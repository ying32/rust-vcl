/*
    The code is automatically generated by the genBind tool.
    Author: ying32
    https://github.com/ying32
*/

#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_unsafe)]

use lclapi::*;
use types::*;

use std::borrow::Cow;
use std::ffi::{CStr, CString};

// IObject IComponent IControl IWinControl只是用来让编译器知道这几个的关系的
pub trait IObject {
    fn Instance(&self) -> usize;
}
pub trait IComponent: IObject {}
pub trait IControl: IComponent {}
pub trait IWinControl: IControl {}
pub trait IStrings: IObject {}


/* 先定义所有的类 */
pub struct TObject(usize, bool);
pub struct TComponent(usize, bool);
pub struct TControl(usize, bool);
pub struct TWinControl(usize, bool);
pub struct TMainMenu(usize, bool);
pub struct TPopupMenu(usize, bool);
pub struct TMemo(usize, bool);
pub struct TCheckBox(usize, bool);
pub struct TRadioButton(usize, bool);
pub struct TGroupBox(usize, bool);
pub struct TLabel(usize, bool);
pub struct TListBox(usize, bool);
pub struct TComboBox(usize, bool);
pub struct TPanel(usize, bool);
pub struct TImage(usize, bool);
pub struct TLinkLabel(usize, bool);
pub struct TSpeedButton(usize, bool);
pub struct TSplitter(usize, bool);
pub struct TRadioGroup(usize, bool);
pub struct TStaticText(usize, bool);
pub struct TColorBox(usize, bool);
pub struct TColorListBox(usize, bool);
pub struct TTrayIcon(usize, bool);
pub struct TOpenDialog(usize, bool);
pub struct TSaveDialog(usize, bool);
pub struct TColorDialog(usize, bool);
pub struct TFontDialog(usize, bool);
pub struct TPrintDialog(usize, bool);
pub struct TOpenPictureDialog(usize, bool);
pub struct TSavePictureDialog(usize, bool);
pub struct TSelectDirectoryDialog(usize, bool);
pub struct TRichEdit(usize, bool);
pub struct TTrackBar(usize, bool);
pub struct TImageList(usize, bool);
pub struct TUpDown(usize, bool);
pub struct TProgressBar(usize, bool);
pub struct TDateTimePicker(usize, bool);
pub struct TMonthCalendar(usize, bool);
pub struct TListView(usize, bool);
pub struct TTreeView(usize, bool);
pub struct TStatusBar(usize, bool);
pub struct TToolBar(usize, bool);
pub struct TBitBtn(usize, bool);
pub struct TIcon(usize, bool);
pub struct TBitmap(usize, bool);
pub struct TMemoryStream(usize, bool);
pub struct TFont(usize, bool);
pub struct TStrings(usize, bool);
pub struct TStringList(usize, bool);
pub struct TBrush(usize, bool);
pub struct TPen(usize, bool);
pub struct TMenuItem(usize, bool);
pub struct TPicture(usize, bool);
pub struct TListColumns(usize, bool);
pub struct TListItems(usize, bool);
pub struct TTreeNodes(usize, bool);
pub struct TListItem(usize, bool);
pub struct TTreeNode(usize, bool);
pub struct TPageControl(usize, bool);
pub struct TTabSheet(usize, bool);
pub struct TButton(usize, bool);
pub struct TEdit(usize, bool);
pub struct TScreen(usize, bool);
pub struct TMouse(usize, bool);
pub struct TListColumn(usize, bool);
pub struct TCollectionItem(usize, bool);
pub struct TStatusPanels(usize, bool);
pub struct TStatusPanel(usize, bool);
pub struct TSpinEdit(usize, bool);
pub struct TMiniWebview(usize, bool);
pub struct TCanvas(usize, bool);
pub struct TApplication(usize, bool);
pub struct TGraphic(usize, bool);
pub struct TPngImage(usize, bool);
pub struct TJPEGImage(usize, bool);
pub struct TGIFImage(usize, bool);
pub struct TActionList(usize, bool);
pub struct TAction(usize, bool);
pub struct TToolButton(usize, bool);
pub struct TIniFile(usize, bool);
pub struct TRegistry(usize, bool);
pub struct TClipboard(usize, bool);
pub struct TMonitor(usize, bool);
pub struct TPaintBox(usize, bool);
pub struct TTimer(usize, bool);
pub struct TList(usize, bool);
pub struct TForm(usize, bool);
pub struct TParaAttributes(usize, bool);
pub struct TTextAttributes(usize, bool);
pub struct TIconOptions(usize, bool);
pub struct Exception(usize, bool);
pub struct TScrollBar(usize, bool);
pub struct TMaskEdit(usize, bool);
pub struct TShape(usize, bool);
pub struct TBevel(usize, bool);
pub struct TScrollBox(usize, bool);
pub struct TCheckListBox(usize, bool);
pub struct TGauge(usize, bool);
pub struct TImageButton(usize, bool);
pub struct TFindDialog(usize, bool);
pub struct TReplaceDialog(usize, bool);
pub struct TPrinterSetupDialog(usize, bool);
pub struct TPageSetupDialog(usize, bool);
pub struct TDragObject(usize, bool);
pub struct TDragDockObject(usize, bool);
pub struct TStringGrid(usize, bool);
pub struct TDrawGrid(usize, bool);
pub struct TValueListEditor(usize, bool);
pub struct THeaderControl(usize, bool);
pub struct THeaderSection(usize, bool);
pub struct THeaderSections(usize, bool);
pub struct TLabeledEdit(usize, bool);
pub struct TBoundLabel(usize, bool);
pub struct TFlowPanel(usize, bool);
pub struct TCoolBar(usize, bool);
pub struct TCoolBands(usize, bool);
pub struct TCoolBand(usize, bool);
pub struct TCollection(usize, bool);
pub struct TPrinter(usize, bool);
pub struct TTaskDialog(usize, bool);
pub struct TTaskDialogButtons(usize, bool);
pub struct TTaskDialogButtonItem(usize, bool);
pub struct TTaskDialogRadioButtonItem(usize, bool);
pub struct TTaskDialogBaseButtonItem(usize, bool);
pub struct TComboBoxEx(usize, bool);
pub struct TComboExItems(usize, bool);
pub struct TComboExItem(usize, bool);
pub struct TFrame(usize, bool);
pub struct TControlScrollBar(usize, bool);
pub struct TSizeConstraints(usize, bool);
pub struct TXButton(usize, bool);
pub struct TAnchorSide(usize, bool);
pub struct TControlBorderSpacing(usize, bool);
pub struct TControlChildSizing(usize, bool);
pub struct TCheckGroup(usize, bool);
pub struct TToggleBox(usize, bool);
pub struct TGridColumnTitle(usize, bool);
pub struct TGridColumn(usize, bool);
pub struct TGridColumns(usize, bool);
/* 开始实现接口 */

impl TObject {
      pub fn new() -> Self {
        method_Create!(TObject, Object_Create, );
      }

      impl_As_method!(TObject);

	  impl_Free_method!(Object_Free);

	  pub fn ClassType(&self) -> TClass  {
          return method_Call_1!(Object_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Object_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32  {
          return method_Call_1!(Object_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool  {
          return method_Call_1!(Object_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool  {
          return method_Call_1!(Object_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32  {
          return method_Call_1!(Object_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Object_ToString, self.0));
      }

      // static class
	  impl_Class_method!(Object_StaticClassType);
}

impl_IObject!(TObject);
impl_Drop_method!(TObject);

impl TComponent {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TComponent, Component_Create, aOwner.Instance());
      }

      impl_As_method!(TComponent);

	  impl_Free_method!(Component_Free);

	  pub fn FindComponent(&self, aName: &str) -> TComponent  {
          return method_Call_2!(TComponent, Component_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Component_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool  {
          return method_Call_1!(Component_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(Component_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Component_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Component_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Component_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Component_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Component_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Component_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Component_ToString, self.0));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Component_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Component_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Component_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Component_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Component_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Component_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Component_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Component_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Component_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(Component_StaticClassType);
}

impl_IObject!(TComponent);
impl_IComponent!(TComponent);
impl_Drop_method!(TComponent);

impl TControl {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TControl, Control_Create, aOwner.Instance());
      }

      impl_As_method!(TControl);

	  impl_Free_method!(Control_Free);

	  pub fn BringToFront(&self)  {
          method_Call_1!(Control_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint  {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Control_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint  {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Control_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool  {
          return method_Call_1!(Control_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Control_HasParent, self.0);
      }

	  pub fn Hide(&self)  {
          method_Call_1!(Control_Hide, self.0);
      }

	  pub fn Invalidate(&self)  {
          method_Call_1!(Control_Invalidate, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize  {
          return method_Call_1!(Control_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self)  {
          method_Call_1!(Control_Refresh, self.0);
      }

	  pub fn Repaint(&self)  {
          method_Call_1!(Control_Repaint, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint  {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Control_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint  {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Control_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self)  {
          method_Call_1!(Control_SendToBack, self.0);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32)  {
          method_Call_1!(Control_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn Show(&self)  {
          method_Call_1!(Control_Show, self.0);
      }

	  pub fn Update(&self)  {
          method_Call_1!(Control_Update, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32  {
          return method_Call_1!(Control_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32  {
          return method_Call_1!(Control_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str)  {
          method_Call_1!(Control_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Control_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Control_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Control_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Control_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Control_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Control_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Control_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Control_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Control_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Control_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl)  {
          method_Call_1!(Control_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl)  {
          method_Call_1!(Control_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl)  {
          method_Call_1!(Control_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl)  {
          method_Call_1!(Control_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32)  {
          method_Call_1!(Control_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32)  {
          method_Call_1!(Control_AnchorClient, self.0, aSpace);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(Control_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(Control_SetEnabled, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, Control_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(Control_SetAction, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(Control_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(Control_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(Control_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(Control_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(Control_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(Control_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Control_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(Control_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(Control_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(Control_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(Control_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Control_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(Control_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(Control_SetClientWidth, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, Control_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(Control_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(Control_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(Control_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(Control_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(Control_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(Control_GetFloating, self.0);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(Control_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(Control_SetShowHint, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(Control_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(Control_SetVisible, self.0, aValue);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Control_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(Control_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(Control_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(Control_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(Control_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(Control_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Control_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Control_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Control_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Control_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(Control_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(Control_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Control_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(Control_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Control_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Control_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Control_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Control_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Control_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Control_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Control_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Control_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Control_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Control_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Control_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Control_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Control_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Control_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Control_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Control_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, Control_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(Control_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Control_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Control_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(Control_StaticClassType);
}

impl_IObject!(TControl);
impl_IComponent!(TControl);
impl_IControl!(TControl);

impl TWinControl {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TWinControl, WinControl_Create, aOwner.Instance());
      }

      impl_As_method!(TWinControl);

	  impl_Free_method!(WinControl_Free);

	  pub fn CanFocus(&self) -> bool  {
          return method_Call_1!(WinControl_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool  {
          return method_Call_1!(WinControl_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl  {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, WinControl_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self)  {
          method_Call_1!(WinControl_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self)  {
          method_Call_1!(WinControl_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl  {
          return method_Call_2!(TControl, WinControl_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool)  {
          method_Call_1!(WinControl_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool  {
          return method_Call_1!(WinControl_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool  {
          return method_Call_1!(WinControl_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl)  {
          method_Call_1!(WinControl_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(WinControl_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl)  {
          method_Call_1!(WinControl_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self)  {
          method_Call_1!(WinControl_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(WinControl_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32)  {
          method_Call_1!(WinControl_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32)  {
          method_Call_1!(WinControl_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(WinControl_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self)  {
          method_Call_1!(WinControl_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(WinControl_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(WinControl_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(WinControl_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(WinControl_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(WinControl_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(WinControl_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(WinControl_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(WinControl_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(WinControl_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(WinControl_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(WinControl_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(WinControl_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(WinControl_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(WinControl_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(WinControl_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(WinControl_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, WinControl_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(WinControl_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(WinControl_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(WinControl_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(WinControl_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(WinControl_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(WinControl_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(WinControl_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(WinControl_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(WinControl_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(WinControl_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(WinControl_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(WinControl_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(WinControl_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(WinControl_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(WinControl_AnchorClient, self.0, aSpace);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(WinControl_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(WinControl_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(WinControl_SetDockSite, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(WinControl_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(WinControl_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(WinControl_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(WinControl_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, WinControl_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(WinControl_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(WinControl_GetHandle, self.0);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(WinControl_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(WinControl_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(WinControl_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(WinControl_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(WinControl_GetShowing, self.0);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(WinControl_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(WinControl_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(WinControl_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(WinControl_SetTabStop, self.0, aValue);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(WinControl_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(WinControl_SetUseDockManager, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(WinControl_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(WinControl_SetEnabled, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, WinControl_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(WinControl_SetAction, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(WinControl_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(WinControl_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(WinControl_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(WinControl_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(WinControl_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(WinControl_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(WinControl_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(WinControl_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(WinControl_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(WinControl_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(WinControl_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(WinControl_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(WinControl_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(WinControl_SetClientWidth, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, WinControl_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(WinControl_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(WinControl_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(WinControl_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(WinControl_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(WinControl_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(WinControl_GetFloating, self.0);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(WinControl_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(WinControl_SetShowHint, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(WinControl_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(WinControl_SetVisible, self.0, aValue);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, WinControl_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(WinControl_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(WinControl_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(WinControl_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(WinControl_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(WinControl_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(WinControl_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(WinControl_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(WinControl_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(WinControl_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(WinControl_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(WinControl_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(WinControl_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(WinControl_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(WinControl_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(WinControl_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(WinControl_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, WinControl_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(WinControl_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(WinControl_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(WinControl_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(WinControl_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, WinControl_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(WinControl_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, WinControl_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(WinControl_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, WinControl_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(WinControl_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, WinControl_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(WinControl_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, WinControl_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(WinControl_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, WinControl_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(WinControl_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, WinControl_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, WinControl_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, WinControl_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, WinControl_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(WinControl_StaticClassType);
}

impl_IObject!(TWinControl);
impl_IComponent!(TWinControl);
impl_IControl!(TWinControl);
impl_IWinControl!(TWinControl);

impl TMainMenu {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TMainMenu, MainMenu_Create, aOwner.Instance());
      }

      impl_As_method!(TMainMenu);

	  impl_Free_method!(MainMenu_Free);

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, MainMenu_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MainMenu_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(MainMenu_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(MainMenu_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(MainMenu_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MainMenu_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(MainMenu_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(MainMenu_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(MainMenu_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(MainMenu_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MainMenu_ToString, self.0));
      }

	  pub fn ImagesWidth(&self) -> i32  {
          return method_Call_1!(MainMenu_GetImagesWidth, self.0);
      }

	  pub fn SetImagesWidth(&self, aValue: i32)  {
          method_Call_1!(MainMenu_SetImagesWidth, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(MainMenu_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(MainMenu_SetBiDiMode, self.0, aValue);
      }

	  pub fn Images(&self) -> TImageList  {
          return method_Call_2!(TImageList, MainMenu_GetImages, self.0);
      }

	  pub fn SetImages(&self, aValue: &TImageList)  {
          method_Call_1!(MainMenu_SetImages, self.0, aValue.Instance());
      }

	  pub fn OwnerDraw(&self) -> bool  {
          return method_Call_1!(MainMenu_GetOwnerDraw, self.0);
      }

	  pub fn SetOwnerDraw(&self, aValue: bool)  {
          method_Call_1!(MainMenu_SetOwnerDraw, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TMenuChangeEvent)  {
          method_Call_1!(MainMenu_SetOnChange, self.0, aEventId);
      }

	  pub fn Handle(&self) -> HMENU  {
          return method_Call_1!(MainMenu_GetHandle, self.0);
      }

	  pub fn Items(&self) -> TMenuItem  {
          return method_Call_2!(TMenuItem, MainMenu_GetItems, self.0);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(MainMenu_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(MainMenu_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(MainMenu_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, MainMenu_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MainMenu_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(MainMenu_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(MainMenu_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(MainMenu_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, MainMenu_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(MainMenu_StaticClassType);
}

impl_IObject!(TMainMenu);
impl_IComponent!(TMainMenu);

impl TPopupMenu {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TPopupMenu, PopupMenu_Create, aOwner.Instance());
      }

      impl_As_method!(TPopupMenu);

	  impl_Free_method!(PopupMenu_Free);

	  pub fn CloseMenu(&self)  {
          method_Call_1!(PopupMenu_CloseMenu, self.0);
      }

	  pub fn Popup(&self, x: i32, y: i32)  {
          method_Call_1!(PopupMenu_Popup, self.0, x, y);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, PopupMenu_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PopupMenu_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(PopupMenu_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(PopupMenu_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(PopupMenu_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PopupMenu_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(PopupMenu_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(PopupMenu_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(PopupMenu_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(PopupMenu_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PopupMenu_ToString, self.0));
      }

	  pub fn ImagesWidth(&self) -> i32  {
          return method_Call_1!(PopupMenu_GetImagesWidth, self.0);
      }

	  pub fn SetImagesWidth(&self, aValue: i32)  {
          method_Call_1!(PopupMenu_SetImagesWidth, self.0, aValue);
      }

	  pub fn PopupComponent(&self) -> TComponent  {
          return method_Call_2!(TComponent, PopupMenu_GetPopupComponent, self.0);
      }

	  pub fn SetPopupComponent(&self, aValue: &dyn IComponent)  {
          method_Call_1!(PopupMenu_SetPopupComponent, self.0, aValue.Instance());
      }

	  pub fn PopupPoint(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(PopupMenu_GetPopupPoint, self.0, &mut result);
          return result;
      }

	  pub fn Alignment(&self) -> TPopupAlignment  {
          return method_Call_1!(PopupMenu_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TPopupAlignment)  {
          method_Call_1!(PopupMenu_SetAlignment, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(PopupMenu_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(PopupMenu_SetBiDiMode, self.0, aValue);
      }

	  pub fn Images(&self) -> TImageList  {
          return method_Call_2!(TImageList, PopupMenu_GetImages, self.0);
      }

	  pub fn SetImages(&self, aValue: &TImageList)  {
          method_Call_1!(PopupMenu_SetImages, self.0, aValue.Instance());
      }

	  pub fn OwnerDraw(&self) -> bool  {
          return method_Call_1!(PopupMenu_GetOwnerDraw, self.0);
      }

	  pub fn SetOwnerDraw(&self, aValue: bool)  {
          method_Call_1!(PopupMenu_SetOwnerDraw, self.0, aValue);
      }

	  pub fn SetOnPopup(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PopupMenu_SetOnPopup, self.0, aEventId);
      }

	  pub fn Handle(&self) -> HMENU  {
          return method_Call_1!(PopupMenu_GetHandle, self.0);
      }

	  pub fn Items(&self) -> TMenuItem  {
          return method_Call_2!(TMenuItem, PopupMenu_GetItems, self.0);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(PopupMenu_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(PopupMenu_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(PopupMenu_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, PopupMenu_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(PopupMenu_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(PopupMenu_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(PopupMenu_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(PopupMenu_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, PopupMenu_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(PopupMenu_StaticClassType);
}

impl_IObject!(TPopupMenu);
impl_IComponent!(TPopupMenu);

impl TMemo {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TMemo, Memo_Create, aOwner.Instance());
      }

      impl_As_method!(TMemo);

	  impl_Free_method!(Memo_Free);

	  pub fn Append(&self, value: &str)  {
          method_Call_1!(Memo_Append, self.0, to_CString!(value));
      }

	  pub fn Clear(&self)  {
          method_Call_1!(Memo_Clear, self.0);
      }

	  pub fn ClearSelection(&self)  {
          method_Call_1!(Memo_ClearSelection, self.0);
      }

	  pub fn CopyToClipboard(&self)  {
          method_Call_1!(Memo_CopyToClipboard, self.0);
      }

	  pub fn CutToClipboard(&self)  {
          method_Call_1!(Memo_CutToClipboard, self.0);
      }

	  pub fn PasteFromClipboard(&self)  {
          method_Call_1!(Memo_PasteFromClipboard, self.0);
      }

	  pub fn Undo(&self)  {
          method_Call_1!(Memo_Undo, self.0);
      }

	  pub fn SelectAll(&self)  {
          method_Call_1!(Memo_SelectAll, self.0);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(Memo_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(Memo_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, Memo_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(Memo_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(Memo_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, Memo_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(Memo_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(Memo_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(Memo_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(Memo_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(Memo_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(Memo_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(Memo_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(Memo_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(Memo_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(Memo_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(Memo_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(Memo_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(Memo_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(Memo_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Memo_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Memo_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(Memo_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Memo_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(Memo_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(Memo_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(Memo_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Memo_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Memo_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(Memo_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(Memo_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(Memo_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(Memo_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(Memo_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Memo_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Memo_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Memo_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Memo_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Memo_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Memo_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Memo_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Memo_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Memo_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Memo_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Memo_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Memo_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Memo_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Memo_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(Memo_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(Memo_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(Memo_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(Memo_SetAlign, self.0, aValue);
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(Memo_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(Memo_SetAlignment, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(Memo_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(Memo_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(Memo_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(Memo_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(Memo_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(Memo_SetBorderStyle, self.0, aValue);
      }

	  pub fn CharCase(&self) -> TEditCharCase  {
          return method_Call_1!(Memo_GetCharCase, self.0);
      }

	  pub fn SetCharCase(&self, aValue: TEditCharCase)  {
          method_Call_1!(Memo_SetCharCase, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(Memo_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(Memo_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, Memo_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(Memo_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(Memo_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(Memo_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(Memo_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(Memo_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(Memo_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(Memo_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(Memo_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(Memo_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(Memo_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(Memo_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, Memo_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(Memo_SetFont, self.0, aValue.Instance());
      }

	  pub fn HideSelection(&self) -> bool  {
          return method_Call_1!(Memo_GetHideSelection, self.0);
      }

	  pub fn SetHideSelection(&self, aValue: bool)  {
          method_Call_1!(Memo_SetHideSelection, self.0, aValue);
      }

	  pub fn Lines(&self) -> TStrings  {
          return method_Call_2!(TStrings, Memo_GetLines, self.0);
      }

	  pub fn SetLines(&self, aValue: &dyn IStrings)  {
          method_Call_1!(Memo_SetLines, self.0, aValue.Instance());
      }

	  pub fn MaxLength(&self) -> i32  {
          return method_Call_1!(Memo_GetMaxLength, self.0);
      }

	  pub fn SetMaxLength(&self, aValue: i32)  {
          method_Call_1!(Memo_SetMaxLength, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(Memo_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(Memo_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(Memo_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(Memo_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(Memo_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(Memo_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(Memo_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(Memo_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, Memo_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(Memo_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ReadOnly(&self) -> bool  {
          return method_Call_1!(Memo_GetReadOnly, self.0);
      }

	  pub fn SetReadOnly(&self, aValue: bool)  {
          method_Call_1!(Memo_SetReadOnly, self.0, aValue);
      }

	  pub fn ScrollBars(&self) -> TScrollStyle  {
          return method_Call_1!(Memo_GetScrollBars, self.0);
      }

	  pub fn SetScrollBars(&self, aValue: TScrollStyle)  {
          method_Call_1!(Memo_SetScrollBars, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(Memo_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(Memo_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(Memo_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(Memo_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(Memo_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(Memo_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(Memo_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(Memo_SetVisible, self.0, aValue);
      }

	  pub fn WantReturns(&self) -> bool  {
          return method_Call_1!(Memo_GetWantReturns, self.0);
      }

	  pub fn SetWantReturns(&self, aValue: bool)  {
          method_Call_1!(Memo_SetWantReturns, self.0, aValue);
      }

	  pub fn WantTabs(&self) -> bool  {
          return method_Call_1!(Memo_GetWantTabs, self.0);
      }

	  pub fn SetWantTabs(&self, aValue: bool)  {
          method_Call_1!(Memo_SetWantTabs, self.0, aValue);
      }

	  pub fn WordWrap(&self) -> bool  {
          return method_Call_1!(Memo_GetWordWrap, self.0);
      }

	  pub fn SetWordWrap(&self, aValue: bool)  {
          method_Call_1!(Memo_SetWordWrap, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Memo_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Memo_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(Memo_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Memo_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(Memo_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(Memo_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(Memo_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Memo_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Memo_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(Memo_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(Memo_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(Memo_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Memo_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Memo_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Memo_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(Memo_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Memo_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn CaretPos(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(Memo_GetCaretPos, self.0, &mut result);
          return result;
      }

	  pub fn SetCaretPos(&self, aValue: *mut TPoint)  {
          method_Call_1!(Memo_SetCaretPos, self.0, aValue);
      }

	  pub fn CanUndo(&self) -> bool  {
          return method_Call_1!(Memo_GetCanUndo, self.0);
      }

	  pub fn Modified(&self) -> bool  {
          return method_Call_1!(Memo_GetModified, self.0);
      }

	  pub fn SetModified(&self, aValue: bool)  {
          method_Call_1!(Memo_SetModified, self.0, aValue);
      }

	  pub fn SelLength(&self) -> i32  {
          return method_Call_1!(Memo_GetSelLength, self.0);
      }

	  pub fn SetSelLength(&self, aValue: i32)  {
          method_Call_1!(Memo_SetSelLength, self.0, aValue);
      }

	  pub fn SelStart(&self) -> i32  {
          return method_Call_1!(Memo_GetSelStart, self.0);
      }

	  pub fn SetSelStart(&self, aValue: i32)  {
          method_Call_1!(Memo_SetSelStart, self.0, aValue);
      }

	  pub fn SelText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Memo_GetSelText, self.0));
      }

	  pub fn SetSelText(&self, aValue: &str)  {
          method_Call_1!(Memo_SetSelText, self.0, to_CString!(aValue));
      }

	  pub fn Text<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Memo_GetText, self.0));
      }

	  pub fn SetText(&self, aValue: &str)  {
          method_Call_1!(Memo_SetText, self.0, to_CString!(aValue));
      }

	  pub fn TextHint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Memo_GetTextHint, self.0));
      }

	  pub fn SetTextHint(&self, aValue: &str)  {
          method_Call_1!(Memo_SetTextHint, self.0, to_CString!(aValue));
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(Memo_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(Memo_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(Memo_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(Memo_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(Memo_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, Memo_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(Memo_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(Memo_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(Memo_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(Memo_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(Memo_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(Memo_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(Memo_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, Memo_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(Memo_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Memo_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(Memo_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(Memo_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(Memo_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(Memo_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Memo_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(Memo_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(Memo_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(Memo_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(Memo_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(Memo_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(Memo_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(Memo_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Memo_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(Memo_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(Memo_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(Memo_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(Memo_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(Memo_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Memo_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Memo_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Memo_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Memo_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(Memo_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(Memo_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Memo_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(Memo_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Memo_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Memo_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Memo_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Memo_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Memo_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Memo_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Memo_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Memo_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Memo_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Memo_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Memo_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Memo_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Memo_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Memo_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Memo_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Memo_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, Memo_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(Memo_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, Memo_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(Memo_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, Memo_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, Memo_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Memo_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Memo_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(Memo_StaticClassType);
}

impl_IObject!(TMemo);
impl_IComponent!(TMemo);
impl_IControl!(TMemo);
impl_IWinControl!(TMemo);

impl TCheckBox {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TCheckBox, CheckBox_Create, aOwner.Instance());
      }

      impl_As_method!(TCheckBox);

	  impl_Free_method!(CheckBox_Free);

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(CheckBox_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(CheckBox_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, CheckBox_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(CheckBox_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(CheckBox_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, CheckBox_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(CheckBox_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(CheckBox_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(CheckBox_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(CheckBox_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(CheckBox_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(CheckBox_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(CheckBox_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(CheckBox_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(CheckBox_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(CheckBox_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(CheckBox_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(CheckBox_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(CheckBox_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(CheckBox_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CheckBox_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CheckBox_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(CheckBox_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(CheckBox_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(CheckBox_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(CheckBox_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(CheckBox_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CheckBox_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CheckBox_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(CheckBox_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(CheckBox_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(CheckBox_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(CheckBox_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(CheckBox_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, CheckBox_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CheckBox_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(CheckBox_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(CheckBox_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CheckBox_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(CheckBox_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(CheckBox_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(CheckBox_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(CheckBox_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CheckBox_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(CheckBox_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(CheckBox_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(CheckBox_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(CheckBox_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(CheckBox_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(CheckBox_AnchorClient, self.0, aSpace);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckBox_SetOnChange, self.0, aEventId);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, CheckBox_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(CheckBox_SetAction, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(CheckBox_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(CheckBox_SetAlign, self.0, aValue);
      }

	  pub fn Alignment(&self) -> TLeftRight  {
          return method_Call_1!(CheckBox_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TLeftRight)  {
          method_Call_1!(CheckBox_SetAlignment, self.0, aValue);
      }

	  pub fn AllowGrayed(&self) -> bool  {
          return method_Call_1!(CheckBox_GetAllowGrayed, self.0);
      }

	  pub fn SetAllowGrayed(&self, aValue: bool)  {
          method_Call_1!(CheckBox_SetAllowGrayed, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(CheckBox_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(CheckBox_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(CheckBox_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(CheckBox_SetBiDiMode, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CheckBox_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(CheckBox_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Checked(&self) -> bool  {
          return method_Call_1!(CheckBox_GetChecked, self.0);
      }

	  pub fn SetChecked(&self, aValue: bool)  {
          method_Call_1!(CheckBox_SetChecked, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(CheckBox_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(CheckBox_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, CheckBox_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(CheckBox_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(CheckBox_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(CheckBox_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(CheckBox_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(CheckBox_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(CheckBox_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(CheckBox_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(CheckBox_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(CheckBox_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(CheckBox_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(CheckBox_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, CheckBox_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(CheckBox_SetFont, self.0, aValue.Instance());
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(CheckBox_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(CheckBox_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(CheckBox_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(CheckBox_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(CheckBox_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(CheckBox_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(CheckBox_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(CheckBox_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, CheckBox_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(CheckBox_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(CheckBox_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(CheckBox_SetShowHint, self.0, aValue);
      }

	  pub fn State(&self) -> TCheckBoxState  {
          return method_Call_1!(CheckBox_GetState, self.0);
      }

	  pub fn SetState(&self, aValue: TCheckBoxState)  {
          method_Call_1!(CheckBox_SetState, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(CheckBox_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(CheckBox_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(CheckBox_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(CheckBox_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(CheckBox_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(CheckBox_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckBox_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(CheckBox_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(CheckBox_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(CheckBox_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(CheckBox_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckBox_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckBox_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(CheckBox_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(CheckBox_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(CheckBox_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(CheckBox_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckBox_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckBox_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(CheckBox_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(CheckBox_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(CheckBox_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(CheckBox_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(CheckBox_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(CheckBox_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(CheckBox_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, CheckBox_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(CheckBox_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(CheckBox_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(CheckBox_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(CheckBox_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(CheckBox_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(CheckBox_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(CheckBox_SetUseDockManager, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(CheckBox_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(CheckBox_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(CheckBox_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(CheckBox_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(CheckBox_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(CheckBox_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(CheckBox_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(CheckBox_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(CheckBox_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(CheckBox_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(CheckBox_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(CheckBox_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(CheckBox_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, CheckBox_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(CheckBox_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(CheckBox_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(CheckBox_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(CheckBox_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(CheckBox_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(CheckBox_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(CheckBox_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(CheckBox_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(CheckBox_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(CheckBox_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(CheckBox_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CheckBox_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(CheckBox_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(CheckBox_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(CheckBox_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(CheckBox_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, CheckBox_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CheckBox_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(CheckBox_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(CheckBox_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(CheckBox_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CheckBox_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CheckBox_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CheckBox_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CheckBox_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CheckBox_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CheckBox_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CheckBox_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CheckBox_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, CheckBox_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(CheckBox_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, CheckBox_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(CheckBox_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, CheckBox_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, CheckBox_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, CheckBox_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CheckBox_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(CheckBox_StaticClassType);
}

impl_IObject!(TCheckBox);
impl_IComponent!(TCheckBox);
impl_IControl!(TCheckBox);
impl_IWinControl!(TCheckBox);

impl TRadioButton {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TRadioButton, RadioButton_Create, aOwner.Instance());
      }

      impl_As_method!(TRadioButton);

	  impl_Free_method!(RadioButton_Free);

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(RadioButton_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(RadioButton_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, RadioButton_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(RadioButton_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(RadioButton_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, RadioButton_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(RadioButton_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(RadioButton_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(RadioButton_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(RadioButton_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(RadioButton_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(RadioButton_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(RadioButton_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(RadioButton_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(RadioButton_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(RadioButton_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(RadioButton_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(RadioButton_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(RadioButton_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(RadioButton_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(RadioButton_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(RadioButton_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(RadioButton_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(RadioButton_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(RadioButton_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(RadioButton_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(RadioButton_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(RadioButton_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(RadioButton_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(RadioButton_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(RadioButton_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(RadioButton_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(RadioButton_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(RadioButton_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, RadioButton_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(RadioButton_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(RadioButton_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(RadioButton_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(RadioButton_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(RadioButton_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(RadioButton_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(RadioButton_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(RadioButton_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(RadioButton_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(RadioButton_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(RadioButton_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(RadioButton_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(RadioButton_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(RadioButton_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(RadioButton_AnchorClient, self.0, aSpace);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RadioButton_SetOnChange, self.0, aEventId);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, RadioButton_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(RadioButton_SetAction, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(RadioButton_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(RadioButton_SetAlign, self.0, aValue);
      }

	  pub fn Alignment(&self) -> TLeftRight  {
          return method_Call_1!(RadioButton_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TLeftRight)  {
          method_Call_1!(RadioButton_SetAlignment, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(RadioButton_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(RadioButton_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(RadioButton_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(RadioButton_SetBiDiMode, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(RadioButton_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(RadioButton_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Checked(&self) -> bool  {
          return method_Call_1!(RadioButton_GetChecked, self.0);
      }

	  pub fn SetChecked(&self, aValue: bool)  {
          method_Call_1!(RadioButton_SetChecked, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(RadioButton_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(RadioButton_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, RadioButton_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(RadioButton_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(RadioButton_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(RadioButton_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(RadioButton_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(RadioButton_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(RadioButton_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(RadioButton_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(RadioButton_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(RadioButton_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(RadioButton_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(RadioButton_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, RadioButton_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(RadioButton_SetFont, self.0, aValue.Instance());
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(RadioButton_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(RadioButton_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(RadioButton_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(RadioButton_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(RadioButton_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(RadioButton_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(RadioButton_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(RadioButton_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, RadioButton_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(RadioButton_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(RadioButton_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(RadioButton_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(RadioButton_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(RadioButton_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(RadioButton_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(RadioButton_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(RadioButton_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(RadioButton_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RadioButton_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(RadioButton_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(RadioButton_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(RadioButton_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(RadioButton_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RadioButton_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RadioButton_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(RadioButton_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(RadioButton_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(RadioButton_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(RadioButton_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RadioButton_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RadioButton_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(RadioButton_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(RadioButton_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(RadioButton_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(RadioButton_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(RadioButton_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(RadioButton_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(RadioButton_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, RadioButton_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(RadioButton_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(RadioButton_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(RadioButton_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(RadioButton_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(RadioButton_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(RadioButton_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(RadioButton_SetUseDockManager, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(RadioButton_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(RadioButton_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(RadioButton_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(RadioButton_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(RadioButton_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(RadioButton_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(RadioButton_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(RadioButton_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(RadioButton_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(RadioButton_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(RadioButton_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(RadioButton_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(RadioButton_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, RadioButton_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(RadioButton_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(RadioButton_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(RadioButton_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(RadioButton_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(RadioButton_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(RadioButton_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(RadioButton_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(RadioButton_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(RadioButton_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(RadioButton_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(RadioButton_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(RadioButton_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(RadioButton_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(RadioButton_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(RadioButton_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(RadioButton_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, RadioButton_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(RadioButton_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(RadioButton_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(RadioButton_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(RadioButton_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, RadioButton_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(RadioButton_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, RadioButton_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(RadioButton_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, RadioButton_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(RadioButton_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, RadioButton_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(RadioButton_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, RadioButton_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(RadioButton_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, RadioButton_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(RadioButton_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, RadioButton_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, RadioButton_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, RadioButton_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, RadioButton_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(RadioButton_StaticClassType);
}

impl_IObject!(TRadioButton);
impl_IComponent!(TRadioButton);
impl_IControl!(TRadioButton);
impl_IWinControl!(TRadioButton);

impl TGroupBox {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TGroupBox, GroupBox_Create, aOwner.Instance());
      }

      impl_As_method!(TGroupBox);

	  impl_Free_method!(GroupBox_Free);

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(GroupBox_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(GroupBox_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, GroupBox_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(GroupBox_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(GroupBox_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, GroupBox_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(GroupBox_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(GroupBox_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(GroupBox_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(GroupBox_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(GroupBox_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(GroupBox_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(GroupBox_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(GroupBox_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(GroupBox_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(GroupBox_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(GroupBox_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(GroupBox_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(GroupBox_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(GroupBox_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(GroupBox_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(GroupBox_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(GroupBox_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(GroupBox_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(GroupBox_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(GroupBox_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(GroupBox_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(GroupBox_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(GroupBox_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(GroupBox_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(GroupBox_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(GroupBox_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(GroupBox_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(GroupBox_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, GroupBox_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(GroupBox_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(GroupBox_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(GroupBox_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(GroupBox_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(GroupBox_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(GroupBox_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(GroupBox_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(GroupBox_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(GroupBox_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(GroupBox_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(GroupBox_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(GroupBox_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(GroupBox_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(GroupBox_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(GroupBox_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(GroupBox_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(GroupBox_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(GroupBox_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(GroupBox_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(GroupBox_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(GroupBox_SetBiDiMode, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(GroupBox_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(GroupBox_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(GroupBox_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(GroupBox_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, GroupBox_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(GroupBox_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(GroupBox_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(GroupBox_SetDockSite, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(GroupBox_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(GroupBox_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(GroupBox_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(GroupBox_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(GroupBox_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(GroupBox_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(GroupBox_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(GroupBox_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(GroupBox_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(GroupBox_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, GroupBox_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(GroupBox_SetFont, self.0, aValue.Instance());
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(GroupBox_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(GroupBox_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(GroupBox_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(GroupBox_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(GroupBox_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(GroupBox_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(GroupBox_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(GroupBox_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, GroupBox_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(GroupBox_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(GroupBox_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(GroupBox_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(GroupBox_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(GroupBox_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(GroupBox_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(GroupBox_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(GroupBox_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(GroupBox_SetVisible, self.0, aValue);
      }

	  pub fn SetOnAlignPosition(&self, aEventId: TAlignPositionEvent)  {
          method_Call_1!(GroupBox_SetOnAlignPosition, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(GroupBox_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(GroupBox_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(GroupBox_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(GroupBox_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDockDrop(&self, aEventId: TDockDropEvent)  {
          method_Call_1!(GroupBox_SetOnDockDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(GroupBox_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(GroupBox_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(GroupBox_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(GroupBox_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(GroupBox_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnGetSiteInfo(&self, aEventId: TGetSiteInfoEvent)  {
          method_Call_1!(GroupBox_SetOnGetSiteInfo, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(GroupBox_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(GroupBox_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(GroupBox_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(GroupBox_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(GroupBox_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(GroupBox_SetOnStartDock, self.0, aEventId);
      }

	  pub fn SetOnUnDock(&self, aEventId: TUnDockEvent)  {
          method_Call_1!(GroupBox_SetOnUnDock, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(GroupBox_GetDockClientCount, self.0);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(GroupBox_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(GroupBox_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, GroupBox_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(GroupBox_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(GroupBox_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(GroupBox_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(GroupBox_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(GroupBox_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(GroupBox_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(GroupBox_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, GroupBox_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(GroupBox_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(GroupBox_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(GroupBox_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(GroupBox_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(GroupBox_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(GroupBox_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(GroupBox_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(GroupBox_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(GroupBox_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(GroupBox_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(GroupBox_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(GroupBox_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(GroupBox_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(GroupBox_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, GroupBox_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(GroupBox_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(GroupBox_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(GroupBox_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(GroupBox_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(GroupBox_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(GroupBox_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(GroupBox_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(GroupBox_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(GroupBox_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(GroupBox_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(GroupBox_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(GroupBox_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(GroupBox_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(GroupBox_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(GroupBox_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(GroupBox_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, GroupBox_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(GroupBox_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(GroupBox_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(GroupBox_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(GroupBox_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, GroupBox_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(GroupBox_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, GroupBox_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(GroupBox_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, GroupBox_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(GroupBox_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, GroupBox_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(GroupBox_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, GroupBox_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(GroupBox_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, GroupBox_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(GroupBox_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, GroupBox_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, GroupBox_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, GroupBox_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, GroupBox_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(GroupBox_StaticClassType);
}

impl_IObject!(TGroupBox);
impl_IComponent!(TGroupBox);
impl_IControl!(TGroupBox);
impl_IWinControl!(TGroupBox);

impl TLabel {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TLabel, Label_Create, aOwner.Instance());
      }

      impl_As_method!(TLabel);

	  impl_Free_method!(Label_Free);

	  pub fn BringToFront(&self) {
          method_Call_1!(Label_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Label_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Label_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(Label_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Label_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(Label_Hide, self.0);
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(Label_Invalidate, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(Label_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(Label_Refresh, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(Label_Repaint, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Label_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Label_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(Label_SendToBack, self.0);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(Label_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn Show(&self) {
          method_Call_1!(Label_Show, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(Label_Update, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(Label_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(Label_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(Label_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Label_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Label_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Label_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Label_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Label_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Label_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Label_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Label_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Label_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Label_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Label_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Label_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Label_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Label_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(Label_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(Label_AnchorClient, self.0, aSpace);
      }

	  pub fn OptimalFill(&self) -> bool  {
          return method_Call_1!(Label_GetOptimalFill, self.0);
      }

	  pub fn SetOptimalFill(&self, aValue: bool)  {
          method_Call_1!(Label_SetOptimalFill, self.0, aValue);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(Label_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(Label_SetAlign, self.0, aValue);
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(Label_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(Label_SetAlignment, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(Label_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(Label_SetAnchors, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(Label_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(Label_SetAutoSize, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(Label_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(Label_SetBiDiMode, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Label_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(Label_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(Label_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(Label_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, Label_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(Label_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(Label_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(Label_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(Label_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(Label_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(Label_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(Label_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(Label_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(Label_SetEnabled, self.0, aValue);
      }

	  pub fn FocusControl(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Label_GetFocusControl, self.0);
      }

	  pub fn SetFocusControl(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(Label_SetFocusControl, self.0, aValue.Instance());
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, Label_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(Label_SetFont, self.0, aValue.Instance());
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(Label_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(Label_SetParentColor, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(Label_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(Label_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(Label_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(Label_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, Label_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(Label_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowAccelChar(&self) -> bool  {
          return method_Call_1!(Label_GetShowAccelChar, self.0);
      }

	  pub fn SetShowAccelChar(&self, aValue: bool)  {
          method_Call_1!(Label_SetShowAccelChar, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(Label_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(Label_SetShowHint, self.0, aValue);
      }

	  pub fn Transparent(&self) -> bool  {
          return method_Call_1!(Label_GetTransparent, self.0);
      }

	  pub fn SetTransparent(&self, aValue: bool)  {
          method_Call_1!(Label_SetTransparent, self.0, aValue);
      }

	  pub fn Layout(&self) -> TTextLayout  {
          return method_Call_1!(Label_GetLayout, self.0);
      }

	  pub fn SetLayout(&self, aValue: TTextLayout)  {
          method_Call_1!(Label_SetLayout, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(Label_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(Label_SetVisible, self.0, aValue);
      }

	  pub fn WordWrap(&self) -> bool  {
          return method_Call_1!(Label_GetWordWrap, self.0);
      }

	  pub fn SetWordWrap(&self, aValue: bool)  {
          method_Call_1!(Label_SetWordWrap, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Label_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(Label_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Label_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(Label_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(Label_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(Label_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Label_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(Label_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Label_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Label_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Label_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, Label_GetCanvas, self.0);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, Label_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(Label_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Label_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(Label_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(Label_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(Label_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(Label_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Label_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(Label_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(Label_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(Label_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(Label_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(Label_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(Label_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(Label_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Label_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(Label_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(Label_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(Label_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(Label_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(Label_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Label_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Label_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Label_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Label_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(Label_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(Label_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Label_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(Label_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Label_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Label_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Label_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Label_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Label_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Label_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Label_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Label_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Label_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Label_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Label_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Label_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Label_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Label_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Label_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Label_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, Label_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(Label_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Label_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Label_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(Label_StaticClassType);
}

impl_IObject!(TLabel);
impl_IComponent!(TLabel);
impl_IControl!(TLabel);

impl TListBox {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TListBox, ListBox_Create, aOwner.Instance());
      }

      impl_As_method!(TListBox);

	  impl_Free_method!(ListBox_Free);

	  pub fn AddItem(&self, item: &str, aObject: &dyn IObject)  {
          method_Call_1!(ListBox_AddItem, self.0, to_CString!(item), aObject.Instance());
      }

	  pub fn Clear(&self)  {
          method_Call_1!(ListBox_Clear, self.0);
      }

	  pub fn ClearSelection(&self)  {
          method_Call_1!(ListBox_ClearSelection, self.0);
      }

	  pub fn DeleteSelected(&self)  {
          method_Call_1!(ListBox_DeleteSelected, self.0);
      }

	  pub fn ItemAtPos(&self, pos: &TPoint, existing: bool) -> i32  {
          let mut ps1 = TPoint::From(pos);
          return method_Call_1!(ListBox_ItemAtPos, self.0, &mut ps1, existing);
      }

	  pub fn ItemRect(&self, index: i32) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ListBox_ItemRect, self.0, index, &mut result);
          return result;
      }

	  pub fn SelectAll(&self)  {
          method_Call_1!(ListBox_SelectAll, self.0);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(ListBox_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(ListBox_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, ListBox_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(ListBox_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(ListBox_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, ListBox_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(ListBox_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(ListBox_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(ListBox_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ListBox_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(ListBox_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ListBox_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(ListBox_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(ListBox_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(ListBox_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(ListBox_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(ListBox_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(ListBox_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(ListBox_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(ListBox_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ListBox_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ListBox_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(ListBox_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ListBox_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(ListBox_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(ListBox_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(ListBox_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ListBox_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ListBox_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(ListBox_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(ListBox_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(ListBox_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(ListBox_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(ListBox_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ListBox_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ListBox_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ListBox_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ListBox_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ListBox_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ListBox_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ListBox_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ListBox_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ListBox_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ListBox_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ListBox_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ListBox_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ListBox_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ListBox_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(ListBox_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(ListBox_AnchorClient, self.0, aSpace);
      }

	  pub fn ClickOnSelChange(&self) -> bool  {
          return method_Call_1!(ListBox_GetClickOnSelChange, self.0);
      }

	  pub fn SetClickOnSelChange(&self, aValue: bool)  {
          method_Call_1!(ListBox_SetClickOnSelChange, self.0, aValue);
      }

	  pub fn Options(&self) -> TListBoxOptions  {
          return method_Call_1!(ListBox_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TListBoxOptions)  {
          method_Call_1!(ListBox_SetOptions, self.0, aValue);
      }

	  pub fn TopIndex(&self) -> i32  {
          return method_Call_1!(ListBox_GetTopIndex, self.0);
      }

	  pub fn SetTopIndex(&self, aValue: i32)  {
          method_Call_1!(ListBox_SetTopIndex, self.0, aValue);
      }

	  pub fn Style(&self) -> TListBoxStyle  {
          return method_Call_1!(ListBox_GetStyle, self.0);
      }

	  pub fn SetStyle(&self, aValue: TListBoxStyle)  {
          method_Call_1!(ListBox_SetStyle, self.0, aValue);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(ListBox_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(ListBox_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(ListBox_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(ListBox_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(ListBox_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(ListBox_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(ListBox_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(ListBox_SetBorderStyle, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(ListBox_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(ListBox_SetColor, self.0, aValue);
      }

	  pub fn Columns(&self) -> i32  {
          return method_Call_1!(ListBox_GetColumns, self.0);
      }

	  pub fn SetColumns(&self, aValue: i32)  {
          method_Call_1!(ListBox_SetColumns, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, ListBox_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(ListBox_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(ListBox_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ListBox_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(ListBox_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(ListBox_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(ListBox_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(ListBox_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(ListBox_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(ListBox_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(ListBox_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(ListBox_SetEnabled, self.0, aValue);
      }

	  pub fn ExtendedSelect(&self) -> bool  {
          return method_Call_1!(ListBox_GetExtendedSelect, self.0);
      }

	  pub fn SetExtendedSelect(&self, aValue: bool)  {
          method_Call_1!(ListBox_SetExtendedSelect, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, ListBox_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(ListBox_SetFont, self.0, aValue.Instance());
      }

	  pub fn ItemHeight(&self) -> i32  {
          return method_Call_1!(ListBox_GetItemHeight, self.0);
      }

	  pub fn SetItemHeight(&self, aValue: i32)  {
          method_Call_1!(ListBox_SetItemHeight, self.0, aValue);
      }

	  pub fn Items(&self) -> TStrings  {
          return method_Call_2!(TStrings, ListBox_GetItems, self.0);
      }

	  pub fn SetItems(&self, aValue: &dyn IStrings)  {
          method_Call_1!(ListBox_SetItems, self.0, aValue.Instance());
      }

	  pub fn MultiSelect(&self) -> bool  {
          return method_Call_1!(ListBox_GetMultiSelect, self.0);
      }

	  pub fn SetMultiSelect(&self, aValue: bool)  {
          method_Call_1!(ListBox_SetMultiSelect, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(ListBox_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(ListBox_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(ListBox_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ListBox_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(ListBox_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(ListBox_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(ListBox_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(ListBox_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, ListBox_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(ListBox_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(ListBox_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(ListBox_SetShowHint, self.0, aValue);
      }

	  pub fn Sorted(&self) -> bool  {
          return method_Call_1!(ListBox_GetSorted, self.0);
      }

	  pub fn SetSorted(&self, aValue: bool)  {
          method_Call_1!(ListBox_SetSorted, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(ListBox_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(ListBox_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(ListBox_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(ListBox_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(ListBox_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(ListBox_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ListBox_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(ListBox_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ListBox_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(ListBox_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(ListBox_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnDrawItem(&self, aEventId: TDrawItemEvent)  {
          method_Call_1!(ListBox_SetOnDrawItem, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ListBox_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ListBox_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ListBox_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ListBox_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(ListBox_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ListBox_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMeasureItem(&self, aEventId: TMeasureItemEvent)  {
          method_Call_1!(ListBox_SetOnMeasureItem, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ListBox_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ListBox_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ListBox_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(ListBox_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ListBox_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, ListBox_GetCanvas, self.0);
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(ListBox_GetCount, self.0);
      }

	  pub fn SelCount(&self) -> i32  {
          return method_Call_1!(ListBox_GetSelCount, self.0);
      }

	  pub fn ItemIndex(&self) -> i32  {
          return method_Call_1!(ListBox_GetItemIndex, self.0);
      }

	  pub fn SetItemIndex(&self, aValue: i32)  {
          method_Call_1!(ListBox_SetItemIndex, self.0, aValue);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(ListBox_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(ListBox_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(ListBox_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(ListBox_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(ListBox_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, ListBox_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(ListBox_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(ListBox_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(ListBox_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(ListBox_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(ListBox_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(ListBox_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(ListBox_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, ListBox_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(ListBox_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ListBox_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(ListBox_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(ListBox_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(ListBox_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ListBox_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ListBox_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(ListBox_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(ListBox_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(ListBox_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(ListBox_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(ListBox_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(ListBox_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(ListBox_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, ListBox_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(ListBox_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ListBox_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ListBox_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ListBox_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ListBox_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ListBox_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ListBox_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(ListBox_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(ListBox_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(ListBox_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(ListBox_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ListBox_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(ListBox_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ListBox_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ListBox_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ListBox_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ListBox_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ListBox_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ListBox_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ListBox_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ListBox_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ListBox_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ListBox_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ListBox_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ListBox_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ListBox_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ListBox_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ListBox_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ListBox_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, ListBox_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(ListBox_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, ListBox_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(ListBox_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Selected(&self, index: i32) -> bool  {
          return method_Call_1!(ListBox_GetSelected, self.0, index);
      }

	  pub fn SetSelected(&self, index: i32, aValue: bool)  {
          method_Call_1!(ListBox_SetSelected, self.0, index, aValue);
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ListBox_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ListBox_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ListBox_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ListBox_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(ListBox_StaticClassType);
}

impl_IObject!(TListBox);
impl_IComponent!(TListBox);
impl_IControl!(TListBox);
impl_IWinControl!(TListBox);

impl TComboBox {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TComboBox, ComboBox_Create, aOwner.Instance());
      }

      impl_As_method!(TComboBox);

	  impl_Free_method!(ComboBox_Free);

	  pub fn AddItem(&self, item: &str, aObject: &dyn IObject)  {
          method_Call_1!(ComboBox_AddItem, self.0, to_CString!(item), aObject.Instance());
      }

	  pub fn Clear(&self)  {
          method_Call_1!(ComboBox_Clear, self.0);
      }

	  pub fn ClearSelection(&self)  {
          method_Call_1!(ComboBox_ClearSelection, self.0);
      }

	  pub fn DeleteSelected(&self)  {
          method_Call_1!(ComboBox_DeleteSelected, self.0);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(ComboBox_Focused, self.0);
      }

	  pub fn SelectAll(&self)  {
          method_Call_1!(ComboBox_SelectAll, self.0);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(ComboBox_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(ComboBox_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, ComboBox_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(ComboBox_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(ComboBox_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, ComboBox_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(ComboBox_FlipChildren, self.0, allLevels);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(ComboBox_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ComboBox_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(ComboBox_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ComboBox_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(ComboBox_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(ComboBox_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(ComboBox_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(ComboBox_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(ComboBox_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(ComboBox_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(ComboBox_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(ComboBox_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ComboBox_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ComboBox_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(ComboBox_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ComboBox_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(ComboBox_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(ComboBox_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(ComboBox_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ComboBox_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ComboBox_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(ComboBox_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(ComboBox_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(ComboBox_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(ComboBox_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(ComboBox_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ComboBox_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ComboBox_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ComboBox_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ComboBox_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ComboBox_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ComboBox_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ComboBox_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ComboBox_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ComboBox_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ComboBox_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ComboBox_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ComboBox_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ComboBox_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ComboBox_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(ComboBox_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(ComboBox_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(ComboBox_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(ComboBox_SetAlign, self.0, aValue);
      }

	  pub fn AutoComplete(&self) -> bool  {
          return method_Call_1!(ComboBox_GetAutoComplete, self.0);
      }

	  pub fn SetAutoComplete(&self, aValue: bool)  {
          method_Call_1!(ComboBox_SetAutoComplete, self.0, aValue);
      }

	  pub fn AutoDropDown(&self) -> bool  {
          return method_Call_1!(ComboBox_GetAutoDropDown, self.0);
      }

	  pub fn SetAutoDropDown(&self, aValue: bool)  {
          method_Call_1!(ComboBox_SetAutoDropDown, self.0, aValue);
      }

	  pub fn Style(&self) -> TComboBoxStyle  {
          return method_Call_1!(ComboBox_GetStyle, self.0);
      }

	  pub fn SetStyle(&self, aValue: TComboBoxStyle)  {
          method_Call_1!(ComboBox_SetStyle, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(ComboBox_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(ComboBox_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(ComboBox_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(ComboBox_SetBiDiMode, self.0, aValue);
      }

	  pub fn CharCase(&self) -> TEditCharCase  {
          return method_Call_1!(ComboBox_GetCharCase, self.0);
      }

	  pub fn SetCharCase(&self, aValue: TEditCharCase)  {
          method_Call_1!(ComboBox_SetCharCase, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(ComboBox_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(ComboBox_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, ComboBox_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(ComboBox_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(ComboBox_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ComboBox_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(ComboBox_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(ComboBox_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(ComboBox_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(ComboBox_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(ComboBox_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(ComboBox_SetDragMode, self.0, aValue);
      }

	  pub fn DropDownCount(&self) -> i32  {
          return method_Call_1!(ComboBox_GetDropDownCount, self.0);
      }

	  pub fn SetDropDownCount(&self, aValue: i32)  {
          method_Call_1!(ComboBox_SetDropDownCount, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(ComboBox_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(ComboBox_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, ComboBox_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(ComboBox_SetFont, self.0, aValue.Instance());
      }

	  pub fn ItemHeight(&self) -> i32  {
          return method_Call_1!(ComboBox_GetItemHeight, self.0);
      }

	  pub fn SetItemHeight(&self, aValue: i32)  {
          method_Call_1!(ComboBox_SetItemHeight, self.0, aValue);
      }

	  pub fn ItemIndex(&self) -> i32  {
          return method_Call_1!(ComboBox_GetItemIndex, self.0);
      }

	  pub fn SetItemIndex(&self, aValue: i32)  {
          method_Call_1!(ComboBox_SetItemIndex, self.0, aValue);
      }

	  pub fn MaxLength(&self) -> i32  {
          return method_Call_1!(ComboBox_GetMaxLength, self.0);
      }

	  pub fn SetMaxLength(&self, aValue: i32)  {
          method_Call_1!(ComboBox_SetMaxLength, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(ComboBox_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(ComboBox_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(ComboBox_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ComboBox_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(ComboBox_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(ComboBox_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(ComboBox_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(ComboBox_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, ComboBox_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(ComboBox_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(ComboBox_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(ComboBox_SetShowHint, self.0, aValue);
      }

	  pub fn Sorted(&self) -> bool  {
          return method_Call_1!(ComboBox_GetSorted, self.0);
      }

	  pub fn SetSorted(&self, aValue: bool)  {
          method_Call_1!(ComboBox_SetSorted, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(ComboBox_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(ComboBox_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(ComboBox_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(ComboBox_SetTabStop, self.0, aValue);
      }

	  pub fn Text<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ComboBox_GetText, self.0));
      }

	  pub fn SetText(&self, aValue: &str)  {
          method_Call_1!(ComboBox_SetText, self.0, to_CString!(aValue));
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(ComboBox_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(ComboBox_SetVisible, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBox_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBox_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(ComboBox_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBox_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(ComboBox_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(ComboBox_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnDrawItem(&self, aEventId: TDrawItemEvent)  {
          method_Call_1!(ComboBox_SetOnDrawItem, self.0, aEventId);
      }

	  pub fn SetOnDropDown(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBox_SetOnDropDown, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ComboBox_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBox_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBox_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ComboBox_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(ComboBox_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ComboBox_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMeasureItem(&self, aEventId: TMeasureItemEvent)  {
          method_Call_1!(ComboBox_SetOnMeasureItem, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBox_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBox_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnSelect(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBox_SetOnSelect, self.0, aEventId);
      }

	  pub fn Items(&self) -> TStrings  {
          return method_Call_2!(TStrings, ComboBox_GetItems, self.0);
      }

	  pub fn SetItems(&self, aValue: &dyn IStrings)  {
          method_Call_1!(ComboBox_SetItems, self.0, aValue.Instance());
      }

	  pub fn SelText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ComboBox_GetSelText, self.0));
      }

	  pub fn SetSelText(&self, aValue: &str)  {
          method_Call_1!(ComboBox_SetSelText, self.0, to_CString!(aValue));
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, ComboBox_GetCanvas, self.0);
      }

	  pub fn DroppedDown(&self) -> bool  {
          return method_Call_1!(ComboBox_GetDroppedDown, self.0);
      }

	  pub fn SetDroppedDown(&self, aValue: bool)  {
          method_Call_1!(ComboBox_SetDroppedDown, self.0, aValue);
      }

	  pub fn SelLength(&self) -> i32  {
          return method_Call_1!(ComboBox_GetSelLength, self.0);
      }

	  pub fn SetSelLength(&self, aValue: i32)  {
          method_Call_1!(ComboBox_SetSelLength, self.0, aValue);
      }

	  pub fn SelStart(&self) -> i32  {
          return method_Call_1!(ComboBox_GetSelStart, self.0);
      }

	  pub fn SetSelStart(&self, aValue: i32)  {
          method_Call_1!(ComboBox_SetSelStart, self.0, aValue);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(ComboBox_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(ComboBox_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(ComboBox_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(ComboBox_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(ComboBox_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, ComboBox_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(ComboBox_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(ComboBox_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(ComboBox_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(ComboBox_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(ComboBox_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(ComboBox_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(ComboBox_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, ComboBox_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(ComboBox_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ComboBox_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(ComboBox_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(ComboBox_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(ComboBox_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ComboBox_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ComboBox_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(ComboBox_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(ComboBox_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(ComboBox_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(ComboBox_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(ComboBox_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(ComboBox_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(ComboBox_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, ComboBox_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(ComboBox_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ComboBox_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ComboBox_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ComboBox_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ComboBox_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ComboBox_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ComboBox_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(ComboBox_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(ComboBox_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(ComboBox_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(ComboBox_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ComboBox_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(ComboBox_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ComboBox_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ComboBox_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ComboBox_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ComboBox_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ComboBox_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ComboBox_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ComboBox_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ComboBox_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ComboBox_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ComboBox_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ComboBox_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ComboBox_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ComboBox_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ComboBox_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ComboBox_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ComboBox_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, ComboBox_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(ComboBox_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, ComboBox_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(ComboBox_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ComboBox_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ComboBox_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ComboBox_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ComboBox_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(ComboBox_StaticClassType);
}

impl_IObject!(TComboBox);
impl_IComponent!(TComboBox);
impl_IControl!(TComboBox);
impl_IWinControl!(TComboBox);

impl TPanel {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TPanel, Panel_Create, aOwner.Instance());
      }

      impl_As_method!(TPanel);

	  impl_Free_method!(Panel_Free);

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(Panel_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(Panel_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, Panel_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(Panel_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(Panel_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, Panel_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(Panel_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(Panel_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(Panel_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(Panel_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(Panel_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(Panel_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(Panel_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(Panel_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(Panel_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(Panel_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(Panel_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(Panel_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(Panel_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(Panel_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Panel_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Panel_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(Panel_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Panel_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(Panel_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(Panel_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(Panel_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Panel_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Panel_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(Panel_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(Panel_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(Panel_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(Panel_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(Panel_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Panel_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Panel_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Panel_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Panel_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Panel_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Panel_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Panel_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Panel_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Panel_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Panel_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Panel_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Panel_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Panel_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Panel_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(Panel_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(Panel_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(Panel_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(Panel_SetAlign, self.0, aValue);
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(Panel_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(Panel_SetAlignment, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(Panel_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(Panel_SetAnchors, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(Panel_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(Panel_SetAutoSize, self.0, aValue);
      }

	  pub fn BevelInner(&self) -> TBevelCut  {
          return method_Call_1!(Panel_GetBevelInner, self.0);
      }

	  pub fn SetBevelInner(&self, aValue: TBevelCut)  {
          method_Call_1!(Panel_SetBevelInner, self.0, aValue);
      }

	  pub fn BevelOuter(&self) -> TBevelCut  {
          return method_Call_1!(Panel_GetBevelOuter, self.0);
      }

	  pub fn SetBevelOuter(&self, aValue: TBevelCut)  {
          method_Call_1!(Panel_SetBevelOuter, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(Panel_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(Panel_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderWidth(&self) -> i32  {
          return method_Call_1!(Panel_GetBorderWidth, self.0);
      }

	  pub fn SetBorderWidth(&self, aValue: i32)  {
          method_Call_1!(Panel_SetBorderWidth, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(Panel_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(Panel_SetBorderStyle, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Panel_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(Panel_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(Panel_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(Panel_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, Panel_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(Panel_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(Panel_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(Panel_SetUseDockManager, self.0, aValue);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(Panel_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(Panel_SetDockSite, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(Panel_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(Panel_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(Panel_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(Panel_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(Panel_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(Panel_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(Panel_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(Panel_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(Panel_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(Panel_SetEnabled, self.0, aValue);
      }

	  pub fn FullRepaint(&self) -> bool  {
          return method_Call_1!(Panel_GetFullRepaint, self.0);
      }

	  pub fn SetFullRepaint(&self, aValue: bool)  {
          method_Call_1!(Panel_SetFullRepaint, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, Panel_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(Panel_SetFont, self.0, aValue.Instance());
      }

	  pub fn ParentBackground(&self) -> bool  {
          return method_Call_1!(Panel_GetParentBackground, self.0);
      }

	  pub fn SetParentBackground(&self, aValue: bool)  {
          method_Call_1!(Panel_SetParentBackground, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(Panel_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(Panel_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(Panel_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(Panel_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(Panel_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(Panel_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(Panel_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(Panel_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, Panel_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(Panel_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(Panel_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(Panel_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(Panel_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(Panel_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(Panel_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(Panel_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(Panel_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(Panel_SetVisible, self.0, aValue);
      }

	  pub fn SetOnAlignPosition(&self, aEventId: TAlignPositionEvent)  {
          method_Call_1!(Panel_SetOnAlignPosition, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Panel_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(Panel_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDockDrop(&self, aEventId: TDockDropEvent)  {
          method_Call_1!(Panel_SetOnDockDrop, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Panel_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(Panel_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(Panel_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(Panel_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(Panel_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Panel_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Panel_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnGetSiteInfo(&self, aEventId: TGetSiteInfoEvent)  {
          method_Call_1!(Panel_SetOnGetSiteInfo, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Panel_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Panel_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Panel_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(Panel_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Panel_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnResize(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Panel_SetOnResize, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(Panel_SetOnStartDock, self.0, aEventId);
      }

	  pub fn SetOnUnDock(&self, aEventId: TUnDockEvent)  {
          method_Call_1!(Panel_SetOnUnDock, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(Panel_GetDockClientCount, self.0);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(Panel_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(Panel_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, Panel_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(Panel_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(Panel_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(Panel_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(Panel_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(Panel_GetShowing, self.0);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, Panel_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(Panel_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Panel_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(Panel_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(Panel_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(Panel_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(Panel_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Panel_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(Panel_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(Panel_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(Panel_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(Panel_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(Panel_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(Panel_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(Panel_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Panel_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(Panel_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(Panel_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(Panel_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(Panel_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(Panel_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Panel_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Panel_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Panel_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Panel_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(Panel_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(Panel_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Panel_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(Panel_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Panel_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Panel_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Panel_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Panel_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Panel_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Panel_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Panel_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Panel_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Panel_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Panel_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Panel_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Panel_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Panel_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Panel_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Panel_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Panel_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, Panel_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(Panel_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, Panel_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(Panel_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, Panel_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, Panel_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Panel_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Panel_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(Panel_StaticClassType);
}

impl_IObject!(TPanel);
impl_IComponent!(TPanel);
impl_IControl!(TPanel);
impl_IWinControl!(TPanel);

impl TImage {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TImage, Image_Create, aOwner.Instance());
      }

      impl_As_method!(TImage);

	  impl_Free_method!(Image_Free);

	  pub fn BringToFront(&self) {
          method_Call_1!(Image_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Image_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Image_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(Image_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Image_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(Image_Hide, self.0);
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(Image_Invalidate, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(Image_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(Image_Refresh, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(Image_Repaint, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Image_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Image_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(Image_SendToBack, self.0);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(Image_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn Show(&self) {
          method_Call_1!(Image_Show, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(Image_Update, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(Image_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(Image_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(Image_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Image_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Image_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Image_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Image_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Image_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Image_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Image_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Image_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Image_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Image_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Image_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Image_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Image_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Image_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(Image_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(Image_AnchorClient, self.0, aSpace);
      }

	  pub fn AntialiasingMode(&self) -> TAntialiasingMode  {
          return method_Call_1!(Image_GetAntialiasingMode, self.0);
      }

	  pub fn SetAntialiasingMode(&self, aValue: TAntialiasingMode)  {
          method_Call_1!(Image_SetAntialiasingMode, self.0, aValue);
      }

	  pub fn KeepOriginXWhenClipped(&self) -> bool  {
          return method_Call_1!(Image_GetKeepOriginXWhenClipped, self.0);
      }

	  pub fn SetKeepOriginXWhenClipped(&self, aValue: bool)  {
          method_Call_1!(Image_SetKeepOriginXWhenClipped, self.0, aValue);
      }

	  pub fn KeepOriginYWhenClipped(&self) -> bool  {
          return method_Call_1!(Image_GetKeepOriginYWhenClipped, self.0);
      }

	  pub fn SetKeepOriginYWhenClipped(&self, aValue: bool)  {
          method_Call_1!(Image_SetKeepOriginYWhenClipped, self.0, aValue);
      }

	  pub fn StretchInEnabled(&self) -> bool  {
          return method_Call_1!(Image_GetStretchInEnabled, self.0);
      }

	  pub fn SetStretchInEnabled(&self, aValue: bool)  {
          method_Call_1!(Image_SetStretchInEnabled, self.0, aValue);
      }

	  pub fn StretchOutEnabled(&self) -> bool  {
          return method_Call_1!(Image_GetStretchOutEnabled, self.0);
      }

	  pub fn SetStretchOutEnabled(&self, aValue: bool)  {
          method_Call_1!(Image_SetStretchOutEnabled, self.0, aValue);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, Image_GetCanvas, self.0);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(Image_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(Image_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(Image_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(Image_SetAnchors, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(Image_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(Image_SetAutoSize, self.0, aValue);
      }

	  pub fn Center(&self) -> bool  {
          return method_Call_1!(Image_GetCenter, self.0);
      }

	  pub fn SetCenter(&self, aValue: bool)  {
          method_Call_1!(Image_SetCenter, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, Image_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(Image_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(Image_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(Image_SetDragCursor, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(Image_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(Image_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(Image_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(Image_SetEnabled, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(Image_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(Image_SetParentShowHint, self.0, aValue);
      }

	  pub fn Picture(&self) -> TPicture  {
          return method_Call_2!(TPicture, Image_GetPicture, self.0);
      }

	  pub fn SetPicture(&self, aValue: &TPicture)  {
          method_Call_1!(Image_SetPicture, self.0, aValue.Instance());
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, Image_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(Image_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn Proportional(&self) -> bool  {
          return method_Call_1!(Image_GetProportional, self.0);
      }

	  pub fn SetProportional(&self, aValue: bool)  {
          method_Call_1!(Image_SetProportional, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(Image_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(Image_SetShowHint, self.0, aValue);
      }

	  pub fn Stretch(&self) -> bool  {
          return method_Call_1!(Image_GetStretch, self.0);
      }

	  pub fn SetStretch(&self, aValue: bool)  {
          method_Call_1!(Image_SetStretch, self.0, aValue);
      }

	  pub fn Transparent(&self) -> bool  {
          return method_Call_1!(Image_GetTransparent, self.0);
      }

	  pub fn SetTransparent(&self, aValue: bool)  {
          method_Call_1!(Image_SetTransparent, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(Image_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(Image_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Image_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Image_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(Image_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(Image_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(Image_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Image_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Image_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Image_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(Image_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Image_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, Image_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(Image_SetAction, self.0, aValue.Instance());
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(Image_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(Image_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Image_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(Image_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(Image_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(Image_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(Image_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Image_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(Image_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(Image_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(Image_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(Image_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(Image_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(Image_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(Image_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Image_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(Image_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(Image_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(Image_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(Image_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(Image_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Image_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Image_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Image_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Image_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(Image_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(Image_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Image_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(Image_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Image_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Image_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Image_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Image_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Image_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Image_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Image_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Image_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Image_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Image_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Image_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Image_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Image_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Image_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Image_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Image_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, Image_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(Image_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Image_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Image_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(Image_StaticClassType);
}

impl_IObject!(TImage);
impl_IComponent!(TImage);
impl_IControl!(TImage);

impl TLinkLabel {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TLinkLabel, LinkLabel_Create, aOwner.Instance());
      }

      impl_As_method!(TLinkLabel);

	  impl_Free_method!(LinkLabel_Free);

	  pub fn Invalidate(&self) {
          method_Call_1!(LinkLabel_Invalidate, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(LinkLabel_Repaint, self.0);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(LinkLabel_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn Update(&self) {
          method_Call_1!(LinkLabel_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(LinkLabel_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(LinkLabel_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(LinkLabel_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(LinkLabel_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(LinkLabel_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(LinkLabel_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(LinkLabel_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(LinkLabel_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(LinkLabel_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(LinkLabel_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(LinkLabel_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(LinkLabel_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(LinkLabel_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(LinkLabel_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(LinkLabel_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, LinkLabel_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(LinkLabel_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(LinkLabel_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(LinkLabel_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(LinkLabel_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(LinkLabel_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(LinkLabel_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(LinkLabel_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(LinkLabel_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(LinkLabel_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(LinkLabel_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(LinkLabel_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(LinkLabel_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(LinkLabel_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(LinkLabel_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(LinkLabel_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(LinkLabel_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(LinkLabel_SetAlign, self.0, aValue);
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(LinkLabel_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(LinkLabel_SetAlignment, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(LinkLabel_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(LinkLabel_SetAnchors, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(LinkLabel_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(LinkLabel_SetAutoSize, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(LinkLabel_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(LinkLabel_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(LinkLabel_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(LinkLabel_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, LinkLabel_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(LinkLabel_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(LinkLabel_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(LinkLabel_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(LinkLabel_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(LinkLabel_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(LinkLabel_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(LinkLabel_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(LinkLabel_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(LinkLabel_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, LinkLabel_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(LinkLabel_SetFont, self.0, aValue.Instance());
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(LinkLabel_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(LinkLabel_SetParentColor, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(LinkLabel_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(LinkLabel_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(LinkLabel_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(LinkLabel_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, LinkLabel_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(LinkLabel_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(LinkLabel_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(LinkLabel_SetShowHint, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(LinkLabel_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(LinkLabel_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(LinkLabel_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(LinkLabel_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(LinkLabel_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(LinkLabel_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(LinkLabel_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(LinkLabel_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(LinkLabel_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(LinkLabel_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(LinkLabel_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(LinkLabel_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(LinkLabel_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnLinkClick(&self, aEventId: TSysLinkEvent)  {
          method_Call_1!(LinkLabel_SetOnLinkClick, self.0, aEventId);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(LinkLabel_GetMouseInClient, self.0);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, LinkLabel_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(LinkLabel_SetAction, self.0, aValue.Instance());
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(LinkLabel_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(LinkLabel_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(LinkLabel_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(LinkLabel_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(LinkLabel_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(LinkLabel_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(LinkLabel_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(LinkLabel_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(LinkLabel_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(LinkLabel_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(LinkLabel_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(LinkLabel_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(LinkLabel_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(LinkLabel_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(LinkLabel_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, LinkLabel_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(LinkLabel_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(LinkLabel_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(LinkLabel_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(LinkLabel_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(LinkLabel_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(LinkLabel_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(LinkLabel_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(LinkLabel_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(LinkLabel_SetHeight, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(LinkLabel_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(LinkLabel_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(LinkLabel_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(LinkLabel_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(LinkLabel_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, LinkLabel_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(LinkLabel_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(LinkLabel_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(LinkLabel_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(LinkLabel_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, LinkLabel_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(LinkLabel_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, LinkLabel_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(LinkLabel_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, LinkLabel_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(LinkLabel_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, LinkLabel_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(LinkLabel_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, LinkLabel_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(LinkLabel_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, LinkLabel_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, LinkLabel_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(LinkLabel_StaticClassType);
}

impl_IObject!(TLinkLabel);
impl_IComponent!(TLinkLabel);
impl_IControl!(TLinkLabel);
impl_IWinControl!(TLinkLabel);

impl TSpeedButton {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TSpeedButton, SpeedButton_Create, aOwner.Instance());
      }

      impl_As_method!(TSpeedButton);

	  impl_Free_method!(SpeedButton_Free);

	  pub fn Click(&self)  {
          method_Call_1!(SpeedButton_Click, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(SpeedButton_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(SpeedButton_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(SpeedButton_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(SpeedButton_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(SpeedButton_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(SpeedButton_Hide, self.0);
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(SpeedButton_Invalidate, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(SpeedButton_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(SpeedButton_Refresh, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(SpeedButton_Repaint, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(SpeedButton_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(SpeedButton_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(SpeedButton_SendToBack, self.0);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(SpeedButton_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn Show(&self) {
          method_Call_1!(SpeedButton_Show, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(SpeedButton_Update, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(SpeedButton_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(SpeedButton_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(SpeedButton_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, SpeedButton_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SpeedButton_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(SpeedButton_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(SpeedButton_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SpeedButton_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(SpeedButton_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(SpeedButton_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(SpeedButton_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(SpeedButton_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SpeedButton_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(SpeedButton_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(SpeedButton_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(SpeedButton_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(SpeedButton_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(SpeedButton_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(SpeedButton_AnchorClient, self.0, aSpace);
      }

	  pub fn ImageIndex(&self) -> i32  {
          return method_Call_1!(SpeedButton_GetImageIndex, self.0);
      }

	  pub fn SetImageIndex(&self, aValue: i32)  {
          method_Call_1!(SpeedButton_SetImageIndex, self.0, aValue);
      }

	  pub fn Images(&self) -> TImageList  {
          return method_Call_2!(TImageList, SpeedButton_GetImages, self.0);
      }

	  pub fn SetImages(&self, aValue: &TImageList)  {
          method_Call_1!(SpeedButton_SetImages, self.0, aValue.Instance());
      }

	  pub fn ImageWidth(&self) -> i32  {
          return method_Call_1!(SpeedButton_GetImageWidth, self.0);
      }

	  pub fn SetImageWidth(&self, aValue: i32)  {
          method_Call_1!(SpeedButton_SetImageWidth, self.0, aValue);
      }

	  pub fn ShowCaption(&self) -> bool  {
          return method_Call_1!(SpeedButton_GetShowCaption, self.0);
      }

	  pub fn SetShowCaption(&self, aValue: bool)  {
          method_Call_1!(SpeedButton_SetShowCaption, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, SpeedButton_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(SpeedButton_SetAction, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(SpeedButton_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(SpeedButton_SetAlign, self.0, aValue);
      }

	  pub fn AllowAllUp(&self) -> bool  {
          return method_Call_1!(SpeedButton_GetAllowAllUp, self.0);
      }

	  pub fn SetAllowAllUp(&self, aValue: bool)  {
          method_Call_1!(SpeedButton_SetAllowAllUp, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(SpeedButton_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(SpeedButton_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(SpeedButton_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(SpeedButton_SetBiDiMode, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, SpeedButton_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(SpeedButton_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn GroupIndex(&self) -> i32  {
          return method_Call_1!(SpeedButton_GetGroupIndex, self.0);
      }

	  pub fn SetGroupIndex(&self, aValue: i32)  {
          method_Call_1!(SpeedButton_SetGroupIndex, self.0, aValue);
      }

	  pub fn Down(&self) -> bool  {
          return method_Call_1!(SpeedButton_GetDown, self.0);
      }

	  pub fn SetDown(&self, aValue: bool)  {
          method_Call_1!(SpeedButton_SetDown, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SpeedButton_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(SpeedButton_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(SpeedButton_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(SpeedButton_SetEnabled, self.0, aValue);
      }

	  pub fn Flat(&self) -> bool  {
          return method_Call_1!(SpeedButton_GetFlat, self.0);
      }

	  pub fn SetFlat(&self, aValue: bool)  {
          method_Call_1!(SpeedButton_SetFlat, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, SpeedButton_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(SpeedButton_SetFont, self.0, aValue.Instance());
      }

	  pub fn Glyph(&self) -> TBitmap  {
          return method_Call_2!(TBitmap, SpeedButton_GetGlyph, self.0);
      }

	  pub fn SetGlyph(&self, aValue: &TBitmap)  {
          method_Call_1!(SpeedButton_SetGlyph, self.0, aValue.Instance());
      }

	  pub fn Layout(&self) -> TButtonLayout  {
          return method_Call_1!(SpeedButton_GetLayout, self.0);
      }

	  pub fn SetLayout(&self, aValue: TButtonLayout)  {
          method_Call_1!(SpeedButton_SetLayout, self.0, aValue);
      }

	  pub fn NumGlyphs(&self) -> TNumGlyphs  {
          return method_Call_1!(SpeedButton_GetNumGlyphs, self.0);
      }

	  pub fn SetNumGlyphs(&self, aValue: TNumGlyphs)  {
          method_Call_1!(SpeedButton_SetNumGlyphs, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(SpeedButton_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(SpeedButton_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(SpeedButton_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(SpeedButton_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, SpeedButton_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(SpeedButton_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(SpeedButton_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(SpeedButton_SetShowHint, self.0, aValue);
      }

	  pub fn Spacing(&self) -> i32  {
          return method_Call_1!(SpeedButton_GetSpacing, self.0);
      }

	  pub fn SetSpacing(&self, aValue: i32)  {
          method_Call_1!(SpeedButton_SetSpacing, self.0, aValue);
      }

	  pub fn Transparent(&self) -> bool  {
          return method_Call_1!(SpeedButton_GetTransparent, self.0);
      }

	  pub fn SetTransparent(&self, aValue: bool)  {
          method_Call_1!(SpeedButton_SetTransparent, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(SpeedButton_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(SpeedButton_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(SpeedButton_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(SpeedButton_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(SpeedButton_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(SpeedButton_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(SpeedButton_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(SpeedButton_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(SpeedButton_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(SpeedButton_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(SpeedButton_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(SpeedButton_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(SpeedButton_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(SpeedButton_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(SpeedButton_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(SpeedButton_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(SpeedButton_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(SpeedButton_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(SpeedButton_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(SpeedButton_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(SpeedButton_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(SpeedButton_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, SpeedButton_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(SpeedButton_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(SpeedButton_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(SpeedButton_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(SpeedButton_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(SpeedButton_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(SpeedButton_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(SpeedButton_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(SpeedButton_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(SpeedButton_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(SpeedButton_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(SpeedButton_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SpeedButton_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(SpeedButton_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(SpeedButton_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(SpeedButton_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(SpeedButton_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, SpeedButton_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SpeedButton_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(SpeedButton_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(SpeedButton_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(SpeedButton_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, SpeedButton_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(SpeedButton_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, SpeedButton_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(SpeedButton_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, SpeedButton_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(SpeedButton_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, SpeedButton_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(SpeedButton_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, SpeedButton_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(SpeedButton_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, SpeedButton_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, SpeedButton_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(SpeedButton_StaticClassType);
}

impl_IObject!(TSpeedButton);
impl_IComponent!(TSpeedButton);
impl_IControl!(TSpeedButton);

impl TSplitter {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TSplitter, Splitter_Create, aOwner.Instance());
      }

      impl_As_method!(TSplitter);

	  impl_Free_method!(Splitter_Free);

	  pub fn BringToFront(&self) {
          method_Call_1!(Splitter_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Splitter_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Splitter_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(Splitter_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Splitter_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(Splitter_Hide, self.0);
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(Splitter_Invalidate, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(Splitter_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(Splitter_Refresh, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(Splitter_Repaint, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Splitter_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Splitter_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(Splitter_SendToBack, self.0);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(Splitter_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn Show(&self) {
          method_Call_1!(Splitter_Show, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(Splitter_Update, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(Splitter_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(Splitter_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(Splitter_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Splitter_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Splitter_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Splitter_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Splitter_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Splitter_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Splitter_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Splitter_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Splitter_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Splitter_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Splitter_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Splitter_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Splitter_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Splitter_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Splitter_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(Splitter_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(Splitter_AnchorClient, self.0, aSpace);
      }

	  pub fn ResizeAnchor(&self) -> TAnchorKind  {
          return method_Call_1!(Splitter_GetResizeAnchor, self.0);
      }

	  pub fn SetResizeAnchor(&self, aValue: TAnchorKind)  {
          method_Call_1!(Splitter_SetResizeAnchor, self.0, aValue);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, Splitter_GetCanvas, self.0);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(Splitter_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(Splitter_SetAlign, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(Splitter_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(Splitter_SetColor, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(Splitter_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(Splitter_SetCursor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, Splitter_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(Splitter_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn MinSize(&self) -> i32  {
          return method_Call_1!(Splitter_GetMinSize, self.0);
      }

	  pub fn SetMinSize(&self, aValue: i32)  {
          method_Call_1!(Splitter_SetMinSize, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(Splitter_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(Splitter_SetParentColor, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(Splitter_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(Splitter_SetVisible, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Splitter_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Splitter_SetWidth, self.0, aValue);
      }

	  pub fn SetOnPaint(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Splitter_SetOnPaint, self.0, aEventId);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(Splitter_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(Splitter_SetEnabled, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, Splitter_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(Splitter_SetAction, self.0, aValue.Instance());
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(Splitter_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(Splitter_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(Splitter_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(Splitter_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Splitter_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(Splitter_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(Splitter_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(Splitter_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(Splitter_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Splitter_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(Splitter_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(Splitter_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(Splitter_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(Splitter_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(Splitter_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(Splitter_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(Splitter_GetFloating, self.0);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(Splitter_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(Splitter_SetShowHint, self.0, aValue);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Splitter_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(Splitter_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(Splitter_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(Splitter_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(Splitter_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(Splitter_SetTop, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Splitter_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Splitter_SetHeight, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Splitter_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(Splitter_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Splitter_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Splitter_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Splitter_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Splitter_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Splitter_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Splitter_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Splitter_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Splitter_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Splitter_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Splitter_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Splitter_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Splitter_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Splitter_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Splitter_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Splitter_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Splitter_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, Splitter_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(Splitter_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Splitter_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Splitter_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(Splitter_StaticClassType);
}

impl_IObject!(TSplitter);
impl_IComponent!(TSplitter);
impl_IControl!(TSplitter);

impl TRadioGroup {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TRadioGroup, RadioGroup_Create, aOwner.Instance());
      }

      impl_As_method!(TRadioGroup);

	  impl_Free_method!(RadioGroup_Free);

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(RadioGroup_FlipChildren, self.0, allLevels);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(RadioGroup_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(RadioGroup_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, RadioGroup_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(RadioGroup_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(RadioGroup_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, RadioGroup_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(RadioGroup_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(RadioGroup_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(RadioGroup_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(RadioGroup_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(RadioGroup_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(RadioGroup_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(RadioGroup_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(RadioGroup_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(RadioGroup_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(RadioGroup_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(RadioGroup_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(RadioGroup_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(RadioGroup_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(RadioGroup_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(RadioGroup_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(RadioGroup_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(RadioGroup_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(RadioGroup_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(RadioGroup_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(RadioGroup_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(RadioGroup_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(RadioGroup_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(RadioGroup_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(RadioGroup_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(RadioGroup_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(RadioGroup_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(RadioGroup_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, RadioGroup_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(RadioGroup_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(RadioGroup_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(RadioGroup_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(RadioGroup_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(RadioGroup_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(RadioGroup_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(RadioGroup_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(RadioGroup_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(RadioGroup_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(RadioGroup_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(RadioGroup_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(RadioGroup_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(RadioGroup_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(RadioGroup_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(RadioGroup_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(RadioGroup_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(RadioGroup_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(RadioGroup_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(RadioGroup_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(RadioGroup_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(RadioGroup_SetBiDiMode, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(RadioGroup_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(RadioGroup_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(RadioGroup_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(RadioGroup_SetColor, self.0, aValue);
      }

	  pub fn Columns(&self) -> i32  {
          return method_Call_1!(RadioGroup_GetColumns, self.0);
      }

	  pub fn SetColumns(&self, aValue: i32)  {
          method_Call_1!(RadioGroup_SetColumns, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(RadioGroup_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(RadioGroup_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(RadioGroup_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(RadioGroup_SetDragCursor, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(RadioGroup_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(RadioGroup_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(RadioGroup_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(RadioGroup_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, RadioGroup_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(RadioGroup_SetFont, self.0, aValue.Instance());
      }

	  pub fn ItemIndex(&self) -> i32  {
          return method_Call_1!(RadioGroup_GetItemIndex, self.0);
      }

	  pub fn SetItemIndex(&self, aValue: i32)  {
          method_Call_1!(RadioGroup_SetItemIndex, self.0, aValue);
      }

	  pub fn Items(&self) -> TStrings  {
          return method_Call_2!(TStrings, RadioGroup_GetItems, self.0);
      }

	  pub fn SetItems(&self, aValue: &dyn IStrings)  {
          method_Call_1!(RadioGroup_SetItems, self.0, aValue.Instance());
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, RadioGroup_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(RadioGroup_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(RadioGroup_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(RadioGroup_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(RadioGroup_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(RadioGroup_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(RadioGroup_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(RadioGroup_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(RadioGroup_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(RadioGroup_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, RadioGroup_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(RadioGroup_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(RadioGroup_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(RadioGroup_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(RadioGroup_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(RadioGroup_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(RadioGroup_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(RadioGroup_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(RadioGroup_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(RadioGroup_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RadioGroup_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(RadioGroup_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(RadioGroup_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(RadioGroup_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RadioGroup_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RadioGroup_SetOnExit, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(RadioGroup_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(RadioGroup_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(RadioGroup_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(RadioGroup_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(RadioGroup_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, RadioGroup_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(RadioGroup_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(RadioGroup_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(RadioGroup_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(RadioGroup_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(RadioGroup_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(RadioGroup_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(RadioGroup_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, RadioGroup_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(RadioGroup_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(RadioGroup_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(RadioGroup_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(RadioGroup_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(RadioGroup_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(RadioGroup_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(RadioGroup_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(RadioGroup_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(RadioGroup_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(RadioGroup_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(RadioGroup_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(RadioGroup_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(RadioGroup_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(RadioGroup_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, RadioGroup_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(RadioGroup_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(RadioGroup_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(RadioGroup_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(RadioGroup_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(RadioGroup_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(RadioGroup_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(RadioGroup_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(RadioGroup_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(RadioGroup_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(RadioGroup_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(RadioGroup_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(RadioGroup_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(RadioGroup_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(RadioGroup_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(RadioGroup_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(RadioGroup_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, RadioGroup_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(RadioGroup_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(RadioGroup_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(RadioGroup_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(RadioGroup_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, RadioGroup_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(RadioGroup_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, RadioGroup_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(RadioGroup_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, RadioGroup_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(RadioGroup_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, RadioGroup_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(RadioGroup_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, RadioGroup_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(RadioGroup_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, RadioGroup_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(RadioGroup_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, RadioGroup_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, RadioGroup_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, RadioGroup_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, RadioGroup_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(RadioGroup_StaticClassType);
}

impl_IObject!(TRadioGroup);
impl_IComponent!(TRadioGroup);
impl_IControl!(TRadioGroup);
impl_IWinControl!(TRadioGroup);

impl TStaticText {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TStaticText, StaticText_Create, aOwner.Instance());
      }

      impl_As_method!(TStaticText);

	  impl_Free_method!(StaticText_Free);

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(StaticText_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(StaticText_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, StaticText_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(StaticText_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(StaticText_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, StaticText_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(StaticText_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(StaticText_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(StaticText_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(StaticText_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(StaticText_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(StaticText_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(StaticText_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(StaticText_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(StaticText_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(StaticText_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(StaticText_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(StaticText_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(StaticText_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(StaticText_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(StaticText_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(StaticText_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(StaticText_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(StaticText_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(StaticText_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(StaticText_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(StaticText_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(StaticText_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(StaticText_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(StaticText_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(StaticText_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(StaticText_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(StaticText_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(StaticText_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, StaticText_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StaticText_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(StaticText_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(StaticText_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StaticText_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(StaticText_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(StaticText_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(StaticText_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(StaticText_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StaticText_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(StaticText_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(StaticText_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(StaticText_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(StaticText_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(StaticText_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(StaticText_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(StaticText_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(StaticText_SetAlign, self.0, aValue);
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(StaticText_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(StaticText_SetAlignment, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(StaticText_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(StaticText_SetAnchors, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(StaticText_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(StaticText_SetAutoSize, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(StaticText_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(StaticText_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TStaticBorderStyle  {
          return method_Call_1!(StaticText_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TStaticBorderStyle)  {
          method_Call_1!(StaticText_SetBorderStyle, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StaticText_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(StaticText_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(StaticText_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(StaticText_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, StaticText_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(StaticText_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(StaticText_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(StaticText_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(StaticText_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(StaticText_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(StaticText_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(StaticText_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(StaticText_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(StaticText_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(StaticText_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(StaticText_SetEnabled, self.0, aValue);
      }

	  pub fn FocusControl(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, StaticText_GetFocusControl, self.0);
      }

	  pub fn SetFocusControl(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(StaticText_SetFocusControl, self.0, aValue.Instance());
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, StaticText_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(StaticText_SetFont, self.0, aValue.Instance());
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(StaticText_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(StaticText_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(StaticText_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(StaticText_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(StaticText_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(StaticText_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(StaticText_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(StaticText_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, StaticText_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(StaticText_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowAccelChar(&self) -> bool  {
          return method_Call_1!(StaticText_GetShowAccelChar, self.0);
      }

	  pub fn SetShowAccelChar(&self, aValue: bool)  {
          method_Call_1!(StaticText_SetShowAccelChar, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(StaticText_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(StaticText_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(StaticText_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(StaticText_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(StaticText_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(StaticText_SetTabStop, self.0, aValue);
      }

	  pub fn Transparent(&self) -> bool  {
          return method_Call_1!(StaticText_GetTransparent, self.0);
      }

	  pub fn SetTransparent(&self, aValue: bool)  {
          method_Call_1!(StaticText_SetTransparent, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(StaticText_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(StaticText_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StaticText_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(StaticText_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StaticText_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(StaticText_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(StaticText_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(StaticText_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(StaticText_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StaticText_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StaticText_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(StaticText_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(StaticText_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(StaticText_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(StaticText_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(StaticText_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(StaticText_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(StaticText_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, StaticText_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(StaticText_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(StaticText_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(StaticText_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(StaticText_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(StaticText_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(StaticText_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(StaticText_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, StaticText_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(StaticText_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(StaticText_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(StaticText_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(StaticText_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(StaticText_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(StaticText_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(StaticText_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(StaticText_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(StaticText_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(StaticText_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(StaticText_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(StaticText_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(StaticText_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(StaticText_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, StaticText_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(StaticText_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(StaticText_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(StaticText_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(StaticText_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(StaticText_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(StaticText_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(StaticText_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(StaticText_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(StaticText_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(StaticText_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(StaticText_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StaticText_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(StaticText_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(StaticText_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(StaticText_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(StaticText_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, StaticText_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StaticText_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(StaticText_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(StaticText_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(StaticText_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, StaticText_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(StaticText_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, StaticText_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(StaticText_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, StaticText_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(StaticText_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, StaticText_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(StaticText_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, StaticText_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(StaticText_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, StaticText_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(StaticText_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, StaticText_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, StaticText_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, StaticText_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, StaticText_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(StaticText_StaticClassType);
}

impl_IObject!(TStaticText);
impl_IComponent!(TStaticText);
impl_IControl!(TStaticText);
impl_IWinControl!(TStaticText);

impl TColorBox {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TColorBox, ColorBox_Create, aOwner.Instance());
      }

      impl_As_method!(TColorBox);

	  impl_Free_method!(ColorBox_Free);

	  pub fn AddItem(&self, item: &str, aObject: &dyn IObject)  {
          method_Call_1!(ColorBox_AddItem, self.0, to_CString!(item), aObject.Instance());
      }

	  pub fn Clear(&self)  {
          method_Call_1!(ColorBox_Clear, self.0);
      }

	  pub fn ClearSelection(&self)  {
          method_Call_1!(ColorBox_ClearSelection, self.0);
      }

	  pub fn DeleteSelected(&self)  {
          method_Call_1!(ColorBox_DeleteSelected, self.0);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(ColorBox_Focused, self.0);
      }

	  pub fn SelectAll(&self)  {
          method_Call_1!(ColorBox_SelectAll, self.0);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(ColorBox_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(ColorBox_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, ColorBox_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(ColorBox_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(ColorBox_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, ColorBox_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(ColorBox_FlipChildren, self.0, allLevels);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(ColorBox_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ColorBox_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(ColorBox_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ColorBox_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(ColorBox_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(ColorBox_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(ColorBox_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(ColorBox_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(ColorBox_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(ColorBox_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(ColorBox_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(ColorBox_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ColorBox_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ColorBox_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(ColorBox_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ColorBox_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(ColorBox_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(ColorBox_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(ColorBox_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ColorBox_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ColorBox_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(ColorBox_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(ColorBox_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(ColorBox_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(ColorBox_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(ColorBox_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ColorBox_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ColorBox_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ColorBox_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ColorBox_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ColorBox_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ColorBox_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ColorBox_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ColorBox_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ColorBox_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ColorBox_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ColorBox_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ColorBox_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ColorBox_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ColorBox_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(ColorBox_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(ColorBox_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(ColorBox_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(ColorBox_SetAlign, self.0, aValue);
      }

	  pub fn AutoComplete(&self) -> bool  {
          return method_Call_1!(ColorBox_GetAutoComplete, self.0);
      }

	  pub fn SetAutoComplete(&self, aValue: bool)  {
          method_Call_1!(ColorBox_SetAutoComplete, self.0, aValue);
      }

	  pub fn AutoDropDown(&self) -> bool  {
          return method_Call_1!(ColorBox_GetAutoDropDown, self.0);
      }

	  pub fn SetAutoDropDown(&self, aValue: bool)  {
          method_Call_1!(ColorBox_SetAutoDropDown, self.0, aValue);
      }

	  pub fn DefaultColorColor(&self) -> TColor  {
          return method_Call_1!(ColorBox_GetDefaultColorColor, self.0);
      }

	  pub fn SetDefaultColorColor(&self, aValue: TColor)  {
          method_Call_1!(ColorBox_SetDefaultColorColor, self.0, aValue);
      }

	  pub fn NoneColorColor(&self) -> TColor  {
          return method_Call_1!(ColorBox_GetNoneColorColor, self.0);
      }

	  pub fn SetNoneColorColor(&self, aValue: TColor)  {
          method_Call_1!(ColorBox_SetNoneColorColor, self.0, aValue);
      }

	  pub fn Selected(&self) -> TColor  {
          return method_Call_1!(ColorBox_GetSelected, self.0);
      }

	  pub fn SetSelected(&self, aValue: TColor)  {
          method_Call_1!(ColorBox_SetSelected, self.0, aValue);
      }

	  pub fn Style(&self) -> TColorBoxStyle  {
          return method_Call_1!(ColorBox_GetStyle, self.0);
      }

	  pub fn SetStyle(&self, aValue: TColorBoxStyle)  {
          method_Call_1!(ColorBox_SetStyle, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(ColorBox_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(ColorBox_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(ColorBox_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(ColorBox_SetBiDiMode, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(ColorBox_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(ColorBox_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, ColorBox_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(ColorBox_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(ColorBox_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ColorBox_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DropDownCount(&self) -> i32  {
          return method_Call_1!(ColorBox_GetDropDownCount, self.0);
      }

	  pub fn SetDropDownCount(&self, aValue: i32)  {
          method_Call_1!(ColorBox_SetDropDownCount, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(ColorBox_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(ColorBox_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, ColorBox_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(ColorBox_SetFont, self.0, aValue.Instance());
      }

	  pub fn ItemHeight(&self) -> i32  {
          return method_Call_1!(ColorBox_GetItemHeight, self.0);
      }

	  pub fn SetItemHeight(&self, aValue: i32)  {
          method_Call_1!(ColorBox_SetItemHeight, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(ColorBox_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(ColorBox_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(ColorBox_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ColorBox_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(ColorBox_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(ColorBox_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(ColorBox_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(ColorBox_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, ColorBox_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(ColorBox_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(ColorBox_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(ColorBox_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(ColorBox_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(ColorBox_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(ColorBox_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(ColorBox_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(ColorBox_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(ColorBox_SetVisible, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorBox_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorBox_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(ColorBox_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(ColorBox_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(ColorBox_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnDropDown(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorBox_SetOnDropDown, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ColorBox_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorBox_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorBox_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ColorBox_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(ColorBox_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ColorBox_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorBox_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorBox_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnSelect(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorBox_SetOnSelect, self.0, aEventId);
      }

	  pub fn CharCase(&self) -> TEditCharCase  {
          return method_Call_1!(ColorBox_GetCharCase, self.0);
      }

	  pub fn SetCharCase(&self, aValue: TEditCharCase)  {
          method_Call_1!(ColorBox_SetCharCase, self.0, aValue);
      }

	  pub fn SelText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ColorBox_GetSelText, self.0));
      }

	  pub fn SetSelText(&self, aValue: &str)  {
          method_Call_1!(ColorBox_SetSelText, self.0, to_CString!(aValue));
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, ColorBox_GetCanvas, self.0);
      }

	  pub fn DroppedDown(&self) -> bool  {
          return method_Call_1!(ColorBox_GetDroppedDown, self.0);
      }

	  pub fn SetDroppedDown(&self, aValue: bool)  {
          method_Call_1!(ColorBox_SetDroppedDown, self.0, aValue);
      }

	  pub fn Items(&self) -> TStrings  {
          return method_Call_2!(TStrings, ColorBox_GetItems, self.0);
      }

	  pub fn SetItems(&self, aValue: &dyn IStrings)  {
          method_Call_1!(ColorBox_SetItems, self.0, aValue.Instance());
      }

	  pub fn SelLength(&self) -> i32  {
          return method_Call_1!(ColorBox_GetSelLength, self.0);
      }

	  pub fn SetSelLength(&self, aValue: i32)  {
          method_Call_1!(ColorBox_SetSelLength, self.0, aValue);
      }

	  pub fn SelStart(&self) -> i32  {
          return method_Call_1!(ColorBox_GetSelStart, self.0);
      }

	  pub fn SetSelStart(&self, aValue: i32)  {
          method_Call_1!(ColorBox_SetSelStart, self.0, aValue);
      }

	  pub fn ItemIndex(&self) -> i32  {
          return method_Call_1!(ColorBox_GetItemIndex, self.0);
      }

	  pub fn SetItemIndex(&self, aValue: i32)  {
          method_Call_1!(ColorBox_SetItemIndex, self.0, aValue);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(ColorBox_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(ColorBox_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(ColorBox_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(ColorBox_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(ColorBox_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, ColorBox_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(ColorBox_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(ColorBox_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(ColorBox_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(ColorBox_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(ColorBox_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(ColorBox_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(ColorBox_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, ColorBox_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(ColorBox_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ColorBox_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(ColorBox_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(ColorBox_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(ColorBox_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ColorBox_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ColorBox_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(ColorBox_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(ColorBox_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(ColorBox_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(ColorBox_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(ColorBox_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(ColorBox_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(ColorBox_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, ColorBox_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(ColorBox_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ColorBox_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ColorBox_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ColorBox_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ColorBox_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ColorBox_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ColorBox_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(ColorBox_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(ColorBox_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(ColorBox_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(ColorBox_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ColorBox_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(ColorBox_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ColorBox_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ColorBox_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ColorBox_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ColorBox_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ColorBox_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ColorBox_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ColorBox_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ColorBox_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ColorBox_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ColorBox_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ColorBox_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ColorBox_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ColorBox_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ColorBox_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ColorBox_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ColorBox_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, ColorBox_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(ColorBox_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, ColorBox_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(ColorBox_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Colors(&self, index: i32) -> TColor  {
          return method_Call_1!(ColorBox_GetColors, self.0, index);
      }

	  pub fn ColorNames<'a>(&self, index: i32) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ColorBox_GetColorNames, self.0, index));
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ColorBox_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ColorBox_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ColorBox_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ColorBox_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(ColorBox_StaticClassType);
}

impl_IObject!(TColorBox);
impl_IComponent!(TColorBox);
impl_IControl!(TColorBox);
impl_IWinControl!(TColorBox);

impl TColorListBox {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TColorListBox, ColorListBox_Create, aOwner.Instance());
      }

      impl_As_method!(TColorListBox);

	  impl_Free_method!(ColorListBox_Free);

	  pub fn AddItem(&self, item: &str, aObject: &dyn IObject)  {
          method_Call_1!(ColorListBox_AddItem, self.0, to_CString!(item), aObject.Instance());
      }

	  pub fn Clear(&self)  {
          method_Call_1!(ColorListBox_Clear, self.0);
      }

	  pub fn ClearSelection(&self)  {
          method_Call_1!(ColorListBox_ClearSelection, self.0);
      }

	  pub fn DeleteSelected(&self)  {
          method_Call_1!(ColorListBox_DeleteSelected, self.0);
      }

	  pub fn ItemAtPos(&self, pos: &TPoint, existing: bool) -> i32  {
          let mut ps1 = TPoint::From(pos);
          return method_Call_1!(ColorListBox_ItemAtPos, self.0, &mut ps1, existing);
      }

	  pub fn ItemRect(&self, index: i32) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ColorListBox_ItemRect, self.0, index, &mut result);
          return result;
      }

	  pub fn SelectAll(&self)  {
          method_Call_1!(ColorListBox_SelectAll, self.0);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(ColorListBox_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(ColorListBox_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, ColorListBox_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(ColorListBox_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(ColorListBox_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, ColorListBox_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(ColorListBox_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(ColorListBox_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(ColorListBox_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ColorListBox_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(ColorListBox_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ColorListBox_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(ColorListBox_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(ColorListBox_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(ColorListBox_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(ColorListBox_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(ColorListBox_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(ColorListBox_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(ColorListBox_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(ColorListBox_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ColorListBox_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ColorListBox_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(ColorListBox_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ColorListBox_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(ColorListBox_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(ColorListBox_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(ColorListBox_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ColorListBox_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ColorListBox_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(ColorListBox_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(ColorListBox_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(ColorListBox_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(ColorListBox_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(ColorListBox_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ColorListBox_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ColorListBox_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ColorListBox_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ColorListBox_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ColorListBox_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ColorListBox_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ColorListBox_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ColorListBox_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ColorListBox_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ColorListBox_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ColorListBox_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ColorListBox_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ColorListBox_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ColorListBox_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(ColorListBox_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(ColorListBox_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(ColorListBox_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(ColorListBox_SetAlign, self.0, aValue);
      }

	  pub fn DefaultColorColor(&self) -> TColor  {
          return method_Call_1!(ColorListBox_GetDefaultColorColor, self.0);
      }

	  pub fn SetDefaultColorColor(&self, aValue: TColor)  {
          method_Call_1!(ColorListBox_SetDefaultColorColor, self.0, aValue);
      }

	  pub fn NoneColorColor(&self) -> TColor  {
          return method_Call_1!(ColorListBox_GetNoneColorColor, self.0);
      }

	  pub fn SetNoneColorColor(&self, aValue: TColor)  {
          method_Call_1!(ColorListBox_SetNoneColorColor, self.0, aValue);
      }

	  pub fn Selected(&self) -> TColor  {
          return method_Call_1!(ColorListBox_GetSelected, self.0);
      }

	  pub fn SetSelected(&self, aValue: TColor)  {
          method_Call_1!(ColorListBox_SetSelected, self.0, aValue);
      }

	  pub fn Style(&self) -> TColorBoxStyle  {
          return method_Call_1!(ColorListBox_GetStyle, self.0);
      }

	  pub fn SetStyle(&self, aValue: TColorBoxStyle)  {
          method_Call_1!(ColorListBox_SetStyle, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(ColorListBox_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(ColorListBox_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(ColorListBox_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(ColorListBox_SetBiDiMode, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(ColorListBox_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(ColorListBox_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, ColorListBox_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(ColorListBox_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(ColorListBox_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ColorListBox_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(ColorListBox_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(ColorListBox_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, ColorListBox_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(ColorListBox_SetFont, self.0, aValue.Instance());
      }

	  pub fn ItemHeight(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetItemHeight, self.0);
      }

	  pub fn SetItemHeight(&self, aValue: i32)  {
          method_Call_1!(ColorListBox_SetItemHeight, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(ColorListBox_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(ColorListBox_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(ColorListBox_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ColorListBox_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(ColorListBox_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(ColorListBox_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(ColorListBox_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(ColorListBox_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, ColorListBox_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(ColorListBox_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(ColorListBox_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(ColorListBox_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(ColorListBox_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(ColorListBox_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(ColorListBox_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(ColorListBox_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(ColorListBox_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(ColorListBox_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorListBox_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(ColorListBox_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorListBox_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(ColorListBox_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(ColorListBox_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ColorListBox_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorListBox_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorListBox_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ColorListBox_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(ColorListBox_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ColorListBox_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ColorListBox_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorListBox_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorListBox_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(ColorListBox_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ColorListBox_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, ColorListBox_GetCanvas, self.0);
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetCount, self.0);
      }

	  pub fn Items(&self) -> TStrings  {
          return method_Call_2!(TStrings, ColorListBox_GetItems, self.0);
      }

	  pub fn SetItems(&self, aValue: &dyn IStrings)  {
          method_Call_1!(ColorListBox_SetItems, self.0, aValue.Instance());
      }

	  pub fn TopIndex(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetTopIndex, self.0);
      }

	  pub fn SetTopIndex(&self, aValue: i32)  {
          method_Call_1!(ColorListBox_SetTopIndex, self.0, aValue);
      }

	  pub fn MultiSelect(&self) -> bool  {
          return method_Call_1!(ColorListBox_GetMultiSelect, self.0);
      }

	  pub fn SetMultiSelect(&self, aValue: bool)  {
          method_Call_1!(ColorListBox_SetMultiSelect, self.0, aValue);
      }

	  pub fn SelCount(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetSelCount, self.0);
      }

	  pub fn ItemIndex(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetItemIndex, self.0);
      }

	  pub fn SetItemIndex(&self, aValue: i32)  {
          method_Call_1!(ColorListBox_SetItemIndex, self.0, aValue);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(ColorListBox_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(ColorListBox_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(ColorListBox_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, ColorListBox_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(ColorListBox_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(ColorListBox_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(ColorListBox_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(ColorListBox_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(ColorListBox_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(ColorListBox_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, ColorListBox_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(ColorListBox_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ColorListBox_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(ColorListBox_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(ColorListBox_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ColorListBox_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ColorListBox_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(ColorListBox_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(ColorListBox_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(ColorListBox_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(ColorListBox_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(ColorListBox_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(ColorListBox_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, ColorListBox_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(ColorListBox_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ColorListBox_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ColorListBox_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ColorListBox_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(ColorListBox_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(ColorListBox_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(ColorListBox_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ColorListBox_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(ColorListBox_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ColorListBox_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ColorListBox_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ColorListBox_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ColorListBox_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ColorListBox_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ColorListBox_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ColorListBox_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ColorListBox_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ColorListBox_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ColorListBox_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ColorListBox_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ColorListBox_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ColorListBox_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ColorListBox_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ColorListBox_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, ColorListBox_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(ColorListBox_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, ColorListBox_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(ColorListBox_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Colors(&self, index: i32) -> TColor  {
          return method_Call_1!(ColorListBox_GetColors, self.0, index);
      }

	  pub fn ColorNames<'a>(&self, index: i32) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ColorListBox_GetColorNames, self.0, index));
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ColorListBox_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ColorListBox_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ColorListBox_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ColorListBox_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(ColorListBox_StaticClassType);
}

impl_IObject!(TColorListBox);
impl_IComponent!(TColorListBox);
impl_IControl!(TColorListBox);
impl_IWinControl!(TColorListBox);

impl TTrayIcon {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TTrayIcon, TrayIcon_Create, aOwner.Instance());
      }

      impl_As_method!(TTrayIcon);

	  impl_Free_method!(TrayIcon_Free);

	  pub fn ShowBalloonHint(&self)  {
          method_Call_1!(TrayIcon_ShowBalloonHint, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, TrayIcon_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TrayIcon_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(TrayIcon_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(TrayIcon_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(TrayIcon_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TrayIcon_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(TrayIcon_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(TrayIcon_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(TrayIcon_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(TrayIcon_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TrayIcon_ToString, self.0));
      }

	  pub fn AnimateInterval(&self) -> u32  {
          return method_Call_1!(TrayIcon_GetAnimateInterval, self.0);
      }

	  pub fn SetAnimateInterval(&self, aValue: u32)  {
          method_Call_1!(TrayIcon_SetAnimateInterval, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TrayIcon_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(TrayIcon_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn BalloonHint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TrayIcon_GetBalloonHint, self.0));
      }

	  pub fn SetBalloonHint(&self, aValue: &str)  {
          method_Call_1!(TrayIcon_SetBalloonHint, self.0, to_CString!(aValue));
      }

	  pub fn BalloonTitle<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TrayIcon_GetBalloonTitle, self.0));
      }

	  pub fn SetBalloonTitle(&self, aValue: &str)  {
          method_Call_1!(TrayIcon_SetBalloonTitle, self.0, to_CString!(aValue));
      }

	  pub fn BalloonTimeout(&self) -> i32  {
          return method_Call_1!(TrayIcon_GetBalloonTimeout, self.0);
      }

	  pub fn SetBalloonTimeout(&self, aValue: i32)  {
          method_Call_1!(TrayIcon_SetBalloonTimeout, self.0, aValue);
      }

	  pub fn BalloonFlags(&self) -> TBalloonFlags  {
          return method_Call_1!(TrayIcon_GetBalloonFlags, self.0);
      }

	  pub fn SetBalloonFlags(&self, aValue: TBalloonFlags)  {
          method_Call_1!(TrayIcon_SetBalloonFlags, self.0, aValue);
      }

	  pub fn Icon(&self) -> TIcon  {
          return method_Call_2!(TIcon, TrayIcon_GetIcon, self.0);
      }

	  pub fn SetIcon(&self, aValue: &TIcon)  {
          method_Call_1!(TrayIcon_SetIcon, self.0, aValue.Instance());
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, TrayIcon_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(TrayIcon_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(TrayIcon_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(TrayIcon_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TrayIcon_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TrayIcon_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(TrayIcon_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(TrayIcon_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(TrayIcon_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(TrayIcon_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(TrayIcon_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(TrayIcon_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, TrayIcon_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TrayIcon_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(TrayIcon_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(TrayIcon_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(TrayIcon_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, TrayIcon_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(TrayIcon_StaticClassType);
}

impl_IObject!(TTrayIcon);
impl_IComponent!(TTrayIcon);

impl TOpenDialog {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TOpenDialog, OpenDialog_Create, aOwner.Instance());
      }

      impl_As_method!(TOpenDialog);

	  impl_Free_method!(OpenDialog_Free);

	  pub fn Execute(&self) -> bool  {
          return method_Call_1!(OpenDialog_Execute, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, OpenDialog_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(OpenDialog_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(OpenDialog_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(OpenDialog_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(OpenDialog_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(OpenDialog_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(OpenDialog_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(OpenDialog_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(OpenDialog_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(OpenDialog_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(OpenDialog_ToString, self.0));
      }

	  pub fn Files(&self) -> TStrings  {
          return method_Call_2!(TStrings, OpenDialog_GetFiles, self.0);
      }

	  pub fn DefaultExt<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(OpenDialog_GetDefaultExt, self.0));
      }

	  pub fn SetDefaultExt(&self, aValue: &str)  {
          method_Call_1!(OpenDialog_SetDefaultExt, self.0, to_CString!(aValue));
      }

	  pub fn FileName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(OpenDialog_GetFileName, self.0));
      }

	  pub fn SetFileName(&self, aValue: &str)  {
          method_Call_1!(OpenDialog_SetFileName, self.0, to_CString!(aValue));
      }

	  pub fn Filter<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(OpenDialog_GetFilter, self.0));
      }

	  pub fn SetFilter(&self, aValue: &str)  {
          method_Call_1!(OpenDialog_SetFilter, self.0, to_CString!(aValue));
      }

	  pub fn FilterIndex(&self) -> i32  {
          return method_Call_1!(OpenDialog_GetFilterIndex, self.0);
      }

	  pub fn SetFilterIndex(&self, aValue: i32)  {
          method_Call_1!(OpenDialog_SetFilterIndex, self.0, aValue);
      }

	  pub fn InitialDir<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(OpenDialog_GetInitialDir, self.0));
      }

	  pub fn SetInitialDir(&self, aValue: &str)  {
          method_Call_1!(OpenDialog_SetInitialDir, self.0, to_CString!(aValue));
      }

	  pub fn Options(&self) -> TOpenOptions  {
          return method_Call_1!(OpenDialog_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TOpenOptions)  {
          method_Call_1!(OpenDialog_SetOptions, self.0, aValue);
      }

	  pub fn Title<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(OpenDialog_GetTitle, self.0));
      }

	  pub fn SetTitle(&self, aValue: &str)  {
          method_Call_1!(OpenDialog_SetTitle, self.0, to_CString!(aValue));
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(OpenDialog_GetHandle, self.0);
      }

	  pub fn SetOnClose(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(OpenDialog_SetOnClose, self.0, aEventId);
      }

	  pub fn SetOnShow(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(OpenDialog_SetOnShow, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(OpenDialog_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(OpenDialog_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(OpenDialog_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, OpenDialog_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(OpenDialog_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(OpenDialog_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(OpenDialog_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(OpenDialog_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, OpenDialog_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(OpenDialog_StaticClassType);
}

impl_IObject!(TOpenDialog);
impl_IComponent!(TOpenDialog);

impl TSaveDialog {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TSaveDialog, SaveDialog_Create, aOwner.Instance());
      }

      impl_As_method!(TSaveDialog);

	  impl_Free_method!(SaveDialog_Free);

	  pub fn Execute(&self) -> bool  {
          return method_Call_1!(SaveDialog_Execute, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, SaveDialog_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SaveDialog_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(SaveDialog_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(SaveDialog_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(SaveDialog_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SaveDialog_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(SaveDialog_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(SaveDialog_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(SaveDialog_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(SaveDialog_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SaveDialog_ToString, self.0));
      }

	  pub fn Files(&self) -> TStrings  {
          return method_Call_2!(TStrings, SaveDialog_GetFiles, self.0);
      }

	  pub fn DefaultExt<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SaveDialog_GetDefaultExt, self.0));
      }

	  pub fn SetDefaultExt(&self, aValue: &str)  {
          method_Call_1!(SaveDialog_SetDefaultExt, self.0, to_CString!(aValue));
      }

	  pub fn FileName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SaveDialog_GetFileName, self.0));
      }

	  pub fn SetFileName(&self, aValue: &str)  {
          method_Call_1!(SaveDialog_SetFileName, self.0, to_CString!(aValue));
      }

	  pub fn Filter<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SaveDialog_GetFilter, self.0));
      }

	  pub fn SetFilter(&self, aValue: &str)  {
          method_Call_1!(SaveDialog_SetFilter, self.0, to_CString!(aValue));
      }

	  pub fn FilterIndex(&self) -> i32  {
          return method_Call_1!(SaveDialog_GetFilterIndex, self.0);
      }

	  pub fn SetFilterIndex(&self, aValue: i32)  {
          method_Call_1!(SaveDialog_SetFilterIndex, self.0, aValue);
      }

	  pub fn InitialDir<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SaveDialog_GetInitialDir, self.0));
      }

	  pub fn SetInitialDir(&self, aValue: &str)  {
          method_Call_1!(SaveDialog_SetInitialDir, self.0, to_CString!(aValue));
      }

	  pub fn Options(&self) -> TOpenOptions  {
          return method_Call_1!(SaveDialog_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TOpenOptions)  {
          method_Call_1!(SaveDialog_SetOptions, self.0, aValue);
      }

	  pub fn Title<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SaveDialog_GetTitle, self.0));
      }

	  pub fn SetTitle(&self, aValue: &str)  {
          method_Call_1!(SaveDialog_SetTitle, self.0, to_CString!(aValue));
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(SaveDialog_GetHandle, self.0);
      }

	  pub fn SetOnClose(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(SaveDialog_SetOnClose, self.0, aEventId);
      }

	  pub fn SetOnShow(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(SaveDialog_SetOnShow, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(SaveDialog_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(SaveDialog_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(SaveDialog_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, SaveDialog_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SaveDialog_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(SaveDialog_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(SaveDialog_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(SaveDialog_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, SaveDialog_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(SaveDialog_StaticClassType);
}

impl_IObject!(TSaveDialog);
impl_IComponent!(TSaveDialog);

impl TColorDialog {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TColorDialog, ColorDialog_Create, aOwner.Instance());
      }

      impl_As_method!(TColorDialog);

	  impl_Free_method!(ColorDialog_Free);

	  pub fn Execute(&self) -> bool  {
          return method_Call_1!(ColorDialog_Execute, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ColorDialog_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ColorDialog_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ColorDialog_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ColorDialog_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ColorDialog_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ColorDialog_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ColorDialog_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ColorDialog_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ColorDialog_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ColorDialog_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ColorDialog_ToString, self.0));
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(ColorDialog_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(ColorDialog_SetColor, self.0, aValue);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(ColorDialog_GetHandle, self.0);
      }

	  pub fn SetOnClose(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorDialog_SetOnClose, self.0, aEventId);
      }

	  pub fn SetOnShow(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ColorDialog_SetOnShow, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ColorDialog_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ColorDialog_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ColorDialog_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ColorDialog_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ColorDialog_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ColorDialog_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ColorDialog_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ColorDialog_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ColorDialog_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(ColorDialog_StaticClassType);
}

impl_IObject!(TColorDialog);
impl_IComponent!(TColorDialog);

impl TFontDialog {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TFontDialog, FontDialog_Create, aOwner.Instance());
      }

      impl_As_method!(TFontDialog);

	  impl_Free_method!(FontDialog_Free);

	  pub fn Execute(&self) -> bool  {
          return method_Call_1!(FontDialog_Execute, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, FontDialog_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(FontDialog_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(FontDialog_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(FontDialog_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(FontDialog_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(FontDialog_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(FontDialog_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(FontDialog_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(FontDialog_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(FontDialog_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(FontDialog_ToString, self.0));
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, FontDialog_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(FontDialog_SetFont, self.0, aValue.Instance());
      }

	  pub fn Options(&self) -> TFontDialogOptions  {
          return method_Call_1!(FontDialog_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TFontDialogOptions)  {
          method_Call_1!(FontDialog_SetOptions, self.0, aValue);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(FontDialog_GetHandle, self.0);
      }

	  pub fn SetOnClose(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(FontDialog_SetOnClose, self.0, aEventId);
      }

	  pub fn SetOnShow(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(FontDialog_SetOnShow, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(FontDialog_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(FontDialog_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(FontDialog_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, FontDialog_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(FontDialog_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(FontDialog_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(FontDialog_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(FontDialog_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, FontDialog_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(FontDialog_StaticClassType);
}

impl_IObject!(TFontDialog);
impl_IComponent!(TFontDialog);

impl TPrintDialog {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TPrintDialog, PrintDialog_Create, aOwner.Instance());
      }

      impl_As_method!(TPrintDialog);

	  impl_Free_method!(PrintDialog_Free);

	  pub fn Execute(&self) -> bool  {
          return method_Call_1!(PrintDialog_Execute, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, PrintDialog_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PrintDialog_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(PrintDialog_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(PrintDialog_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(PrintDialog_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PrintDialog_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(PrintDialog_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(PrintDialog_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(PrintDialog_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(PrintDialog_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PrintDialog_ToString, self.0));
      }

	  pub fn Collate(&self) -> bool  {
          return method_Call_1!(PrintDialog_GetCollate, self.0);
      }

	  pub fn SetCollate(&self, aValue: bool)  {
          method_Call_1!(PrintDialog_SetCollate, self.0, aValue);
      }

	  pub fn Copies(&self) -> i32  {
          return method_Call_1!(PrintDialog_GetCopies, self.0);
      }

	  pub fn SetCopies(&self, aValue: i32)  {
          method_Call_1!(PrintDialog_SetCopies, self.0, aValue);
      }

	  pub fn FromPage(&self) -> i32  {
          return method_Call_1!(PrintDialog_GetFromPage, self.0);
      }

	  pub fn SetFromPage(&self, aValue: i32)  {
          method_Call_1!(PrintDialog_SetFromPage, self.0, aValue);
      }

	  pub fn MinPage(&self) -> i32  {
          return method_Call_1!(PrintDialog_GetMinPage, self.0);
      }

	  pub fn SetMinPage(&self, aValue: i32)  {
          method_Call_1!(PrintDialog_SetMinPage, self.0, aValue);
      }

	  pub fn MaxPage(&self) -> i32  {
          return method_Call_1!(PrintDialog_GetMaxPage, self.0);
      }

	  pub fn SetMaxPage(&self, aValue: i32)  {
          method_Call_1!(PrintDialog_SetMaxPage, self.0, aValue);
      }

	  pub fn Options(&self) -> TPrintDialogOptions  {
          return method_Call_1!(PrintDialog_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TPrintDialogOptions)  {
          method_Call_1!(PrintDialog_SetOptions, self.0, aValue);
      }

	  pub fn PrintToFile(&self) -> bool  {
          return method_Call_1!(PrintDialog_GetPrintToFile, self.0);
      }

	  pub fn SetPrintToFile(&self, aValue: bool)  {
          method_Call_1!(PrintDialog_SetPrintToFile, self.0, aValue);
      }

	  pub fn PrintRange(&self) -> TPrintRange  {
          return method_Call_1!(PrintDialog_GetPrintRange, self.0);
      }

	  pub fn SetPrintRange(&self, aValue: TPrintRange)  {
          method_Call_1!(PrintDialog_SetPrintRange, self.0, aValue);
      }

	  pub fn ToPage(&self) -> i32  {
          return method_Call_1!(PrintDialog_GetToPage, self.0);
      }

	  pub fn SetToPage(&self, aValue: i32)  {
          method_Call_1!(PrintDialog_SetToPage, self.0, aValue);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(PrintDialog_GetHandle, self.0);
      }

	  pub fn SetOnClose(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PrintDialog_SetOnClose, self.0, aEventId);
      }

	  pub fn SetOnShow(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PrintDialog_SetOnShow, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(PrintDialog_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(PrintDialog_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(PrintDialog_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, PrintDialog_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(PrintDialog_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(PrintDialog_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(PrintDialog_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(PrintDialog_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, PrintDialog_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(PrintDialog_StaticClassType);
}

impl_IObject!(TPrintDialog);
impl_IComponent!(TPrintDialog);

impl TOpenPictureDialog {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TOpenPictureDialog, OpenPictureDialog_Create, aOwner.Instance());
      }

      impl_As_method!(TOpenPictureDialog);

	  impl_Free_method!(OpenPictureDialog_Free);

	  pub fn Execute(&self) -> bool  {
          return method_Call_1!(OpenPictureDialog_Execute, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, OpenPictureDialog_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(OpenPictureDialog_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(OpenPictureDialog_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(OpenPictureDialog_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(OpenPictureDialog_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(OpenPictureDialog_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(OpenPictureDialog_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(OpenPictureDialog_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(OpenPictureDialog_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(OpenPictureDialog_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(OpenPictureDialog_ToString, self.0));
      }

	  pub fn Filter<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(OpenPictureDialog_GetFilter, self.0));
      }

	  pub fn SetFilter(&self, aValue: &str)  {
          method_Call_1!(OpenPictureDialog_SetFilter, self.0, to_CString!(aValue));
      }

	  pub fn Files(&self) -> TStrings  {
          return method_Call_2!(TStrings, OpenPictureDialog_GetFiles, self.0);
      }

	  pub fn DefaultExt<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(OpenPictureDialog_GetDefaultExt, self.0));
      }

	  pub fn SetDefaultExt(&self, aValue: &str)  {
          method_Call_1!(OpenPictureDialog_SetDefaultExt, self.0, to_CString!(aValue));
      }

	  pub fn FileName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(OpenPictureDialog_GetFileName, self.0));
      }

	  pub fn SetFileName(&self, aValue: &str)  {
          method_Call_1!(OpenPictureDialog_SetFileName, self.0, to_CString!(aValue));
      }

	  pub fn FilterIndex(&self) -> i32  {
          return method_Call_1!(OpenPictureDialog_GetFilterIndex, self.0);
      }

	  pub fn SetFilterIndex(&self, aValue: i32)  {
          method_Call_1!(OpenPictureDialog_SetFilterIndex, self.0, aValue);
      }

	  pub fn InitialDir<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(OpenPictureDialog_GetInitialDir, self.0));
      }

	  pub fn SetInitialDir(&self, aValue: &str)  {
          method_Call_1!(OpenPictureDialog_SetInitialDir, self.0, to_CString!(aValue));
      }

	  pub fn Options(&self) -> TOpenOptions  {
          return method_Call_1!(OpenPictureDialog_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TOpenOptions)  {
          method_Call_1!(OpenPictureDialog_SetOptions, self.0, aValue);
      }

	  pub fn Title<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(OpenPictureDialog_GetTitle, self.0));
      }

	  pub fn SetTitle(&self, aValue: &str)  {
          method_Call_1!(OpenPictureDialog_SetTitle, self.0, to_CString!(aValue));
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(OpenPictureDialog_GetHandle, self.0);
      }

	  pub fn SetOnClose(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(OpenPictureDialog_SetOnClose, self.0, aEventId);
      }

	  pub fn SetOnShow(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(OpenPictureDialog_SetOnShow, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(OpenPictureDialog_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(OpenPictureDialog_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(OpenPictureDialog_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, OpenPictureDialog_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(OpenPictureDialog_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(OpenPictureDialog_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(OpenPictureDialog_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(OpenPictureDialog_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, OpenPictureDialog_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(OpenPictureDialog_StaticClassType);
}

impl_IObject!(TOpenPictureDialog);
impl_IComponent!(TOpenPictureDialog);

impl TSavePictureDialog {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TSavePictureDialog, SavePictureDialog_Create, aOwner.Instance());
      }

      impl_As_method!(TSavePictureDialog);

	  impl_Free_method!(SavePictureDialog_Free);

	  pub fn Execute(&self) -> bool  {
          return method_Call_1!(SavePictureDialog_Execute, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, SavePictureDialog_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SavePictureDialog_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(SavePictureDialog_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(SavePictureDialog_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(SavePictureDialog_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SavePictureDialog_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(SavePictureDialog_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(SavePictureDialog_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(SavePictureDialog_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(SavePictureDialog_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SavePictureDialog_ToString, self.0));
      }

	  pub fn Filter<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SavePictureDialog_GetFilter, self.0));
      }

	  pub fn SetFilter(&self, aValue: &str)  {
          method_Call_1!(SavePictureDialog_SetFilter, self.0, to_CString!(aValue));
      }

	  pub fn Files(&self) -> TStrings  {
          return method_Call_2!(TStrings, SavePictureDialog_GetFiles, self.0);
      }

	  pub fn DefaultExt<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SavePictureDialog_GetDefaultExt, self.0));
      }

	  pub fn SetDefaultExt(&self, aValue: &str)  {
          method_Call_1!(SavePictureDialog_SetDefaultExt, self.0, to_CString!(aValue));
      }

	  pub fn FileName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SavePictureDialog_GetFileName, self.0));
      }

	  pub fn SetFileName(&self, aValue: &str)  {
          method_Call_1!(SavePictureDialog_SetFileName, self.0, to_CString!(aValue));
      }

	  pub fn FilterIndex(&self) -> i32  {
          return method_Call_1!(SavePictureDialog_GetFilterIndex, self.0);
      }

	  pub fn SetFilterIndex(&self, aValue: i32)  {
          method_Call_1!(SavePictureDialog_SetFilterIndex, self.0, aValue);
      }

	  pub fn InitialDir<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SavePictureDialog_GetInitialDir, self.0));
      }

	  pub fn SetInitialDir(&self, aValue: &str)  {
          method_Call_1!(SavePictureDialog_SetInitialDir, self.0, to_CString!(aValue));
      }

	  pub fn Options(&self) -> TOpenOptions  {
          return method_Call_1!(SavePictureDialog_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TOpenOptions)  {
          method_Call_1!(SavePictureDialog_SetOptions, self.0, aValue);
      }

	  pub fn Title<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SavePictureDialog_GetTitle, self.0));
      }

	  pub fn SetTitle(&self, aValue: &str)  {
          method_Call_1!(SavePictureDialog_SetTitle, self.0, to_CString!(aValue));
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(SavePictureDialog_GetHandle, self.0);
      }

	  pub fn SetOnClose(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(SavePictureDialog_SetOnClose, self.0, aEventId);
      }

	  pub fn SetOnShow(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(SavePictureDialog_SetOnShow, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(SavePictureDialog_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(SavePictureDialog_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(SavePictureDialog_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, SavePictureDialog_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SavePictureDialog_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(SavePictureDialog_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(SavePictureDialog_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(SavePictureDialog_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, SavePictureDialog_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(SavePictureDialog_StaticClassType);
}

impl_IObject!(TSavePictureDialog);
impl_IComponent!(TSavePictureDialog);

impl TSelectDirectoryDialog {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TSelectDirectoryDialog, SelectDirectoryDialog_Create, aOwner.Instance());
      }

      impl_As_method!(TSelectDirectoryDialog);

	  impl_Free_method!(SelectDirectoryDialog_Free);

	  pub fn Execute(&self) -> bool  {
          return method_Call_1!(SelectDirectoryDialog_Execute, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, SelectDirectoryDialog_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SelectDirectoryDialog_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(SelectDirectoryDialog_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(SelectDirectoryDialog_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(SelectDirectoryDialog_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SelectDirectoryDialog_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(SelectDirectoryDialog_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(SelectDirectoryDialog_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(SelectDirectoryDialog_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(SelectDirectoryDialog_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SelectDirectoryDialog_ToString, self.0));
      }

	  pub fn Files(&self) -> TStrings  {
          return method_Call_2!(TStrings, SelectDirectoryDialog_GetFiles, self.0);
      }

	  pub fn DefaultExt<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SelectDirectoryDialog_GetDefaultExt, self.0));
      }

	  pub fn SetDefaultExt(&self, aValue: &str)  {
          method_Call_1!(SelectDirectoryDialog_SetDefaultExt, self.0, to_CString!(aValue));
      }

	  pub fn FileName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SelectDirectoryDialog_GetFileName, self.0));
      }

	  pub fn SetFileName(&self, aValue: &str)  {
          method_Call_1!(SelectDirectoryDialog_SetFileName, self.0, to_CString!(aValue));
      }

	  pub fn Filter<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SelectDirectoryDialog_GetFilter, self.0));
      }

	  pub fn SetFilter(&self, aValue: &str)  {
          method_Call_1!(SelectDirectoryDialog_SetFilter, self.0, to_CString!(aValue));
      }

	  pub fn FilterIndex(&self) -> i32  {
          return method_Call_1!(SelectDirectoryDialog_GetFilterIndex, self.0);
      }

	  pub fn SetFilterIndex(&self, aValue: i32)  {
          method_Call_1!(SelectDirectoryDialog_SetFilterIndex, self.0, aValue);
      }

	  pub fn InitialDir<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SelectDirectoryDialog_GetInitialDir, self.0));
      }

	  pub fn SetInitialDir(&self, aValue: &str)  {
          method_Call_1!(SelectDirectoryDialog_SetInitialDir, self.0, to_CString!(aValue));
      }

	  pub fn Options(&self) -> TOpenOptions  {
          return method_Call_1!(SelectDirectoryDialog_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TOpenOptions)  {
          method_Call_1!(SelectDirectoryDialog_SetOptions, self.0, aValue);
      }

	  pub fn Title<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SelectDirectoryDialog_GetTitle, self.0));
      }

	  pub fn SetTitle(&self, aValue: &str)  {
          method_Call_1!(SelectDirectoryDialog_SetTitle, self.0, to_CString!(aValue));
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(SelectDirectoryDialog_GetHandle, self.0);
      }

	  pub fn SetOnClose(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(SelectDirectoryDialog_SetOnClose, self.0, aEventId);
      }

	  pub fn SetOnShow(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(SelectDirectoryDialog_SetOnShow, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(SelectDirectoryDialog_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(SelectDirectoryDialog_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(SelectDirectoryDialog_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, SelectDirectoryDialog_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SelectDirectoryDialog_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(SelectDirectoryDialog_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(SelectDirectoryDialog_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(SelectDirectoryDialog_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, SelectDirectoryDialog_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(SelectDirectoryDialog_StaticClassType);
}

impl_IObject!(TSelectDirectoryDialog);
impl_IComponent!(TSelectDirectoryDialog);

impl TRichEdit {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TRichEdit, RichEdit_Create, aOwner.Instance());
      }

      impl_As_method!(TRichEdit);

	  impl_Free_method!(RichEdit_Free);

	  pub fn Clear(&self)  {
          method_Call_1!(RichEdit_Clear, self.0);
      }

	  pub fn FindText(&self, searchStr: &str, startPos: i32, length: i32, options: TSearchTypes) -> i32  {
          return method_Call_1!(RichEdit_FindText, self.0, to_CString!(searchStr), startPos, length, options);
      }

	  pub fn ClearSelection(&self)  {
          method_Call_1!(RichEdit_ClearSelection, self.0);
      }

	  pub fn CopyToClipboard(&self)  {
          method_Call_1!(RichEdit_CopyToClipboard, self.0);
      }

	  pub fn CutToClipboard(&self)  {
          method_Call_1!(RichEdit_CutToClipboard, self.0);
      }

	  pub fn PasteFromClipboard(&self)  {
          method_Call_1!(RichEdit_PasteFromClipboard, self.0);
      }

	  pub fn Undo(&self)  {
          method_Call_1!(RichEdit_Undo, self.0);
      }

	  pub fn SelectAll(&self)  {
          method_Call_1!(RichEdit_SelectAll, self.0);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(RichEdit_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(RichEdit_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, RichEdit_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(RichEdit_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(RichEdit_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, RichEdit_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(RichEdit_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(RichEdit_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(RichEdit_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(RichEdit_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(RichEdit_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(RichEdit_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(RichEdit_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(RichEdit_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(RichEdit_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(RichEdit_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(RichEdit_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(RichEdit_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(RichEdit_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(RichEdit_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(RichEdit_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(RichEdit_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(RichEdit_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(RichEdit_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(RichEdit_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(RichEdit_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(RichEdit_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(RichEdit_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(RichEdit_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(RichEdit_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(RichEdit_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(RichEdit_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(RichEdit_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(RichEdit_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, RichEdit_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(RichEdit_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(RichEdit_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(RichEdit_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(RichEdit_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(RichEdit_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(RichEdit_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(RichEdit_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(RichEdit_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(RichEdit_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(RichEdit_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(RichEdit_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(RichEdit_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(RichEdit_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(RichEdit_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(RichEdit_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(RichEdit_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(RichEdit_SetAlign, self.0, aValue);
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(RichEdit_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(RichEdit_SetAlignment, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(RichEdit_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(RichEdit_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(RichEdit_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(RichEdit_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(RichEdit_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(RichEdit_SetBorderStyle, self.0, aValue);
      }

	  pub fn BorderWidth(&self) -> i32  {
          return method_Call_1!(RichEdit_GetBorderWidth, self.0);
      }

	  pub fn SetBorderWidth(&self, aValue: i32)  {
          method_Call_1!(RichEdit_SetBorderWidth, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(RichEdit_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(RichEdit_SetColor, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(RichEdit_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(RichEdit_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(RichEdit_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(RichEdit_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(RichEdit_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(RichEdit_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(RichEdit_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, RichEdit_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(RichEdit_SetFont, self.0, aValue.Instance());
      }

	  pub fn HideSelection(&self) -> bool  {
          return method_Call_1!(RichEdit_GetHideSelection, self.0);
      }

	  pub fn SetHideSelection(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetHideSelection, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, RichEdit_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(RichEdit_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn Lines(&self) -> TStrings  {
          return method_Call_2!(TStrings, RichEdit_GetLines, self.0);
      }

	  pub fn SetLines(&self, aValue: &dyn IStrings)  {
          method_Call_1!(RichEdit_SetLines, self.0, aValue.Instance());
      }

	  pub fn MaxLength(&self) -> i32  {
          return method_Call_1!(RichEdit_GetMaxLength, self.0);
      }

	  pub fn SetMaxLength(&self, aValue: i32)  {
          method_Call_1!(RichEdit_SetMaxLength, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(RichEdit_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetParentColor, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(RichEdit_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(RichEdit_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, RichEdit_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(RichEdit_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ReadOnly(&self) -> bool  {
          return method_Call_1!(RichEdit_GetReadOnly, self.0);
      }

	  pub fn SetReadOnly(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetReadOnly, self.0, aValue);
      }

	  pub fn ScrollBars(&self) -> TScrollStyle  {
          return method_Call_1!(RichEdit_GetScrollBars, self.0);
      }

	  pub fn SetScrollBars(&self, aValue: TScrollStyle)  {
          method_Call_1!(RichEdit_SetScrollBars, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(RichEdit_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(RichEdit_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(RichEdit_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(RichEdit_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(RichEdit_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetVisible, self.0, aValue);
      }

	  pub fn WantTabs(&self) -> bool  {
          return method_Call_1!(RichEdit_GetWantTabs, self.0);
      }

	  pub fn SetWantTabs(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetWantTabs, self.0, aValue);
      }

	  pub fn WantReturns(&self) -> bool  {
          return method_Call_1!(RichEdit_GetWantReturns, self.0);
      }

	  pub fn SetWantReturns(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetWantReturns, self.0, aValue);
      }

	  pub fn WordWrap(&self) -> bool  {
          return method_Call_1!(RichEdit_GetWordWrap, self.0);
      }

	  pub fn SetWordWrap(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetWordWrap, self.0, aValue);
      }

	  pub fn Zoom(&self) -> i32  {
          return method_Call_1!(RichEdit_GetZoom, self.0);
      }

	  pub fn SetZoom(&self, aValue: i32)  {
          method_Call_1!(RichEdit_SetZoom, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RichEdit_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RichEdit_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(RichEdit_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RichEdit_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(RichEdit_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(RichEdit_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(RichEdit_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RichEdit_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RichEdit_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(RichEdit_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(RichEdit_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(RichEdit_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(RichEdit_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RichEdit_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(RichEdit_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(RichEdit_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(RichEdit_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnMouseWheel(&self, aEventId: TMouseWheelEvent)  {
          method_Call_1!(RichEdit_SetOnMouseWheel, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelDown(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(RichEdit_SetOnMouseWheelDown, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelUp(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(RichEdit_SetOnMouseWheelUp, self.0, aEventId);
      }

	  pub fn DefAttributes(&self) -> TTextAttributes  {
          return method_Call_2!(TTextAttributes, RichEdit_GetDefAttributes, self.0);
      }

	  pub fn SetDefAttributes(&self, aValue: &TTextAttributes)  {
          method_Call_1!(RichEdit_SetDefAttributes, self.0, aValue.Instance());
      }

	  pub fn SelAttributes(&self) -> TTextAttributes  {
          return method_Call_2!(TTextAttributes, RichEdit_GetSelAttributes, self.0);
      }

	  pub fn SetSelAttributes(&self, aValue: &TTextAttributes)  {
          method_Call_1!(RichEdit_SetSelAttributes, self.0, aValue.Instance());
      }

	  pub fn Paragraph(&self) -> TParaAttributes  {
          return method_Call_2!(TParaAttributes, RichEdit_GetParagraph, self.0);
      }

	  pub fn CaretPos(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(RichEdit_GetCaretPos, self.0, &mut result);
          return result;
      }

	  pub fn SetCaretPos(&self, aValue: *mut TPoint)  {
          method_Call_1!(RichEdit_SetCaretPos, self.0, aValue);
      }

	  pub fn CanUndo(&self) -> bool  {
          return method_Call_1!(RichEdit_GetCanUndo, self.0);
      }

	  pub fn Modified(&self) -> bool  {
          return method_Call_1!(RichEdit_GetModified, self.0);
      }

	  pub fn SetModified(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetModified, self.0, aValue);
      }

	  pub fn SelLength(&self) -> i32  {
          return method_Call_1!(RichEdit_GetSelLength, self.0);
      }

	  pub fn SetSelLength(&self, aValue: i32)  {
          method_Call_1!(RichEdit_SetSelLength, self.0, aValue);
      }

	  pub fn SelStart(&self) -> i32  {
          return method_Call_1!(RichEdit_GetSelStart, self.0);
      }

	  pub fn SetSelStart(&self, aValue: i32)  {
          method_Call_1!(RichEdit_SetSelStart, self.0, aValue);
      }

	  pub fn SelText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(RichEdit_GetSelText, self.0));
      }

	  pub fn SetSelText(&self, aValue: &str)  {
          method_Call_1!(RichEdit_SetSelText, self.0, to_CString!(aValue));
      }

	  pub fn Text<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(RichEdit_GetText, self.0));
      }

	  pub fn SetText(&self, aValue: &str)  {
          method_Call_1!(RichEdit_SetText, self.0, to_CString!(aValue));
      }

	  pub fn TextHint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(RichEdit_GetTextHint, self.0));
      }

	  pub fn SetTextHint(&self, aValue: &str)  {
          method_Call_1!(RichEdit_SetTextHint, self.0, to_CString!(aValue));
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(RichEdit_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(RichEdit_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetDockSite, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(RichEdit_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(RichEdit_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(RichEdit_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, RichEdit_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(RichEdit_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(RichEdit_GetHandle, self.0);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(RichEdit_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(RichEdit_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(RichEdit_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(RichEdit_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(RichEdit_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(RichEdit_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, RichEdit_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(RichEdit_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(RichEdit_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(RichEdit_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(RichEdit_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(RichEdit_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(RichEdit_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(RichEdit_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(RichEdit_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(RichEdit_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(RichEdit_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(RichEdit_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(RichEdit_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(RichEdit_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(RichEdit_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, RichEdit_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(RichEdit_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(RichEdit_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(RichEdit_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(RichEdit_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(RichEdit_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(RichEdit_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(RichEdit_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(RichEdit_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(RichEdit_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(RichEdit_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(RichEdit_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(RichEdit_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(RichEdit_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(RichEdit_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(RichEdit_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(RichEdit_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, RichEdit_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(RichEdit_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(RichEdit_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(RichEdit_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(RichEdit_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, RichEdit_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(RichEdit_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, RichEdit_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(RichEdit_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, RichEdit_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(RichEdit_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, RichEdit_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(RichEdit_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, RichEdit_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(RichEdit_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, RichEdit_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(RichEdit_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, RichEdit_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, RichEdit_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, RichEdit_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, RichEdit_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(RichEdit_StaticClassType);
}

impl_IObject!(TRichEdit);
impl_IComponent!(TRichEdit);
impl_IControl!(TRichEdit);
impl_IWinControl!(TRichEdit);

impl TTrackBar {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TTrackBar, TrackBar_Create, aOwner.Instance());
      }

      impl_As_method!(TTrackBar);

	  impl_Free_method!(TrackBar_Free);

	  pub fn SetTick(&self, value: i32)  {
          method_Call_1!(TrackBar_SetTick, self.0, value);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(TrackBar_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(TrackBar_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, TrackBar_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(TrackBar_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(TrackBar_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, TrackBar_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(TrackBar_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(TrackBar_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(TrackBar_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(TrackBar_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(TrackBar_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(TrackBar_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(TrackBar_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(TrackBar_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(TrackBar_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(TrackBar_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(TrackBar_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(TrackBar_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(TrackBar_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(TrackBar_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(TrackBar_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(TrackBar_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(TrackBar_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(TrackBar_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(TrackBar_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(TrackBar_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(TrackBar_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(TrackBar_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(TrackBar_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(TrackBar_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(TrackBar_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(TrackBar_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(TrackBar_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(TrackBar_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, TrackBar_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TrackBar_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(TrackBar_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(TrackBar_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TrackBar_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(TrackBar_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(TrackBar_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(TrackBar_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(TrackBar_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TrackBar_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(TrackBar_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(TrackBar_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(TrackBar_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(TrackBar_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(TrackBar_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(TrackBar_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(TrackBar_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(TrackBar_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(TrackBar_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(TrackBar_SetAnchors, self.0, aValue);
      }

	  pub fn BorderWidth(&self) -> i32  {
          return method_Call_1!(TrackBar_GetBorderWidth, self.0);
      }

	  pub fn SetBorderWidth(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetBorderWidth, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(TrackBar_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(TrackBar_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(TrackBar_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(TrackBar_SetDragCursor, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(TrackBar_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(TrackBar_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(TrackBar_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(TrackBar_SetEnabled, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, TrackBar_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(TrackBar_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn LineSize(&self) -> i32  {
          return method_Call_1!(TrackBar_GetLineSize, self.0);
      }

	  pub fn SetLineSize(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetLineSize, self.0, aValue);
      }

	  pub fn Max(&self) -> i32  {
          return method_Call_1!(TrackBar_GetMax, self.0);
      }

	  pub fn SetMax(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetMax, self.0, aValue);
      }

	  pub fn Min(&self) -> i32  {
          return method_Call_1!(TrackBar_GetMin, self.0);
      }

	  pub fn SetMin(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetMin, self.0, aValue);
      }

	  pub fn Orientation(&self) -> TTrackBarOrientation  {
          return method_Call_1!(TrackBar_GetOrientation, self.0);
      }

	  pub fn SetOrientation(&self, aValue: TTrackBarOrientation)  {
          method_Call_1!(TrackBar_SetOrientation, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(TrackBar_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(TrackBar_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(TrackBar_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(TrackBar_SetParentShowHint, self.0, aValue);
      }

	  pub fn PageSize(&self) -> i32  {
          return method_Call_1!(TrackBar_GetPageSize, self.0);
      }

	  pub fn SetPageSize(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetPageSize, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, TrackBar_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(TrackBar_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn Frequency(&self) -> i32  {
          return method_Call_1!(TrackBar_GetFrequency, self.0);
      }

	  pub fn SetFrequency(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetFrequency, self.0, aValue);
      }

	  pub fn Position(&self) -> i32  {
          return method_Call_1!(TrackBar_GetPosition, self.0);
      }

	  pub fn SetPosition(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetPosition, self.0, aValue);
      }

	  pub fn SelEnd(&self) -> i32  {
          return method_Call_1!(TrackBar_GetSelEnd, self.0);
      }

	  pub fn SetSelEnd(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetSelEnd, self.0, aValue);
      }

	  pub fn SelStart(&self) -> i32  {
          return method_Call_1!(TrackBar_GetSelStart, self.0);
      }

	  pub fn SetSelStart(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetSelStart, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(TrackBar_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(TrackBar_SetShowHint, self.0, aValue);
      }

	  pub fn ShowSelRange(&self) -> bool  {
          return method_Call_1!(TrackBar_GetShowSelRange, self.0);
      }

	  pub fn SetShowSelRange(&self, aValue: bool)  {
          method_Call_1!(TrackBar_SetShowSelRange, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(TrackBar_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(TrackBar_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(TrackBar_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(TrackBar_SetTabStop, self.0, aValue);
      }

	  pub fn TickMarks(&self) -> TTickMark  {
          return method_Call_1!(TrackBar_GetTickMarks, self.0);
      }

	  pub fn SetTickMarks(&self, aValue: TTickMark)  {
          method_Call_1!(TrackBar_SetTickMarks, self.0, aValue);
      }

	  pub fn TickStyle(&self) -> TTickStyle  {
          return method_Call_1!(TrackBar_GetTickStyle, self.0);
      }

	  pub fn SetTickStyle(&self, aValue: TTickStyle)  {
          method_Call_1!(TrackBar_SetTickStyle, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(TrackBar_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(TrackBar_SetVisible, self.0, aValue);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(TrackBar_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TrackBar_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(TrackBar_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(TrackBar_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(TrackBar_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TrackBar_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TrackBar_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(TrackBar_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(TrackBar_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(TrackBar_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(TrackBar_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(TrackBar_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(TrackBar_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(TrackBar_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(TrackBar_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, TrackBar_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(TrackBar_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(TrackBar_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(TrackBar_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(TrackBar_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(TrackBar_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(TrackBar_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(TrackBar_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, TrackBar_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(TrackBar_SetAction, self.0, aValue.Instance());
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(TrackBar_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(TrackBar_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(TrackBar_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(TrackBar_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(TrackBar_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(TrackBar_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(TrackBar_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(TrackBar_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(TrackBar_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(TrackBar_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(TrackBar_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(TrackBar_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(TrackBar_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, TrackBar_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(TrackBar_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(TrackBar_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(TrackBar_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(TrackBar_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(TrackBar_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(TrackBar_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(TrackBar_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TrackBar_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(TrackBar_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(TrackBar_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(TrackBar_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(TrackBar_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, TrackBar_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TrackBar_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(TrackBar_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(TrackBar_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(TrackBar_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, TrackBar_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(TrackBar_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, TrackBar_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(TrackBar_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, TrackBar_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(TrackBar_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, TrackBar_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(TrackBar_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, TrackBar_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(TrackBar_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, TrackBar_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(TrackBar_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, TrackBar_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, TrackBar_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, TrackBar_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, TrackBar_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(TrackBar_StaticClassType);
}

impl_IObject!(TTrackBar);
impl_IComponent!(TTrackBar);
impl_IControl!(TTrackBar);
impl_IWinControl!(TTrackBar);

impl TImageList {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TImageList, ImageList_Create, aOwner.Instance());
      }

      impl_As_method!(TImageList);

	  impl_Free_method!(ImageList_Free);

	  pub fn GetHotSpot(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ImageList_GetHotSpot, self.0, &mut result);
          return result;
      }

	  pub fn HideDragImage(&self)  {
          method_Call_1!(ImageList_HideDragImage, self.0);
      }

	  pub fn ShowDragImage(&self)  {
          method_Call_1!(ImageList_ShowDragImage, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ImageList_Assign, self.0, source.Instance());
      }

	  pub fn Add(&self, image: &TBitmap, mask: &TBitmap) -> i32  {
          return method_Call_1!(ImageList_Add, self.0, image.Instance(), mask.Instance());
      }

	  pub fn AddIcon(&self, image: &TIcon) -> i32  {
          return method_Call_1!(ImageList_AddIcon, self.0, image.Instance());
      }

	  pub fn AddImages(&self, value: &TImageList)  {
          method_Call_1!(ImageList_AddImages, self.0, value.Instance());
      }

	  pub fn AddMasked(&self, image: &TBitmap, maskColor: TColor) -> i32  {
          return method_Call_1!(ImageList_AddMasked, self.0, image.Instance(), maskColor);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(ImageList_Clear, self.0);
      }

	  pub fn Delete(&self, index: i32)  {
          method_Call_1!(ImageList_Delete, self.0, index);
      }

	  pub fn Insert(&self, index: i32, image: &TBitmap, mask: &TBitmap)  {
          method_Call_1!(ImageList_Insert, self.0, index, image.Instance(), mask.Instance());
      }

	  pub fn InsertIcon(&self, index: i32, image: &TIcon)  {
          method_Call_1!(ImageList_InsertIcon, self.0, index, image.Instance());
      }

	  pub fn InsertMasked(&self, index: i32, image: &TBitmap, maskColor: TColor)  {
          method_Call_1!(ImageList_InsertMasked, self.0, index, image.Instance(), maskColor);
      }

	  pub fn Move(&self, curIndex: i32, newIndex: i32)  {
          method_Call_1!(ImageList_Move, self.0, curIndex, newIndex);
      }

	  pub fn Replace(&self, index: i32, image: &TBitmap, mask: &TBitmap)  {
          method_Call_1!(ImageList_Replace, self.0, index, image.Instance(), mask.Instance());
      }

	  pub fn ReplaceMasked(&self, index: i32, newImage: &TBitmap, maskColor: TColor)  {
          method_Call_1!(ImageList_ReplaceMasked, self.0, index, newImage.Instance(), maskColor);
      }

	  pub fn BeginUpdate(&self)  {
          method_Call_1!(ImageList_BeginUpdate, self.0);
      }

	  pub fn EndUpdate(&self)  {
          method_Call_1!(ImageList_EndUpdate, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ImageList_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ImageList_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ImageList_HasParent, self.0);
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ImageList_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ImageList_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ImageList_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ImageList_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ImageList_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ImageList_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ImageList_ToString, self.0));
      }

	  pub fn BlendColor(&self) -> TColor  {
          return method_Call_1!(ImageList_GetBlendColor, self.0);
      }

	  pub fn SetBlendColor(&self, aValue: TColor)  {
          method_Call_1!(ImageList_SetBlendColor, self.0, aValue);
      }

	  pub fn BkColor(&self) -> TColor  {
          return method_Call_1!(ImageList_GetBkColor, self.0);
      }

	  pub fn SetBkColor(&self, aValue: TColor)  {
          method_Call_1!(ImageList_SetBkColor, self.0, aValue);
      }

	  pub fn AllocBy(&self) -> i32  {
          return method_Call_1!(ImageList_GetAllocBy, self.0);
      }

	  pub fn SetAllocBy(&self, aValue: i32)  {
          method_Call_1!(ImageList_SetAllocBy, self.0, aValue);
      }

	  pub fn DrawingStyle(&self) -> TDrawingStyle  {
          return method_Call_1!(ImageList_GetDrawingStyle, self.0);
      }

	  pub fn SetDrawingStyle(&self, aValue: TDrawingStyle)  {
          method_Call_1!(ImageList_SetDrawingStyle, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(ImageList_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(ImageList_SetHeight, self.0, aValue);
      }

	  pub fn ImageType(&self) -> TImageType  {
          return method_Call_1!(ImageList_GetImageType, self.0);
      }

	  pub fn SetImageType(&self, aValue: TImageType)  {
          method_Call_1!(ImageList_SetImageType, self.0, aValue);
      }

	  pub fn Masked(&self) -> bool  {
          return method_Call_1!(ImageList_GetMasked, self.0);
      }

	  pub fn SetMasked(&self, aValue: bool)  {
          method_Call_1!(ImageList_SetMasked, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ImageList_SetOnChange, self.0, aEventId);
      }

	  pub fn ShareImages(&self) -> bool  {
          return method_Call_1!(ImageList_GetShareImages, self.0);
      }

	  pub fn SetShareImages(&self, aValue: bool)  {
          method_Call_1!(ImageList_SetShareImages, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ImageList_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ImageList_SetWidth, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(ImageList_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(ImageList_SetDragCursor, self.0, aValue);
      }

	  pub fn Dragging(&self) -> bool  {
          return method_Call_1!(ImageList_GetDragging, self.0);
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(ImageList_GetCount, self.0);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ImageList_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ImageList_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ImageList_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ImageList_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ImageList_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ImageList_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ImageList_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ImageList_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ImageList_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(ImageList_StaticClassType);
	  pub fn Draw1(&self, canvas: &TCanvas, x: i32, y: i32, index: i32, enabled: bool)  {
          method_Call_1!(ImageList_Draw1, self.0, canvas.Instance(), x, y, index, enabled);
      }

	  pub fn DrawOverlay1(&self, canvas: &TCanvas, x: i32, y: i32, imageIndex: i32, overlay: u8, enabled: bool)  {
          method_Call_1!(ImageList_DrawOverlay1, self.0, canvas.Instance(), x, y, imageIndex, overlay, enabled);
      }

	  pub fn GetIcon1(&self, index: i32, image: &TIcon)  {
          method_Call_1!(ImageList_GetIcon1, self.0, index, image.Instance());
      }

}

impl_IObject!(TImageList);
impl_IComponent!(TImageList);

impl TUpDown {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TUpDown, UpDown_Create, aOwner.Instance());
      }

      impl_As_method!(TUpDown);

	  impl_Free_method!(UpDown_Free);

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(UpDown_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(UpDown_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, UpDown_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(UpDown_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(UpDown_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, UpDown_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(UpDown_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(UpDown_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(UpDown_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(UpDown_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(UpDown_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(UpDown_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(UpDown_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(UpDown_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(UpDown_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(UpDown_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(UpDown_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(UpDown_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(UpDown_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(UpDown_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(UpDown_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(UpDown_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(UpDown_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(UpDown_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(UpDown_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(UpDown_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(UpDown_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(UpDown_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(UpDown_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(UpDown_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(UpDown_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(UpDown_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(UpDown_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(UpDown_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, UpDown_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(UpDown_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(UpDown_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(UpDown_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(UpDown_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(UpDown_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(UpDown_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(UpDown_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(UpDown_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(UpDown_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(UpDown_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(UpDown_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(UpDown_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(UpDown_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(UpDown_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(UpDown_AnchorClient, self.0, aSpace);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(UpDown_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(UpDown_SetAnchors, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(UpDown_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(UpDown_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(UpDown_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(UpDown_SetEnabled, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(UpDown_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(UpDown_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn Min(&self) -> i32  {
          return method_Call_1!(UpDown_GetMin, self.0);
      }

	  pub fn SetMin(&self, aValue: i32)  {
          method_Call_1!(UpDown_SetMin, self.0, aValue);
      }

	  pub fn Max(&self) -> i32  {
          return method_Call_1!(UpDown_GetMax, self.0);
      }

	  pub fn SetMax(&self, aValue: i32)  {
          method_Call_1!(UpDown_SetMax, self.0, aValue);
      }

	  pub fn Increment(&self) -> i32  {
          return method_Call_1!(UpDown_GetIncrement, self.0);
      }

	  pub fn SetIncrement(&self, aValue: i32)  {
          method_Call_1!(UpDown_SetIncrement, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, UpDown_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(UpDown_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn Orientation(&self) -> TUDOrientation  {
          return method_Call_1!(UpDown_GetOrientation, self.0);
      }

	  pub fn SetOrientation(&self, aValue: TUDOrientation)  {
          method_Call_1!(UpDown_SetOrientation, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(UpDown_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(UpDown_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(UpDown_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(UpDown_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, UpDown_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(UpDown_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn Position(&self) -> i32  {
          return method_Call_1!(UpDown_GetPosition, self.0);
      }

	  pub fn SetPosition(&self, aValue: i32)  {
          method_Call_1!(UpDown_SetPosition, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(UpDown_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(UpDown_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(UpDown_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(UpDown_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(UpDown_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(UpDown_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(UpDown_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(UpDown_SetVisible, self.0, aValue);
      }

	  pub fn Wrap(&self) -> bool  {
          return method_Call_1!(UpDown_GetWrap, self.0);
      }

	  pub fn SetWrap(&self, aValue: bool)  {
          method_Call_1!(UpDown_SetWrap, self.0, aValue);
      }

	  pub fn SetOnChanging(&self, aEventId: TUDChangingEvent)  {
          method_Call_1!(UpDown_SetOnChanging, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(UpDown_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TUDClickEvent)  {
          method_Call_1!(UpDown_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(UpDown_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(UpDown_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(UpDown_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(UpDown_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(UpDown_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(UpDown_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(UpDown_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(UpDown_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(UpDown_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(UpDown_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(UpDown_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(UpDown_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, UpDown_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(UpDown_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(UpDown_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(UpDown_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(UpDown_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(UpDown_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(UpDown_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(UpDown_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, UpDown_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(UpDown_SetAction, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(UpDown_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(UpDown_SetAlign, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(UpDown_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(UpDown_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(UpDown_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(UpDown_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(UpDown_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(UpDown_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(UpDown_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(UpDown_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(UpDown_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(UpDown_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(UpDown_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(UpDown_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(UpDown_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(UpDown_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(UpDown_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, UpDown_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(UpDown_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(UpDown_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(UpDown_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(UpDown_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(UpDown_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(UpDown_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(UpDown_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(UpDown_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(UpDown_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(UpDown_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(UpDown_SetCursor, self.0, aValue);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(UpDown_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(UpDown_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(UpDown_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, UpDown_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(UpDown_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(UpDown_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(UpDown_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(UpDown_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, UpDown_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(UpDown_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, UpDown_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(UpDown_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, UpDown_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(UpDown_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, UpDown_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(UpDown_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, UpDown_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(UpDown_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, UpDown_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(UpDown_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, UpDown_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, UpDown_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, UpDown_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, UpDown_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(UpDown_StaticClassType);
}

impl_IObject!(TUpDown);
impl_IComponent!(TUpDown);
impl_IControl!(TUpDown);
impl_IWinControl!(TUpDown);

impl TProgressBar {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TProgressBar, ProgressBar_Create, aOwner.Instance());
      }

      impl_As_method!(TProgressBar);

	  impl_Free_method!(ProgressBar_Free);

	  pub fn StepIt(&self)  {
          method_Call_1!(ProgressBar_StepIt, self.0);
      }

	  pub fn StepBy(&self, delta: i32)  {
          method_Call_1!(ProgressBar_StepBy, self.0, delta);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(ProgressBar_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(ProgressBar_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, ProgressBar_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(ProgressBar_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(ProgressBar_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, ProgressBar_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(ProgressBar_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(ProgressBar_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(ProgressBar_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ProgressBar_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(ProgressBar_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ProgressBar_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(ProgressBar_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(ProgressBar_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(ProgressBar_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(ProgressBar_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(ProgressBar_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(ProgressBar_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(ProgressBar_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(ProgressBar_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ProgressBar_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ProgressBar_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(ProgressBar_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ProgressBar_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(ProgressBar_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(ProgressBar_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(ProgressBar_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ProgressBar_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ProgressBar_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(ProgressBar_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(ProgressBar_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(ProgressBar_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(ProgressBar_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(ProgressBar_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ProgressBar_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ProgressBar_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ProgressBar_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ProgressBar_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ProgressBar_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ProgressBar_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ProgressBar_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ProgressBar_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ProgressBar_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ProgressBar_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ProgressBar_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ProgressBar_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ProgressBar_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ProgressBar_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(ProgressBar_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(ProgressBar_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(ProgressBar_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(ProgressBar_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(ProgressBar_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(ProgressBar_SetAnchors, self.0, aValue);
      }

	  pub fn BorderWidth(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetBorderWidth, self.0);
      }

	  pub fn SetBorderWidth(&self, aValue: i32)  {
          method_Call_1!(ProgressBar_SetBorderWidth, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(ProgressBar_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ProgressBar_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(ProgressBar_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(ProgressBar_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(ProgressBar_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(ProgressBar_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(ProgressBar_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(ProgressBar_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(ProgressBar_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(ProgressBar_SetEnabled, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ProgressBar_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(ProgressBar_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, ProgressBar_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(ProgressBar_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn Min(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetMin, self.0);
      }

	  pub fn SetMin(&self, aValue: i32)  {
          method_Call_1!(ProgressBar_SetMin, self.0, aValue);
      }

	  pub fn Max(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetMax, self.0);
      }

	  pub fn SetMax(&self, aValue: i32)  {
          method_Call_1!(ProgressBar_SetMax, self.0, aValue);
      }

	  pub fn Orientation(&self) -> TProgressBarOrientation  {
          return method_Call_1!(ProgressBar_GetOrientation, self.0);
      }

	  pub fn SetOrientation(&self, aValue: TProgressBarOrientation)  {
          method_Call_1!(ProgressBar_SetOrientation, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(ProgressBar_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ProgressBar_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(ProgressBar_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(ProgressBar_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, ProgressBar_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(ProgressBar_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn Position(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetPosition, self.0);
      }

	  pub fn SetPosition(&self, aValue: i32)  {
          method_Call_1!(ProgressBar_SetPosition, self.0, aValue);
      }

	  pub fn Smooth(&self) -> bool  {
          return method_Call_1!(ProgressBar_GetSmooth, self.0);
      }

	  pub fn SetSmooth(&self, aValue: bool)  {
          method_Call_1!(ProgressBar_SetSmooth, self.0, aValue);
      }

	  pub fn Style(&self) -> TProgressBarStyle  {
          return method_Call_1!(ProgressBar_GetStyle, self.0);
      }

	  pub fn SetStyle(&self, aValue: TProgressBarStyle)  {
          method_Call_1!(ProgressBar_SetStyle, self.0, aValue);
      }

	  pub fn Step(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetStep, self.0);
      }

	  pub fn SetStep(&self, aValue: i32)  {
          method_Call_1!(ProgressBar_SetStep, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(ProgressBar_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(ProgressBar_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(ProgressBar_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(ProgressBar_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(ProgressBar_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(ProgressBar_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(ProgressBar_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(ProgressBar_SetVisible, self.0, aValue);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(ProgressBar_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(ProgressBar_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(ProgressBar_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ProgressBar_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ProgressBar_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ProgressBar_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ProgressBar_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ProgressBar_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ProgressBar_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(ProgressBar_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ProgressBar_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(ProgressBar_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(ProgressBar_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(ProgressBar_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, ProgressBar_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(ProgressBar_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(ProgressBar_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(ProgressBar_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(ProgressBar_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(ProgressBar_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(ProgressBar_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, ProgressBar_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(ProgressBar_SetAction, self.0, aValue.Instance());
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(ProgressBar_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(ProgressBar_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ProgressBar_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(ProgressBar_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(ProgressBar_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ProgressBar_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ProgressBar_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(ProgressBar_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(ProgressBar_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(ProgressBar_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(ProgressBar_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(ProgressBar_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(ProgressBar_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, ProgressBar_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(ProgressBar_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ProgressBar_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ProgressBar_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ProgressBar_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(ProgressBar_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(ProgressBar_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(ProgressBar_SetCursor, self.0, aValue);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ProgressBar_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ProgressBar_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ProgressBar_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ProgressBar_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ProgressBar_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ProgressBar_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ProgressBar_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ProgressBar_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ProgressBar_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ProgressBar_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ProgressBar_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ProgressBar_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ProgressBar_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ProgressBar_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ProgressBar_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, ProgressBar_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(ProgressBar_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, ProgressBar_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(ProgressBar_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ProgressBar_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ProgressBar_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ProgressBar_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ProgressBar_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(ProgressBar_StaticClassType);
}

impl_IObject!(TProgressBar);
impl_IComponent!(TProgressBar);
impl_IControl!(TProgressBar);
impl_IWinControl!(TProgressBar);

impl TDateTimePicker {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TDateTimePicker, DateTimePicker_Create, aOwner.Instance());
      }

      impl_As_method!(TDateTimePicker);

	  impl_Free_method!(DateTimePicker_Free);

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(DateTimePicker_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(DateTimePicker_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, DateTimePicker_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(DateTimePicker_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(DateTimePicker_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, DateTimePicker_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(DateTimePicker_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(DateTimePicker_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(DateTimePicker_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(DateTimePicker_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(DateTimePicker_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(DateTimePicker_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(DateTimePicker_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(DateTimePicker_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(DateTimePicker_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(DateTimePicker_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(DateTimePicker_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(DateTimePicker_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(DateTimePicker_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(DateTimePicker_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(DateTimePicker_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(DateTimePicker_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(DateTimePicker_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(DateTimePicker_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(DateTimePicker_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(DateTimePicker_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(DateTimePicker_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(DateTimePicker_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(DateTimePicker_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(DateTimePicker_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(DateTimePicker_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(DateTimePicker_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(DateTimePicker_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(DateTimePicker_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, DateTimePicker_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(DateTimePicker_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(DateTimePicker_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(DateTimePicker_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(DateTimePicker_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(DateTimePicker_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(DateTimePicker_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(DateTimePicker_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(DateTimePicker_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(DateTimePicker_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(DateTimePicker_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(DateTimePicker_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(DateTimePicker_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(DateTimePicker_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(DateTimePicker_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(DateTimePicker_AnchorClient, self.0, aSpace);
      }

	  pub fn DateTime(&self) -> u32  {
          return method_Call_1!(DateTimePicker_GetDateTime, self.0);
      }

	  pub fn SetDateTime(&self, aValue: u32)  {
          method_Call_1!(DateTimePicker_SetDateTime, self.0, aValue);
      }

	  pub fn DroppedDown(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetDroppedDown, self.0);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(DateTimePicker_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(DateTimePicker_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(DateTimePicker_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(DateTimePicker_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(DateTimePicker_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(DateTimePicker_SetBiDiMode, self.0, aValue);
      }

	  pub fn CalAlignment(&self) -> TDTCalAlignment  {
          return method_Call_1!(DateTimePicker_GetCalAlignment, self.0);
      }

	  pub fn SetCalAlignment(&self, aValue: TDTCalAlignment)  {
          method_Call_1!(DateTimePicker_SetCalAlignment, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, DateTimePicker_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(DateTimePicker_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn Date(&self) -> u32  {
          return method_Call_1!(DateTimePicker_GetDate, self.0);
      }

	  pub fn SetDate(&self, aValue: u32)  {
          method_Call_1!(DateTimePicker_SetDate, self.0, aValue);
      }

	  pub fn Time(&self) -> u32  {
          return method_Call_1!(DateTimePicker_GetTime, self.0);
      }

	  pub fn SetTime(&self, aValue: u32)  {
          method_Call_1!(DateTimePicker_SetTime, self.0, aValue);
      }

	  pub fn Checked(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetChecked, self.0);
      }

	  pub fn SetChecked(&self, aValue: bool)  {
          method_Call_1!(DateTimePicker_SetChecked, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(DateTimePicker_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(DateTimePicker_SetColor, self.0, aValue);
      }

	  pub fn DateMode(&self) -> TDTDateMode  {
          return method_Call_1!(DateTimePicker_GetDateMode, self.0);
      }

	  pub fn SetDateMode(&self, aValue: TDTDateMode)  {
          method_Call_1!(DateTimePicker_SetDateMode, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(DateTimePicker_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(DateTimePicker_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, DateTimePicker_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(DateTimePicker_SetFont, self.0, aValue.Instance());
      }

	  pub fn MaxDate(&self) -> u32  {
          return method_Call_1!(DateTimePicker_GetMaxDate, self.0);
      }

	  pub fn SetMaxDate(&self, aValue: u32)  {
          method_Call_1!(DateTimePicker_SetMaxDate, self.0, aValue);
      }

	  pub fn MinDate(&self) -> u32  {
          return method_Call_1!(DateTimePicker_GetMinDate, self.0);
      }

	  pub fn SetMinDate(&self, aValue: u32)  {
          method_Call_1!(DateTimePicker_SetMinDate, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(DateTimePicker_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(DateTimePicker_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(DateTimePicker_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(DateTimePicker_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, DateTimePicker_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(DateTimePicker_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(DateTimePicker_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(DateTimePicker_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(DateTimePicker_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(DateTimePicker_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(DateTimePicker_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(DateTimePicker_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(DateTimePicker_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(DateTimePicker_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDropDown(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(DateTimePicker_SetOnDropDown, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(DateTimePicker_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(DateTimePicker_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(DateTimePicker_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(DateTimePicker_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(DateTimePicker_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(DateTimePicker_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(DateTimePicker_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(DateTimePicker_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(DateTimePicker_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(DateTimePicker_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, DateTimePicker_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(DateTimePicker_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(DateTimePicker_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(DateTimePicker_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(DateTimePicker_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(DateTimePicker_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, DateTimePicker_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(DateTimePicker_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(DateTimePicker_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(DateTimePicker_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(DateTimePicker_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(DateTimePicker_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(DateTimePicker_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(DateTimePicker_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(DateTimePicker_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(DateTimePicker_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(DateTimePicker_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(DateTimePicker_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(DateTimePicker_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(DateTimePicker_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(DateTimePicker_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, DateTimePicker_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(DateTimePicker_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(DateTimePicker_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(DateTimePicker_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(DateTimePicker_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(DateTimePicker_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(DateTimePicker_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(DateTimePicker_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(DateTimePicker_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(DateTimePicker_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(DateTimePicker_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(DateTimePicker_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(DateTimePicker_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(DateTimePicker_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(DateTimePicker_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(DateTimePicker_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(DateTimePicker_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, DateTimePicker_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(DateTimePicker_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(DateTimePicker_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(DateTimePicker_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(DateTimePicker_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, DateTimePicker_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(DateTimePicker_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, DateTimePicker_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(DateTimePicker_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, DateTimePicker_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(DateTimePicker_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, DateTimePicker_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(DateTimePicker_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, DateTimePicker_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(DateTimePicker_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, DateTimePicker_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(DateTimePicker_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, DateTimePicker_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, DateTimePicker_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, DateTimePicker_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, DateTimePicker_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(DateTimePicker_StaticClassType);
}

impl_IObject!(TDateTimePicker);
impl_IComponent!(TDateTimePicker);
impl_IControl!(TDateTimePicker);
impl_IWinControl!(TDateTimePicker);

impl TMonthCalendar {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TMonthCalendar, MonthCalendar_Create, aOwner.Instance());
      }

      impl_As_method!(TMonthCalendar);

	  impl_Free_method!(MonthCalendar_Free);

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(MonthCalendar_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(MonthCalendar_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, MonthCalendar_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(MonthCalendar_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(MonthCalendar_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, MonthCalendar_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(MonthCalendar_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(MonthCalendar_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(MonthCalendar_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(MonthCalendar_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(MonthCalendar_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(MonthCalendar_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(MonthCalendar_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(MonthCalendar_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(MonthCalendar_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(MonthCalendar_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(MonthCalendar_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(MonthCalendar_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(MonthCalendar_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(MonthCalendar_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(MonthCalendar_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(MonthCalendar_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(MonthCalendar_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(MonthCalendar_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(MonthCalendar_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(MonthCalendar_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(MonthCalendar_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(MonthCalendar_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(MonthCalendar_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(MonthCalendar_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(MonthCalendar_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(MonthCalendar_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(MonthCalendar_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(MonthCalendar_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, MonthCalendar_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MonthCalendar_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(MonthCalendar_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(MonthCalendar_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MonthCalendar_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(MonthCalendar_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(MonthCalendar_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(MonthCalendar_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(MonthCalendar_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MonthCalendar_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(MonthCalendar_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(MonthCalendar_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(MonthCalendar_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(MonthCalendar_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(MonthCalendar_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(MonthCalendar_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(MonthCalendar_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(MonthCalendar_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(MonthCalendar_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(MonthCalendar_SetAnchors, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(MonthCalendar_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(MonthCalendar_SetAutoSize, self.0, aValue);
      }

	  pub fn BorderWidth(&self) -> i32  {
          return method_Call_1!(MonthCalendar_GetBorderWidth, self.0);
      }

	  pub fn SetBorderWidth(&self, aValue: i32)  {
          method_Call_1!(MonthCalendar_SetBorderWidth, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(MonthCalendar_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(MonthCalendar_SetBiDiMode, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, MonthCalendar_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(MonthCalendar_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn Date(&self) -> u32  {
          return method_Call_1!(MonthCalendar_GetDate, self.0);
      }

	  pub fn SetDate(&self, aValue: u32)  {
          method_Call_1!(MonthCalendar_SetDate, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(MonthCalendar_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(MonthCalendar_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(MonthCalendar_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(MonthCalendar_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(MonthCalendar_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(MonthCalendar_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(MonthCalendar_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(MonthCalendar_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(MonthCalendar_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(MonthCalendar_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, MonthCalendar_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(MonthCalendar_SetFont, self.0, aValue.Instance());
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(MonthCalendar_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(MonthCalendar_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, MonthCalendar_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(MonthCalendar_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(MonthCalendar_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(MonthCalendar_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(MonthCalendar_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(MonthCalendar_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(MonthCalendar_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(MonthCalendar_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(MonthCalendar_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(MonthCalendar_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(MonthCalendar_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(MonthCalendar_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(MonthCalendar_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(MonthCalendar_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(MonthCalendar_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(MonthCalendar_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(MonthCalendar_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(MonthCalendar_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(MonthCalendar_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(MonthCalendar_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(MonthCalendar_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(MonthCalendar_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(MonthCalendar_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(MonthCalendar_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(MonthCalendar_SetOnStartDock, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(MonthCalendar_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(MonthCalendar_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(MonthCalendar_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(MonthCalendar_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(MonthCalendar_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, MonthCalendar_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(MonthCalendar_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(MonthCalendar_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(MonthCalendar_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(MonthCalendar_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(MonthCalendar_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(MonthCalendar_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(MonthCalendar_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, MonthCalendar_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(MonthCalendar_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(MonthCalendar_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(MonthCalendar_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(MonthCalendar_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(MonthCalendar_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(MonthCalendar_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(MonthCalendar_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(MonthCalendar_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(MonthCalendar_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(MonthCalendar_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(MonthCalendar_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(MonthCalendar_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(MonthCalendar_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(MonthCalendar_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, MonthCalendar_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(MonthCalendar_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(MonthCalendar_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(MonthCalendar_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(MonthCalendar_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(MonthCalendar_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(MonthCalendar_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(MonthCalendar_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(MonthCalendar_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(MonthCalendar_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(MonthCalendar_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(MonthCalendar_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MonthCalendar_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(MonthCalendar_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(MonthCalendar_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(MonthCalendar_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(MonthCalendar_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, MonthCalendar_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MonthCalendar_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(MonthCalendar_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(MonthCalendar_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(MonthCalendar_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, MonthCalendar_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(MonthCalendar_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, MonthCalendar_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(MonthCalendar_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, MonthCalendar_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(MonthCalendar_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, MonthCalendar_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(MonthCalendar_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, MonthCalendar_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(MonthCalendar_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, MonthCalendar_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(MonthCalendar_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, MonthCalendar_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, MonthCalendar_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, MonthCalendar_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, MonthCalendar_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(MonthCalendar_StaticClassType);
}

impl_IObject!(TMonthCalendar);
impl_IComponent!(TMonthCalendar);
impl_IControl!(TMonthCalendar);
impl_IWinControl!(TMonthCalendar);

impl TListView {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TListView, ListView_Create, aOwner.Instance());
      }

      impl_As_method!(TListView);

	  impl_Free_method!(ListView_Free);

	  pub fn AddItem(&self, item: &str, aObject: &dyn IObject)  {
          method_Call_1!(ListView_AddItem, self.0, to_CString!(item), aObject.Instance());
      }

	  pub fn AlphaSort(&self) -> bool  {
          return method_Call_1!(ListView_AlphaSort, self.0);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(ListView_Clear, self.0);
      }

	  pub fn ClearSelection(&self)  {
          method_Call_1!(ListView_ClearSelection, self.0);
      }

	  pub fn DeleteSelected(&self)  {
          method_Call_1!(ListView_DeleteSelected, self.0);
      }

	  pub fn IsEditing(&self) -> bool  {
          return method_Call_1!(ListView_IsEditing, self.0);
      }

	  pub fn SelectAll(&self)  {
          method_Call_1!(ListView_SelectAll, self.0);
      }

	  pub fn CustomSort(&self, sortProc: PFNLVCOMPARE, lParam: isize) -> bool  {
          return method_Call_1!(ListView_CustomSort, self.0, sortProc, lParam);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(ListView_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(ListView_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, ListView_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(ListView_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(ListView_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, ListView_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(ListView_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(ListView_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(ListView_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ListView_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(ListView_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ListView_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(ListView_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(ListView_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(ListView_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(ListView_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(ListView_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(ListView_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(ListView_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(ListView_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ListView_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ListView_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(ListView_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ListView_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(ListView_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(ListView_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(ListView_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ListView_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ListView_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(ListView_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(ListView_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(ListView_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(ListView_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(ListView_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ListView_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ListView_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ListView_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ListView_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ListView_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ListView_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ListView_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ListView_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ListView_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ListView_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ListView_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ListView_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ListView_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ListView_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(ListView_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(ListView_AnchorClient, self.0, aSpace);
      }

	  pub fn AutoSort(&self) -> bool  {
          return method_Call_1!(ListView_GetAutoSort, self.0);
      }

	  pub fn SetAutoSort(&self, aValue: bool)  {
          method_Call_1!(ListView_SetAutoSort, self.0, aValue);
      }

	  pub fn AutoSortIndicator(&self) -> bool  {
          return method_Call_1!(ListView_GetAutoSortIndicator, self.0);
      }

	  pub fn SetAutoSortIndicator(&self, aValue: bool)  {
          method_Call_1!(ListView_SetAutoSortIndicator, self.0, aValue);
      }

	  pub fn AutoWidthLastColumn(&self) -> bool  {
          return method_Call_1!(ListView_GetAutoWidthLastColumn, self.0);
      }

	  pub fn SetAutoWidthLastColumn(&self, aValue: bool)  {
          method_Call_1!(ListView_SetAutoWidthLastColumn, self.0, aValue);
      }

	  pub fn SmallImagesWidth(&self) -> i32  {
          return method_Call_1!(ListView_GetSmallImagesWidth, self.0);
      }

	  pub fn SetSmallImagesWidth(&self, aValue: i32)  {
          method_Call_1!(ListView_SetSmallImagesWidth, self.0, aValue);
      }

	  pub fn SortColumn(&self) -> i32  {
          return method_Call_1!(ListView_GetSortColumn, self.0);
      }

	  pub fn SetSortColumn(&self, aValue: i32)  {
          method_Call_1!(ListView_SetSortColumn, self.0, aValue);
      }

	  pub fn SortDirection(&self) -> TSortDirection  {
          return method_Call_1!(ListView_GetSortDirection, self.0);
      }

	  pub fn SetSortDirection(&self, aValue: TSortDirection)  {
          method_Call_1!(ListView_SetSortDirection, self.0, aValue);
      }

	  pub fn LargeImagesWidth(&self) -> i32  {
          return method_Call_1!(ListView_GetLargeImagesWidth, self.0);
      }

	  pub fn SetLargeImagesWidth(&self, aValue: i32)  {
          method_Call_1!(ListView_SetLargeImagesWidth, self.0, aValue);
      }

	  pub fn StateImagesWidth(&self) -> i32  {
          return method_Call_1!(ListView_GetStateImagesWidth, self.0);
      }

	  pub fn SetStateImagesWidth(&self, aValue: i32)  {
          method_Call_1!(ListView_SetStateImagesWidth, self.0, aValue);
      }

	  pub fn ToolTips(&self) -> bool  {
          return method_Call_1!(ListView_GetToolTips, self.0);
      }

	  pub fn SetToolTips(&self, aValue: bool)  {
          method_Call_1!(ListView_SetToolTips, self.0, aValue);
      }

	  pub fn ScrollBars(&self) -> TScrollStyle  {
          return method_Call_1!(ListView_GetScrollBars, self.0);
      }

	  pub fn SetScrollBars(&self, aValue: TScrollStyle)  {
          method_Call_1!(ListView_SetScrollBars, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, ListView_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(ListView_SetAction, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(ListView_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(ListView_SetAlign, self.0, aValue);
      }

	  pub fn AllocBy(&self) -> i32  {
          return method_Call_1!(ListView_GetAllocBy, self.0);
      }

	  pub fn SetAllocBy(&self, aValue: i32)  {
          method_Call_1!(ListView_SetAllocBy, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(ListView_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(ListView_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(ListView_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(ListView_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(ListView_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(ListView_SetBorderStyle, self.0, aValue);
      }

	  pub fn BorderWidth(&self) -> i32  {
          return method_Call_1!(ListView_GetBorderWidth, self.0);
      }

	  pub fn SetBorderWidth(&self, aValue: i32)  {
          method_Call_1!(ListView_SetBorderWidth, self.0, aValue);
      }

	  pub fn Checkboxes(&self) -> bool  {
          return method_Call_1!(ListView_GetCheckboxes, self.0);
      }

	  pub fn SetCheckboxes(&self, aValue: bool)  {
          method_Call_1!(ListView_SetCheckboxes, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(ListView_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(ListView_SetColor, self.0, aValue);
      }

	  pub fn Columns(&self) -> TListColumns  {
          return method_Call_2!(TListColumns, ListView_GetColumns, self.0);
      }

	  pub fn SetColumns(&self, aValue: &TListColumns)  {
          method_Call_1!(ListView_SetColumns, self.0, aValue.Instance());
      }

	  pub fn ColumnClick(&self) -> bool  {
          return method_Call_1!(ListView_GetColumnClick, self.0);
      }

	  pub fn SetColumnClick(&self, aValue: bool)  {
          method_Call_1!(ListView_SetColumnClick, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, ListView_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(ListView_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(ListView_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ListView_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(ListView_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(ListView_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(ListView_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(ListView_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(ListView_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(ListView_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(ListView_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(ListView_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, ListView_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(ListView_SetFont, self.0, aValue.Instance());
      }

	  pub fn FlatScrollBars(&self) -> bool  {
          return method_Call_1!(ListView_GetFlatScrollBars, self.0);
      }

	  pub fn SetFlatScrollBars(&self, aValue: bool)  {
          method_Call_1!(ListView_SetFlatScrollBars, self.0, aValue);
      }

	  pub fn FullDrag(&self) -> bool  {
          return method_Call_1!(ListView_GetFullDrag, self.0);
      }

	  pub fn SetFullDrag(&self, aValue: bool)  {
          method_Call_1!(ListView_SetFullDrag, self.0, aValue);
      }

	  pub fn GridLines(&self) -> bool  {
          return method_Call_1!(ListView_GetGridLines, self.0);
      }

	  pub fn SetGridLines(&self, aValue: bool)  {
          method_Call_1!(ListView_SetGridLines, self.0, aValue);
      }

	  pub fn HideSelection(&self) -> bool  {
          return method_Call_1!(ListView_GetHideSelection, self.0);
      }

	  pub fn SetHideSelection(&self, aValue: bool)  {
          method_Call_1!(ListView_SetHideSelection, self.0, aValue);
      }

	  pub fn HotTrack(&self) -> bool  {
          return method_Call_1!(ListView_GetHotTrack, self.0);
      }

	  pub fn SetHotTrack(&self, aValue: bool)  {
          method_Call_1!(ListView_SetHotTrack, self.0, aValue);
      }

	  pub fn IconOptions(&self) -> TIconOptions  {
          return method_Call_2!(TIconOptions, ListView_GetIconOptions, self.0);
      }

	  pub fn SetIconOptions(&self, aValue: &TIconOptions)  {
          method_Call_1!(ListView_SetIconOptions, self.0, aValue.Instance());
      }

	  pub fn Items(&self) -> TListItems  {
          return method_Call_2!(TListItems, ListView_GetItems, self.0);
      }

	  pub fn SetItems(&self, aValue: &TListItems)  {
          method_Call_1!(ListView_SetItems, self.0, aValue.Instance());
      }

	  pub fn LargeImages(&self) -> TImageList  {
          return method_Call_2!(TImageList, ListView_GetLargeImages, self.0);
      }

	  pub fn SetLargeImages(&self, aValue: &TImageList)  {
          method_Call_1!(ListView_SetLargeImages, self.0, aValue.Instance());
      }

	  pub fn MultiSelect(&self) -> bool  {
          return method_Call_1!(ListView_GetMultiSelect, self.0);
      }

	  pub fn SetMultiSelect(&self, aValue: bool)  {
          method_Call_1!(ListView_SetMultiSelect, self.0, aValue);
      }

	  pub fn OwnerData(&self) -> bool  {
          return method_Call_1!(ListView_GetOwnerData, self.0);
      }

	  pub fn SetOwnerData(&self, aValue: bool)  {
          method_Call_1!(ListView_SetOwnerData, self.0, aValue);
      }

	  pub fn OwnerDraw(&self) -> bool  {
          return method_Call_1!(ListView_GetOwnerDraw, self.0);
      }

	  pub fn SetOwnerDraw(&self, aValue: bool)  {
          method_Call_1!(ListView_SetOwnerDraw, self.0, aValue);
      }

	  pub fn ReadOnly(&self) -> bool  {
          return method_Call_1!(ListView_GetReadOnly, self.0);
      }

	  pub fn SetReadOnly(&self, aValue: bool)  {
          method_Call_1!(ListView_SetReadOnly, self.0, aValue);
      }

	  pub fn RowSelect(&self) -> bool  {
          return method_Call_1!(ListView_GetRowSelect, self.0);
      }

	  pub fn SetRowSelect(&self, aValue: bool)  {
          method_Call_1!(ListView_SetRowSelect, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(ListView_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(ListView_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(ListView_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ListView_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(ListView_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(ListView_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(ListView_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(ListView_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, ListView_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(ListView_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowColumnHeaders(&self) -> bool  {
          return method_Call_1!(ListView_GetShowColumnHeaders, self.0);
      }

	  pub fn SetShowColumnHeaders(&self, aValue: bool)  {
          method_Call_1!(ListView_SetShowColumnHeaders, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(ListView_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(ListView_SetShowHint, self.0, aValue);
      }

	  pub fn SmallImages(&self) -> TImageList  {
          return method_Call_2!(TImageList, ListView_GetSmallImages, self.0);
      }

	  pub fn SetSmallImages(&self, aValue: &TImageList)  {
          method_Call_1!(ListView_SetSmallImages, self.0, aValue.Instance());
      }

	  pub fn SortType(&self) -> TSortType  {
          return method_Call_1!(ListView_GetSortType, self.0);
      }

	  pub fn SetSortType(&self, aValue: TSortType)  {
          method_Call_1!(ListView_SetSortType, self.0, aValue);
      }

	  pub fn StateImages(&self) -> TImageList  {
          return method_Call_2!(TImageList, ListView_GetStateImages, self.0);
      }

	  pub fn SetStateImages(&self, aValue: &TImageList)  {
          method_Call_1!(ListView_SetStateImages, self.0, aValue.Instance());
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(ListView_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(ListView_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(ListView_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(ListView_SetTabStop, self.0, aValue);
      }

	  pub fn ViewStyle(&self) -> TViewStyle  {
          return method_Call_1!(ListView_GetViewStyle, self.0);
      }

	  pub fn SetViewStyle(&self, aValue: TViewStyle)  {
          method_Call_1!(ListView_SetViewStyle, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(ListView_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(ListView_SetVisible, self.0, aValue);
      }

	  pub fn SetOnAdvancedCustomDraw(&self, aEventId: TLVAdvancedCustomDrawEvent)  {
          method_Call_1!(ListView_SetOnAdvancedCustomDraw, self.0, aEventId);
      }

	  pub fn SetOnAdvancedCustomDrawItem(&self, aEventId: TLVAdvancedCustomDrawItemEvent)  {
          method_Call_1!(ListView_SetOnAdvancedCustomDrawItem, self.0, aEventId);
      }

	  pub fn SetOnAdvancedCustomDrawSubItem(&self, aEventId: TLVAdvancedCustomDrawSubItemEvent)  {
          method_Call_1!(ListView_SetOnAdvancedCustomDrawSubItem, self.0, aEventId);
      }

	  pub fn SetOnChange(&self, aEventId: TLVChangeEvent)  {
          method_Call_1!(ListView_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ListView_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnColumnClick(&self, aEventId: TLVColumnClickEvent)  {
          method_Call_1!(ListView_SetOnColumnClick, self.0, aEventId);
      }

	  pub fn SetOnCompare(&self, aEventId: TLVCompareEvent)  {
          method_Call_1!(ListView_SetOnCompare, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(ListView_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnCustomDraw(&self, aEventId: TLVCustomDrawEvent)  {
          method_Call_1!(ListView_SetOnCustomDraw, self.0, aEventId);
      }

	  pub fn SetOnCustomDrawItem(&self, aEventId: TLVCustomDrawItemEvent)  {
          method_Call_1!(ListView_SetOnCustomDrawItem, self.0, aEventId);
      }

	  pub fn SetOnCustomDrawSubItem(&self, aEventId: TLVCustomDrawSubItemEvent)  {
          method_Call_1!(ListView_SetOnCustomDrawSubItem, self.0, aEventId);
      }

	  pub fn SetOnData(&self, aEventId: TLVOwnerDataEvent)  {
          method_Call_1!(ListView_SetOnData, self.0, aEventId);
      }

	  pub fn SetOnDataFind(&self, aEventId: TLVOwnerDataFindEvent)  {
          method_Call_1!(ListView_SetOnDataFind, self.0, aEventId);
      }

	  pub fn SetOnDataHint(&self, aEventId: TLVOwnerDataHintEvent)  {
          method_Call_1!(ListView_SetOnDataHint, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ListView_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDeletion(&self, aEventId: TLVDeletedEvent)  {
          method_Call_1!(ListView_SetOnDeletion, self.0, aEventId);
      }

	  pub fn SetOnEdited(&self, aEventId: TLVEditedEvent)  {
          method_Call_1!(ListView_SetOnEdited, self.0, aEventId);
      }

	  pub fn SetOnEditing(&self, aEventId: TLVEditingEvent)  {
          method_Call_1!(ListView_SetOnEditing, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ListView_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ListView_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ListView_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ListView_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(ListView_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(ListView_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnInsert(&self, aEventId: TLVDeletedEvent)  {
          method_Call_1!(ListView_SetOnInsert, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ListView_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(ListView_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ListView_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ListView_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ListView_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ListView_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(ListView_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ListView_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnResize(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ListView_SetOnResize, self.0, aEventId);
      }

	  pub fn SetOnSelectItem(&self, aEventId: TLVSelectItemEvent)  {
          method_Call_1!(ListView_SetOnSelectItem, self.0, aEventId);
      }

	  pub fn SetOnItemChecked(&self, aEventId: TLVCheckedItemEvent)  {
          method_Call_1!(ListView_SetOnItemChecked, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(ListView_SetOnStartDock, self.0, aEventId);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, ListView_GetCanvas, self.0);
      }

	  pub fn DropTarget(&self) -> TListItem  {
          return method_Call_2!(TListItem, ListView_GetDropTarget, self.0);
      }

	  pub fn SetDropTarget(&self, aValue: &TListItem)  {
          method_Call_1!(ListView_SetDropTarget, self.0, aValue.Instance());
      }

	  pub fn ItemFocused(&self) -> TListItem  {
          return method_Call_2!(TListItem, ListView_GetItemFocused, self.0);
      }

	  pub fn SetItemFocused(&self, aValue: &TListItem)  {
          method_Call_1!(ListView_SetItemFocused, self.0, aValue.Instance());
      }

	  pub fn SelCount(&self) -> i32  {
          return method_Call_1!(ListView_GetSelCount, self.0);
      }

	  pub fn Selected(&self) -> TListItem  {
          return method_Call_2!(TListItem, ListView_GetSelected, self.0);
      }

	  pub fn SetSelected(&self, aValue: &TListItem)  {
          method_Call_1!(ListView_SetSelected, self.0, aValue.Instance());
      }

	  pub fn TopItem(&self) -> TListItem  {
          return method_Call_2!(TListItem, ListView_GetTopItem, self.0);
      }

	  pub fn VisibleRowCount(&self) -> i32  {
          return method_Call_1!(ListView_GetVisibleRowCount, self.0);
      }

	  pub fn ItemIndex(&self) -> i32  {
          return method_Call_1!(ListView_GetItemIndex, self.0);
      }

	  pub fn SetItemIndex(&self, aValue: i32)  {
          method_Call_1!(ListView_SetItemIndex, self.0, aValue);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(ListView_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(ListView_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(ListView_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(ListView_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(ListView_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, ListView_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(ListView_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(ListView_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(ListView_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(ListView_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(ListView_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(ListView_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(ListView_SetUseDockManager, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ListView_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(ListView_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(ListView_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(ListView_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ListView_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ListView_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(ListView_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(ListView_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(ListView_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(ListView_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(ListView_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(ListView_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(ListView_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, ListView_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(ListView_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ListView_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ListView_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ListView_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ListView_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ListView_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ListView_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(ListView_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(ListView_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(ListView_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(ListView_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ListView_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(ListView_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ListView_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ListView_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ListView_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ListView_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ListView_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ListView_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ListView_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ListView_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ListView_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ListView_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ListView_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ListView_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ListView_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ListView_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ListView_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ListView_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, ListView_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(ListView_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, ListView_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(ListView_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Column(&self, index: i32) -> TListColumn  {
          return method_Call_2!(TListColumn, ListView_GetColumn, self.0, index);
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ListView_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ListView_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ListView_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ListView_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(ListView_StaticClassType);
}

impl_IObject!(TListView);
impl_IComponent!(TListView);
impl_IControl!(TListView);
impl_IWinControl!(TListView);

impl TTreeView {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TTreeView, TreeView_Create, aOwner.Instance());
      }

      impl_As_method!(TTreeView);

	  impl_Free_method!(TreeView_Free);

	  pub fn AlphaSort(&self, aRecurse: bool) -> bool  {
          return method_Call_1!(TreeView_AlphaSort, self.0, aRecurse);
      }

	  pub fn FullCollapse(&self)  {
          method_Call_1!(TreeView_FullCollapse, self.0);
      }

	  pub fn FullExpand(&self)  {
          method_Call_1!(TreeView_FullExpand, self.0);
      }

	  pub fn GetNodeAt(&self, x: i32, y: i32) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeView_GetNodeAt, self.0, x, y);
      }

	  pub fn IsEditing(&self) -> bool  {
          return method_Call_1!(TreeView_IsEditing, self.0);
      }

	  pub fn LoadFromFile(&self, fileName: &str)  {
          method_Call_1!(TreeView_LoadFromFile, self.0, to_CString!(fileName));
      }

	  pub fn LoadFromStream(&self, stream: &dyn IObject)  {
          method_Call_1!(TreeView_LoadFromStream, self.0, stream.Instance());
      }

	  pub fn SaveToFile(&self, fileName: &str)  {
          method_Call_1!(TreeView_SaveToFile, self.0, to_CString!(fileName));
      }

	  pub fn SaveToStream(&self, stream: &dyn IObject)  {
          method_Call_1!(TreeView_SaveToStream, self.0, stream.Instance());
      }

	  pub fn ClearSelection(&self, keepPrimary: bool)  {
          method_Call_1!(TreeView_ClearSelection, self.0, keepPrimary);
      }

	  pub fn CustomSort(&self, sortProc: PFNTVCOMPARE, data: isize, aRecurse: bool) -> bool  {
          return method_Call_1!(TreeView_CustomSort, self.0, sortProc, data, aRecurse);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(TreeView_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(TreeView_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, TreeView_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(TreeView_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(TreeView_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, TreeView_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(TreeView_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(TreeView_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(TreeView_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(TreeView_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(TreeView_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(TreeView_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(TreeView_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(TreeView_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(TreeView_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(TreeView_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(TreeView_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(TreeView_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(TreeView_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(TreeView_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(TreeView_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(TreeView_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(TreeView_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(TreeView_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(TreeView_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(TreeView_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(TreeView_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(TreeView_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(TreeView_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(TreeView_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(TreeView_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(TreeView_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(TreeView_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(TreeView_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, TreeView_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TreeView_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(TreeView_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(TreeView_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TreeView_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(TreeView_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(TreeView_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(TreeView_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(TreeView_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TreeView_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(TreeView_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(TreeView_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(TreeView_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(TreeView_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(TreeView_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(TreeView_AnchorClient, self.0, aSpace);
      }

	  pub fn DefaultItemHeight(&self) -> i32  {
          return method_Call_1!(TreeView_GetDefaultItemHeight, self.0);
      }

	  pub fn SetDefaultItemHeight(&self, aValue: i32)  {
          method_Call_1!(TreeView_SetDefaultItemHeight, self.0, aValue);
      }

	  pub fn ExpandSignColor(&self) -> TColor  {
          return method_Call_1!(TreeView_GetExpandSignColor, self.0);
      }

	  pub fn SetExpandSignColor(&self, aValue: TColor)  {
          method_Call_1!(TreeView_SetExpandSignColor, self.0, aValue);
      }

	  pub fn ExpandSignSize(&self) -> i32  {
          return method_Call_1!(TreeView_GetExpandSignSize, self.0);
      }

	  pub fn SetExpandSignSize(&self, aValue: i32)  {
          method_Call_1!(TreeView_SetExpandSignSize, self.0, aValue);
      }

	  pub fn ExpandSignType(&self) -> TTreeViewExpandSignType  {
          return method_Call_1!(TreeView_GetExpandSignType, self.0);
      }

	  pub fn SetExpandSignType(&self, aValue: TTreeViewExpandSignType)  {
          method_Call_1!(TreeView_SetExpandSignType, self.0, aValue);
      }

	  pub fn HotTrackColor(&self) -> TColor  {
          return method_Call_1!(TreeView_GetHotTrackColor, self.0);
      }

	  pub fn SetHotTrackColor(&self, aValue: TColor)  {
          method_Call_1!(TreeView_SetHotTrackColor, self.0, aValue);
      }

	  pub fn ImagesWidth(&self) -> i32  {
          return method_Call_1!(TreeView_GetImagesWidth, self.0);
      }

	  pub fn SetImagesWidth(&self, aValue: i32)  {
          method_Call_1!(TreeView_SetImagesWidth, self.0, aValue);
      }

	  pub fn Options(&self) -> TTreeViewOptions  {
          return method_Call_1!(TreeView_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TTreeViewOptions)  {
          method_Call_1!(TreeView_SetOptions, self.0, aValue);
      }

	  pub fn ScrollBars(&self) -> TScrollStyle  {
          return method_Call_1!(TreeView_GetScrollBars, self.0);
      }

	  pub fn SetScrollBars(&self, aValue: TScrollStyle)  {
          method_Call_1!(TreeView_SetScrollBars, self.0, aValue);
      }

	  pub fn SelectionColor(&self) -> TColor  {
          return method_Call_1!(TreeView_GetSelectionColor, self.0);
      }

	  pub fn SetSelectionColor(&self, aValue: TColor)  {
          method_Call_1!(TreeView_SetSelectionColor, self.0, aValue);
      }

	  pub fn SelectionFontColor(&self) -> TColor  {
          return method_Call_1!(TreeView_GetSelectionFontColor, self.0);
      }

	  pub fn SetSelectionFontColor(&self, aValue: TColor)  {
          method_Call_1!(TreeView_SetSelectionFontColor, self.0, aValue);
      }

	  pub fn SelectionFontColorUsed(&self) -> bool  {
          return method_Call_1!(TreeView_GetSelectionFontColorUsed, self.0);
      }

	  pub fn SetSelectionFontColorUsed(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetSelectionFontColorUsed, self.0, aValue);
      }

	  pub fn SeparatorColor(&self) -> TColor  {
          return method_Call_1!(TreeView_GetSeparatorColor, self.0);
      }

	  pub fn SetSeparatorColor(&self, aValue: TColor)  {
          method_Call_1!(TreeView_SetSeparatorColor, self.0, aValue);
      }

	  pub fn StateImagesWidth(&self) -> i32  {
          return method_Call_1!(TreeView_GetStateImagesWidth, self.0);
      }

	  pub fn SetStateImagesWidth(&self, aValue: i32)  {
          method_Call_1!(TreeView_SetStateImagesWidth, self.0, aValue);
      }

	  pub fn ToolTips(&self) -> bool  {
          return method_Call_1!(TreeView_GetToolTips, self.0);
      }

	  pub fn SetToolTips(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetToolTips, self.0, aValue);
      }

	  pub fn TreeLineColor(&self) -> TColor  {
          return method_Call_1!(TreeView_GetTreeLineColor, self.0);
      }

	  pub fn SetTreeLineColor(&self, aValue: TColor)  {
          method_Call_1!(TreeView_SetTreeLineColor, self.0, aValue);
      }

	  pub fn TreeLinePenStyle(&self) -> TPenStyle  {
          return method_Call_1!(TreeView_GetTreeLinePenStyle, self.0);
      }

	  pub fn SetTreeLinePenStyle(&self, aValue: TPenStyle)  {
          method_Call_1!(TreeView_SetTreeLinePenStyle, self.0, aValue);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(TreeView_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(TreeView_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(TreeView_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(TreeView_SetAnchors, self.0, aValue);
      }

	  pub fn AutoExpand(&self) -> bool  {
          return method_Call_1!(TreeView_GetAutoExpand, self.0);
      }

	  pub fn SetAutoExpand(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetAutoExpand, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(TreeView_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(TreeView_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(TreeView_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(TreeView_SetBorderStyle, self.0, aValue);
      }

	  pub fn BorderWidth(&self) -> i32  {
          return method_Call_1!(TreeView_GetBorderWidth, self.0);
      }

	  pub fn SetBorderWidth(&self, aValue: i32)  {
          method_Call_1!(TreeView_SetBorderWidth, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(TreeView_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(TreeView_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, TreeView_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(TreeView_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(TreeView_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(TreeView_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(TreeView_SetDragKind, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(TreeView_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(TreeView_SetDragCursor, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(TreeView_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(TreeView_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(TreeView_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, TreeView_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(TreeView_SetFont, self.0, aValue.Instance());
      }

	  pub fn HideSelection(&self) -> bool  {
          return method_Call_1!(TreeView_GetHideSelection, self.0);
      }

	  pub fn SetHideSelection(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetHideSelection, self.0, aValue);
      }

	  pub fn HotTrack(&self) -> bool  {
          return method_Call_1!(TreeView_GetHotTrack, self.0);
      }

	  pub fn SetHotTrack(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetHotTrack, self.0, aValue);
      }

	  pub fn Images(&self) -> TImageList  {
          return method_Call_2!(TImageList, TreeView_GetImages, self.0);
      }

	  pub fn SetImages(&self, aValue: &TImageList)  {
          method_Call_1!(TreeView_SetImages, self.0, aValue.Instance());
      }

	  pub fn Indent(&self) -> i32  {
          return method_Call_1!(TreeView_GetIndent, self.0);
      }

	  pub fn SetIndent(&self, aValue: i32)  {
          method_Call_1!(TreeView_SetIndent, self.0, aValue);
      }

	  pub fn MultiSelect(&self) -> bool  {
          return method_Call_1!(TreeView_GetMultiSelect, self.0);
      }

	  pub fn SetMultiSelect(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetMultiSelect, self.0, aValue);
      }

	  pub fn MultiSelectStyle(&self) -> TMultiSelectStyle  {
          return method_Call_1!(TreeView_GetMultiSelectStyle, self.0);
      }

	  pub fn SetMultiSelectStyle(&self, aValue: TMultiSelectStyle)  {
          method_Call_1!(TreeView_SetMultiSelectStyle, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(TreeView_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(TreeView_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(TreeView_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(TreeView_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, TreeView_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(TreeView_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ReadOnly(&self) -> bool  {
          return method_Call_1!(TreeView_GetReadOnly, self.0);
      }

	  pub fn SetReadOnly(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetReadOnly, self.0, aValue);
      }

	  pub fn RightClickSelect(&self) -> bool  {
          return method_Call_1!(TreeView_GetRightClickSelect, self.0);
      }

	  pub fn SetRightClickSelect(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetRightClickSelect, self.0, aValue);
      }

	  pub fn RowSelect(&self) -> bool  {
          return method_Call_1!(TreeView_GetRowSelect, self.0);
      }

	  pub fn SetRowSelect(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetRowSelect, self.0, aValue);
      }

	  pub fn ShowButtons(&self) -> bool  {
          return method_Call_1!(TreeView_GetShowButtons, self.0);
      }

	  pub fn SetShowButtons(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetShowButtons, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(TreeView_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetShowHint, self.0, aValue);
      }

	  pub fn ShowLines(&self) -> bool  {
          return method_Call_1!(TreeView_GetShowLines, self.0);
      }

	  pub fn SetShowLines(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetShowLines, self.0, aValue);
      }

	  pub fn ShowRoot(&self) -> bool  {
          return method_Call_1!(TreeView_GetShowRoot, self.0);
      }

	  pub fn SetShowRoot(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetShowRoot, self.0, aValue);
      }

	  pub fn SortType(&self) -> TSortType  {
          return method_Call_1!(TreeView_GetSortType, self.0);
      }

	  pub fn SetSortType(&self, aValue: TSortType)  {
          method_Call_1!(TreeView_SetSortType, self.0, aValue);
      }

	  pub fn StateImages(&self) -> TImageList  {
          return method_Call_2!(TImageList, TreeView_GetStateImages, self.0);
      }

	  pub fn SetStateImages(&self, aValue: &TImageList)  {
          method_Call_1!(TreeView_SetStateImages, self.0, aValue.Instance());
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(TreeView_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(TreeView_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(TreeView_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(TreeView_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetVisible, self.0, aValue);
      }

	  pub fn SetOnAddition(&self, aEventId: TTVExpandedEvent)  {
          method_Call_1!(TreeView_SetOnAddition, self.0, aEventId);
      }

	  pub fn SetOnAdvancedCustomDraw(&self, aEventId: TTVAdvancedCustomDrawEvent)  {
          method_Call_1!(TreeView_SetOnAdvancedCustomDraw, self.0, aEventId);
      }

	  pub fn SetOnAdvancedCustomDrawItem(&self, aEventId: TTVAdvancedCustomDrawItemEvent)  {
          method_Call_1!(TreeView_SetOnAdvancedCustomDrawItem, self.0, aEventId);
      }

	  pub fn SetOnChange(&self, aEventId: TTVChangedEvent)  {
          method_Call_1!(TreeView_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnChanging(&self, aEventId: TTVChangingEvent)  {
          method_Call_1!(TreeView_SetOnChanging, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TreeView_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnCollapsed(&self, aEventId: TTVExpandedEvent)  {
          method_Call_1!(TreeView_SetOnCollapsed, self.0, aEventId);
      }

	  pub fn SetOnCollapsing(&self, aEventId: TTVCollapsingEvent)  {
          method_Call_1!(TreeView_SetOnCollapsing, self.0, aEventId);
      }

	  pub fn SetOnCompare(&self, aEventId: TTVCompareEvent)  {
          method_Call_1!(TreeView_SetOnCompare, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(TreeView_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnCustomDraw(&self, aEventId: TTVCustomDrawEvent)  {
          method_Call_1!(TreeView_SetOnCustomDraw, self.0, aEventId);
      }

	  pub fn SetOnCustomDrawItem(&self, aEventId: TTVCustomDrawItemEvent)  {
          method_Call_1!(TreeView_SetOnCustomDrawItem, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TreeView_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDeletion(&self, aEventId: TTVExpandedEvent)  {
          method_Call_1!(TreeView_SetOnDeletion, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(TreeView_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(TreeView_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEdited(&self, aEventId: TTVEditedEvent)  {
          method_Call_1!(TreeView_SetOnEdited, self.0, aEventId);
      }

	  pub fn SetOnEditing(&self, aEventId: TTVEditingEvent)  {
          method_Call_1!(TreeView_SetOnEditing, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(TreeView_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TreeView_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TreeView_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnExpanding(&self, aEventId: TTVExpandingEvent)  {
          method_Call_1!(TreeView_SetOnExpanding, self.0, aEventId);
      }

	  pub fn SetOnExpanded(&self, aEventId: TTVExpandedEvent)  {
          method_Call_1!(TreeView_SetOnExpanded, self.0, aEventId);
      }

	  pub fn SetOnGetSelectedIndex(&self, aEventId: TTVExpandedEvent)  {
          method_Call_1!(TreeView_SetOnGetSelectedIndex, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(TreeView_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(TreeView_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(TreeView_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(TreeView_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TreeView_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TreeView_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(TreeView_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(TreeView_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn Items(&self) -> TTreeNodes  {
          return method_Call_2!(TTreeNodes, TreeView_GetItems, self.0);
      }

	  pub fn SetItems(&self, aValue: &TTreeNodes)  {
          method_Call_1!(TreeView_SetItems, self.0, aValue.Instance());
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, TreeView_GetCanvas, self.0);
      }

	  pub fn DropTarget(&self) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeView_GetDropTarget, self.0);
      }

	  pub fn SetDropTarget(&self, aValue: &TTreeNode)  {
          method_Call_1!(TreeView_SetDropTarget, self.0, aValue.Instance());
      }

	  pub fn Selected(&self) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeView_GetSelected, self.0);
      }

	  pub fn SetSelected(&self, aValue: &TTreeNode)  {
          method_Call_1!(TreeView_SetSelected, self.0, aValue.Instance());
      }

	  pub fn TopItem(&self) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeView_GetTopItem, self.0);
      }

	  pub fn SetTopItem(&self, aValue: &TTreeNode)  {
          method_Call_1!(TreeView_SetTopItem, self.0, aValue.Instance());
      }

	  pub fn SelectionCount(&self) -> u32  {
          return method_Call_1!(TreeView_GetSelectionCount, self.0);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(TreeView_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(TreeView_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(TreeView_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(TreeView_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, TreeView_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(TreeView_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(TreeView_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(TreeView_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(TreeView_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(TreeView_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(TreeView_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(TreeView_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, TreeView_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(TreeView_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(TreeView_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(TreeView_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(TreeView_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(TreeView_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(TreeView_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(TreeView_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(TreeView_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(TreeView_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(TreeView_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(TreeView_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(TreeView_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(TreeView_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(TreeView_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, TreeView_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(TreeView_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(TreeView_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(TreeView_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(TreeView_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(TreeView_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(TreeView_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(TreeView_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(TreeView_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(TreeView_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(TreeView_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(TreeView_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TreeView_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(TreeView_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(TreeView_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(TreeView_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(TreeView_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, TreeView_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TreeView_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(TreeView_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(TreeView_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(TreeView_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, TreeView_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(TreeView_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, TreeView_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(TreeView_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, TreeView_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(TreeView_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, TreeView_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(TreeView_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, TreeView_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(TreeView_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, TreeView_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(TreeView_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Selections(&self, index: i32) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeView_GetSelections, self.0, index);
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, TreeView_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, TreeView_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, TreeView_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, TreeView_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(TreeView_StaticClassType);
}

impl_IObject!(TTreeView);
impl_IComponent!(TTreeView);
impl_IControl!(TTreeView);
impl_IWinControl!(TTreeView);

impl TStatusBar {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TStatusBar, StatusBar_Create, aOwner.Instance());
      }

      impl_As_method!(TStatusBar);

	  impl_Free_method!(StatusBar_Free);

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(StatusBar_FlipChildren, self.0, allLevels);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(StatusBar_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(StatusBar_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(StatusBar_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, StatusBar_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(StatusBar_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(StatusBar_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, StatusBar_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(StatusBar_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(StatusBar_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(StatusBar_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(StatusBar_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(StatusBar_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(StatusBar_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(StatusBar_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(StatusBar_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(StatusBar_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(StatusBar_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(StatusBar_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(StatusBar_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(StatusBar_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(StatusBar_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(StatusBar_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(StatusBar_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(StatusBar_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(StatusBar_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(StatusBar_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(StatusBar_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(StatusBar_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(StatusBar_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(StatusBar_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(StatusBar_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(StatusBar_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(StatusBar_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, StatusBar_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StatusBar_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(StatusBar_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(StatusBar_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StatusBar_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(StatusBar_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(StatusBar_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(StatusBar_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(StatusBar_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StatusBar_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(StatusBar_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(StatusBar_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(StatusBar_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(StatusBar_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(StatusBar_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(StatusBar_AnchorClient, self.0, aSpace);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, StatusBar_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(StatusBar_SetAction, self.0, aValue.Instance());
      }

	  pub fn AutoHint(&self) -> bool  {
          return method_Call_1!(StatusBar_GetAutoHint, self.0);
      }

	  pub fn SetAutoHint(&self, aValue: bool)  {
          method_Call_1!(StatusBar_SetAutoHint, self.0, aValue);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(StatusBar_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(StatusBar_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(StatusBar_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(StatusBar_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(StatusBar_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(StatusBar_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderWidth(&self) -> i32  {
          return method_Call_1!(StatusBar_GetBorderWidth, self.0);
      }

	  pub fn SetBorderWidth(&self, aValue: i32)  {
          method_Call_1!(StatusBar_SetBorderWidth, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(StatusBar_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(StatusBar_SetColor, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(StatusBar_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(StatusBar_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(StatusBar_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(StatusBar_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(StatusBar_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(StatusBar_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(StatusBar_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(StatusBar_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(StatusBar_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(StatusBar_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, StatusBar_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(StatusBar_SetFont, self.0, aValue.Instance());
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, StatusBar_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(StatusBar_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn Panels(&self) -> TStatusPanels  {
          return method_Call_2!(TStatusPanels, StatusBar_GetPanels, self.0);
      }

	  pub fn SetPanels(&self, aValue: &TStatusPanels)  {
          method_Call_1!(StatusBar_SetPanels, self.0, aValue.Instance());
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(StatusBar_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(StatusBar_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(StatusBar_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(StatusBar_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(StatusBar_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(StatusBar_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(StatusBar_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(StatusBar_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, StatusBar_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(StatusBar_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(StatusBar_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(StatusBar_SetShowHint, self.0, aValue);
      }

	  pub fn SimplePanel(&self) -> bool  {
          return method_Call_1!(StatusBar_GetSimplePanel, self.0);
      }

	  pub fn SetSimplePanel(&self, aValue: bool)  {
          method_Call_1!(StatusBar_SetSimplePanel, self.0, aValue);
      }

	  pub fn SimpleText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StatusBar_GetSimpleText, self.0));
      }

	  pub fn SetSimpleText(&self, aValue: &str)  {
          method_Call_1!(StatusBar_SetSimpleText, self.0, to_CString!(aValue));
      }

	  pub fn SizeGrip(&self) -> bool  {
          return method_Call_1!(StatusBar_GetSizeGrip, self.0);
      }

	  pub fn SetSizeGrip(&self, aValue: bool)  {
          method_Call_1!(StatusBar_SetSizeGrip, self.0, aValue);
      }

	  pub fn UseSystemFont(&self) -> bool  {
          return method_Call_1!(StatusBar_GetUseSystemFont, self.0);
      }

	  pub fn SetUseSystemFont(&self, aValue: bool)  {
          method_Call_1!(StatusBar_SetUseSystemFont, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(StatusBar_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(StatusBar_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StatusBar_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(StatusBar_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StatusBar_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(StatusBar_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(StatusBar_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(StatusBar_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(StatusBar_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnHint(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StatusBar_SetOnHint, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(StatusBar_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StatusBar_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StatusBar_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(StatusBar_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(StatusBar_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnResize(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StatusBar_SetOnResize, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(StatusBar_SetOnStartDock, self.0, aEventId);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, StatusBar_GetCanvas, self.0);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(StatusBar_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(StatusBar_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(StatusBar_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(StatusBar_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(StatusBar_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, StatusBar_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(StatusBar_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(StatusBar_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(StatusBar_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(StatusBar_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(StatusBar_GetShowing, self.0);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(StatusBar_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(StatusBar_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(StatusBar_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(StatusBar_SetTabStop, self.0, aValue);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(StatusBar_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(StatusBar_SetUseDockManager, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(StatusBar_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(StatusBar_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(StatusBar_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(StatusBar_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(StatusBar_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(StatusBar_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(StatusBar_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(StatusBar_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(StatusBar_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(StatusBar_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(StatusBar_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(StatusBar_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(StatusBar_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, StatusBar_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(StatusBar_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(StatusBar_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(StatusBar_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(StatusBar_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(StatusBar_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(StatusBar_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(StatusBar_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(StatusBar_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(StatusBar_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(StatusBar_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(StatusBar_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StatusBar_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(StatusBar_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(StatusBar_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(StatusBar_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(StatusBar_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, StatusBar_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StatusBar_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(StatusBar_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(StatusBar_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(StatusBar_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, StatusBar_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(StatusBar_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, StatusBar_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(StatusBar_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, StatusBar_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(StatusBar_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, StatusBar_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(StatusBar_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, StatusBar_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(StatusBar_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, StatusBar_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(StatusBar_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, StatusBar_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, StatusBar_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, StatusBar_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, StatusBar_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(StatusBar_StaticClassType);
}

impl_IObject!(TStatusBar);
impl_IComponent!(TStatusBar);
impl_IControl!(TStatusBar);
impl_IWinControl!(TStatusBar);

impl TToolBar {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TToolBar, ToolBar_Create, aOwner.Instance());
      }

      impl_As_method!(TToolBar);

	  impl_Free_method!(ToolBar_Free);

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(ToolBar_FlipChildren, self.0, allLevels);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(ToolBar_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(ToolBar_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, ToolBar_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(ToolBar_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(ToolBar_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, ToolBar_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(ToolBar_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(ToolBar_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ToolBar_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(ToolBar_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ToolBar_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(ToolBar_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(ToolBar_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(ToolBar_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(ToolBar_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(ToolBar_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(ToolBar_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(ToolBar_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(ToolBar_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ToolBar_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ToolBar_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(ToolBar_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ToolBar_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(ToolBar_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(ToolBar_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(ToolBar_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ToolBar_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ToolBar_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(ToolBar_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(ToolBar_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(ToolBar_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(ToolBar_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(ToolBar_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ToolBar_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ToolBar_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ToolBar_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ToolBar_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ToolBar_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ToolBar_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ToolBar_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ToolBar_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ToolBar_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ToolBar_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ToolBar_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ToolBar_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ToolBar_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ToolBar_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(ToolBar_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(ToolBar_AnchorClient, self.0, aSpace);
      }

	  pub fn ButtonCount(&self) -> i32  {
          return method_Call_1!(ToolBar_GetButtonCount, self.0);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, ToolBar_GetCanvas, self.0);
      }

	  pub fn RowCount(&self) -> i32  {
          return method_Call_1!(ToolBar_GetRowCount, self.0);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(ToolBar_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(ToolBar_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(ToolBar_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(ToolBar_SetAnchors, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(ToolBar_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetAutoSize, self.0, aValue);
      }

	  pub fn BorderWidth(&self) -> i32  {
          return method_Call_1!(ToolBar_GetBorderWidth, self.0);
      }

	  pub fn SetBorderWidth(&self, aValue: i32)  {
          method_Call_1!(ToolBar_SetBorderWidth, self.0, aValue);
      }

	  pub fn ButtonHeight(&self) -> i32  {
          return method_Call_1!(ToolBar_GetButtonHeight, self.0);
      }

	  pub fn SetButtonHeight(&self, aValue: i32)  {
          method_Call_1!(ToolBar_SetButtonHeight, self.0, aValue);
      }

	  pub fn ButtonWidth(&self) -> i32  {
          return method_Call_1!(ToolBar_GetButtonWidth, self.0);
      }

	  pub fn SetButtonWidth(&self, aValue: i32)  {
          method_Call_1!(ToolBar_SetButtonWidth, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ToolBar_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(ToolBar_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(ToolBar_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(ToolBar_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, ToolBar_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(ToolBar_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(ToolBar_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(ToolBar_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetDockSite, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(ToolBar_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(ToolBar_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(ToolBar_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(ToolBar_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(ToolBar_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(ToolBar_SetDragMode, self.0, aValue);
      }

	  pub fn EdgeBorders(&self) -> TEdgeBorders  {
          return method_Call_1!(ToolBar_GetEdgeBorders, self.0);
      }

	  pub fn SetEdgeBorders(&self, aValue: TEdgeBorders)  {
          method_Call_1!(ToolBar_SetEdgeBorders, self.0, aValue);
      }

	  pub fn EdgeInner(&self) -> TEdgeStyle  {
          return method_Call_1!(ToolBar_GetEdgeInner, self.0);
      }

	  pub fn SetEdgeInner(&self, aValue: TEdgeStyle)  {
          method_Call_1!(ToolBar_SetEdgeInner, self.0, aValue);
      }

	  pub fn EdgeOuter(&self) -> TEdgeStyle  {
          return method_Call_1!(ToolBar_GetEdgeOuter, self.0);
      }

	  pub fn SetEdgeOuter(&self, aValue: TEdgeStyle)  {
          method_Call_1!(ToolBar_SetEdgeOuter, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(ToolBar_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetEnabled, self.0, aValue);
      }

	  pub fn Flat(&self) -> bool  {
          return method_Call_1!(ToolBar_GetFlat, self.0);
      }

	  pub fn SetFlat(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetFlat, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, ToolBar_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(ToolBar_SetFont, self.0, aValue.Instance());
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(ToolBar_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(ToolBar_SetHeight, self.0, aValue);
      }

	  pub fn HotImages(&self) -> TImageList  {
          return method_Call_2!(TImageList, ToolBar_GetHotImages, self.0);
      }

	  pub fn SetHotImages(&self, aValue: &TImageList)  {
          method_Call_1!(ToolBar_SetHotImages, self.0, aValue.Instance());
      }

	  pub fn Images(&self) -> TImageList  {
          return method_Call_2!(TImageList, ToolBar_GetImages, self.0);
      }

	  pub fn SetImages(&self, aValue: &TImageList)  {
          method_Call_1!(ToolBar_SetImages, self.0, aValue.Instance());
      }

	  pub fn Indent(&self) -> i32  {
          return method_Call_1!(ToolBar_GetIndent, self.0);
      }

	  pub fn SetIndent(&self, aValue: i32)  {
          method_Call_1!(ToolBar_SetIndent, self.0, aValue);
      }

	  pub fn List(&self) -> bool  {
          return method_Call_1!(ToolBar_GetList, self.0);
      }

	  pub fn SetList(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetList, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(ToolBar_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(ToolBar_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(ToolBar_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(ToolBar_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, ToolBar_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(ToolBar_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowCaptions(&self) -> bool  {
          return method_Call_1!(ToolBar_GetShowCaptions, self.0);
      }

	  pub fn SetShowCaptions(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetShowCaptions, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(ToolBar_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(ToolBar_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(ToolBar_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(ToolBar_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetTabStop, self.0, aValue);
      }

	  pub fn Transparent(&self) -> bool  {
          return method_Call_1!(ToolBar_GetTransparent, self.0);
      }

	  pub fn SetTransparent(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetTransparent, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(ToolBar_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetVisible, self.0, aValue);
      }

	  pub fn Wrapable(&self) -> bool  {
          return method_Call_1!(ToolBar_GetWrapable, self.0);
      }

	  pub fn SetWrapable(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetWrapable, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToolBar_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(ToolBar_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToolBar_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDockDrop(&self, aEventId: TDockDropEvent)  {
          method_Call_1!(ToolBar_SetOnDockDrop, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(ToolBar_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(ToolBar_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ToolBar_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToolBar_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToolBar_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ToolBar_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToolBar_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToolBar_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(ToolBar_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ToolBar_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnResize(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToolBar_SetOnResize, self.0, aEventId);
      }

	  pub fn SetOnUnDock(&self, aEventId: TUnDockEvent)  {
          method_Call_1!(ToolBar_SetOnUnDock, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(ToolBar_GetDockClientCount, self.0);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(ToolBar_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(ToolBar_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, ToolBar_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(ToolBar_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(ToolBar_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(ToolBar_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(ToolBar_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(ToolBar_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(ToolBar_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(ToolBar_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, ToolBar_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(ToolBar_SetAction, self.0, aValue.Instance());
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(ToolBar_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(ToolBar_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ToolBar_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(ToolBar_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(ToolBar_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(ToolBar_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ToolBar_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ToolBar_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(ToolBar_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(ToolBar_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(ToolBar_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(ToolBar_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(ToolBar_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(ToolBar_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(ToolBar_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, ToolBar_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(ToolBar_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ToolBar_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ToolBar_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ToolBar_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ToolBar_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ToolBar_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ToolBar_SetWidth, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(ToolBar_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(ToolBar_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ToolBar_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(ToolBar_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ToolBar_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ToolBar_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ToolBar_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ToolBar_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ToolBar_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ToolBar_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ToolBar_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ToolBar_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ToolBar_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ToolBar_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ToolBar_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ToolBar_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ToolBar_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ToolBar_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ToolBar_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ToolBar_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, ToolBar_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(ToolBar_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, ToolBar_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(ToolBar_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Buttons(&self, index: i32) -> TToolButton  {
          return method_Call_2!(TToolButton, ToolBar_GetButtons, self.0, index);
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ToolBar_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ToolBar_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ToolBar_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ToolBar_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(ToolBar_StaticClassType);
}

impl_IObject!(TToolBar);
impl_IComponent!(TToolBar);
impl_IControl!(TToolBar);
impl_IWinControl!(TToolBar);

impl TBitBtn {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TBitBtn, BitBtn_Create, aOwner.Instance());
      }

      impl_As_method!(TBitBtn);

	  impl_Free_method!(BitBtn_Free);

	  pub fn Click(&self)  {
          method_Call_1!(BitBtn_Click, self.0);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(BitBtn_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(BitBtn_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, BitBtn_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(BitBtn_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(BitBtn_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, BitBtn_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(BitBtn_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(BitBtn_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(BitBtn_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(BitBtn_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(BitBtn_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(BitBtn_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(BitBtn_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(BitBtn_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(BitBtn_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(BitBtn_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(BitBtn_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(BitBtn_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(BitBtn_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(BitBtn_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(BitBtn_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(BitBtn_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(BitBtn_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(BitBtn_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(BitBtn_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(BitBtn_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(BitBtn_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(BitBtn_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(BitBtn_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(BitBtn_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(BitBtn_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(BitBtn_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(BitBtn_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(BitBtn_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, BitBtn_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(BitBtn_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(BitBtn_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(BitBtn_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(BitBtn_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(BitBtn_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(BitBtn_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(BitBtn_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(BitBtn_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(BitBtn_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(BitBtn_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(BitBtn_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(BitBtn_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(BitBtn_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(BitBtn_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(BitBtn_AnchorClient, self.0, aSpace);
      }

	  pub fn DefaultCaption(&self) -> bool  {
          return method_Call_1!(BitBtn_GetDefaultCaption, self.0);
      }

	  pub fn SetDefaultCaption(&self, aValue: bool)  {
          method_Call_1!(BitBtn_SetDefaultCaption, self.0, aValue);
      }

	  pub fn GlyphShowMode(&self) -> TGlyphShowMode  {
          return method_Call_1!(BitBtn_GetGlyphShowMode, self.0);
      }

	  pub fn SetGlyphShowMode(&self, aValue: TGlyphShowMode)  {
          method_Call_1!(BitBtn_SetGlyphShowMode, self.0, aValue);
      }

	  pub fn ImageWidth(&self) -> i32  {
          return method_Call_1!(BitBtn_GetImageWidth, self.0);
      }

	  pub fn SetImageWidth(&self, aValue: i32)  {
          method_Call_1!(BitBtn_SetImageWidth, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, BitBtn_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(BitBtn_SetAction, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(BitBtn_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(BitBtn_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(BitBtn_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(BitBtn_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(BitBtn_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(BitBtn_SetBiDiMode, self.0, aValue);
      }

	  pub fn Cancel(&self) -> bool  {
          return method_Call_1!(BitBtn_GetCancel, self.0);
      }

	  pub fn SetCancel(&self, aValue: bool)  {
          method_Call_1!(BitBtn_SetCancel, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(BitBtn_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(BitBtn_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, BitBtn_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(BitBtn_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn Default(&self) -> bool  {
          return method_Call_1!(BitBtn_GetDefault, self.0);
      }

	  pub fn SetDefault(&self, aValue: bool)  {
          method_Call_1!(BitBtn_SetDefault, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(BitBtn_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(BitBtn_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(BitBtn_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(BitBtn_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, BitBtn_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(BitBtn_SetFont, self.0, aValue.Instance());
      }

	  pub fn Glyph(&self) -> TBitmap  {
          return method_Call_2!(TBitmap, BitBtn_GetGlyph, self.0);
      }

	  pub fn SetGlyph(&self, aValue: &TBitmap)  {
          method_Call_1!(BitBtn_SetGlyph, self.0, aValue.Instance());
      }

	  pub fn Layout(&self) -> TButtonLayout  {
          return method_Call_1!(BitBtn_GetLayout, self.0);
      }

	  pub fn SetLayout(&self, aValue: TButtonLayout)  {
          method_Call_1!(BitBtn_SetLayout, self.0, aValue);
      }

	  pub fn ModalResult(&self) -> TModalResult  {
          return method_Call_1!(BitBtn_GetModalResult, self.0);
      }

	  pub fn SetModalResult(&self, aValue: TModalResult)  {
          method_Call_1!(BitBtn_SetModalResult, self.0, aValue);
      }

	  pub fn NumGlyphs(&self) -> TNumGlyphs  {
          return method_Call_1!(BitBtn_GetNumGlyphs, self.0);
      }

	  pub fn SetNumGlyphs(&self, aValue: TNumGlyphs)  {
          method_Call_1!(BitBtn_SetNumGlyphs, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(BitBtn_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(BitBtn_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(BitBtn_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(BitBtn_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(BitBtn_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(BitBtn_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, BitBtn_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(BitBtn_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(BitBtn_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(BitBtn_SetShowHint, self.0, aValue);
      }

	  pub fn Spacing(&self) -> i32  {
          return method_Call_1!(BitBtn_GetSpacing, self.0);
      }

	  pub fn SetSpacing(&self, aValue: i32)  {
          method_Call_1!(BitBtn_SetSpacing, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(BitBtn_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(BitBtn_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(BitBtn_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(BitBtn_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(BitBtn_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(BitBtn_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(BitBtn_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(BitBtn_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(BitBtn_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(BitBtn_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(BitBtn_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(BitBtn_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(BitBtn_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(BitBtn_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(BitBtn_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(BitBtn_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(BitBtn_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(BitBtn_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(BitBtn_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(BitBtn_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(BitBtn_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(BitBtn_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(BitBtn_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(BitBtn_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(BitBtn_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(BitBtn_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, BitBtn_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(BitBtn_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(BitBtn_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(BitBtn_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(BitBtn_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(BitBtn_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(BitBtn_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(BitBtn_SetUseDockManager, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(BitBtn_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(BitBtn_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(BitBtn_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(BitBtn_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(BitBtn_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(BitBtn_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(BitBtn_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(BitBtn_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(BitBtn_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(BitBtn_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(BitBtn_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(BitBtn_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(BitBtn_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, BitBtn_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(BitBtn_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(BitBtn_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(BitBtn_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(BitBtn_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(BitBtn_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(BitBtn_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(BitBtn_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(BitBtn_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(BitBtn_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(BitBtn_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(BitBtn_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(BitBtn_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(BitBtn_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(BitBtn_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(BitBtn_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(BitBtn_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, BitBtn_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(BitBtn_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(BitBtn_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(BitBtn_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(BitBtn_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, BitBtn_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(BitBtn_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, BitBtn_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(BitBtn_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, BitBtn_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(BitBtn_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, BitBtn_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(BitBtn_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, BitBtn_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(BitBtn_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, BitBtn_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(BitBtn_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, BitBtn_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, BitBtn_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, BitBtn_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, BitBtn_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(BitBtn_StaticClassType);
}

impl_IObject!(TBitBtn);
impl_IComponent!(TBitBtn);
impl_IControl!(TBitBtn);
impl_IWinControl!(TBitBtn);

impl TIcon {
      pub fn new() -> Self {
        method_Create!(TIcon, Icon_Create, );
      }

      impl_As_method!(TIcon);

	  impl_Free_method!(Icon_Free);

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(Icon_Assign, self.0, source.Instance());
      }

	  pub fn HandleAllocated(&self) -> bool  {
          return method_Call_1!(Icon_HandleAllocated, self.0);
      }

	  pub fn LoadFromStream(&self, stream: &dyn IObject)  {
          method_Call_1!(Icon_LoadFromStream, self.0, stream.Instance());
      }

	  pub fn SaveToStream(&self, stream: &dyn IObject)  {
          method_Call_1!(Icon_SaveToStream, self.0, stream.Instance());
      }

	  pub fn SetSize(&self, aWidth: i32, aHeight: i32)  {
          method_Call_1!(Icon_SetSize, self.0, aWidth, aHeight);
      }

	  pub fn LoadFromResourceName(&self, instance: usize, resName: &str)  {
          method_Call_1!(Icon_LoadFromResourceName, self.0, instance, to_CString!(resName));
      }

	  pub fn LoadFromResourceID(&self, instance: usize, resID: i32)  {
          method_Call_1!(Icon_LoadFromResourceID, self.0, instance, resID);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Icon_Equals, self.0, obj.Instance());
      }

	  pub fn LoadFromFile(&self, filename: &str)  {
          method_Call_1!(Icon_LoadFromFile, self.0, to_CString!(filename));
      }

	  pub fn SaveToFile(&self, filename: &str)  {
          method_Call_1!(Icon_SaveToFile, self.0, to_CString!(filename));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Icon_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Icon_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Icon_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Icon_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Icon_InheritsFrom, self.0, aClass);
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Icon_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Icon_ToString, self.0));
      }

	  pub fn Handle(&self) -> HICON  {
          return method_Call_1!(Icon_GetHandle, self.0);
      }

	  pub fn SetHandle(&self, aValue: HICON)  {
          method_Call_1!(Icon_SetHandle, self.0, aValue);
      }

	  pub fn Empty(&self) -> bool  {
          return method_Call_1!(Icon_GetEmpty, self.0);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Icon_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Icon_SetHeight, self.0, aValue);
      }

	  pub fn Modified(&self) -> bool  {
          return method_Call_1!(Icon_GetModified, self.0);
      }

	  pub fn SetModified(&self, aValue: bool)  {
          method_Call_1!(Icon_SetModified, self.0, aValue);
      }

	  pub fn Palette(&self) -> HPALETTE  {
          return method_Call_1!(Icon_GetPalette, self.0);
      }

	  pub fn SetPalette(&self, aValue: HPALETTE)  {
          method_Call_1!(Icon_SetPalette, self.0, aValue);
      }

	  pub fn PaletteModified(&self) -> bool  {
          return method_Call_1!(Icon_GetPaletteModified, self.0);
      }

	  pub fn SetPaletteModified(&self, aValue: bool)  {
          method_Call_1!(Icon_SetPaletteModified, self.0, aValue);
      }

	  pub fn Transparent(&self) -> bool  {
          return method_Call_1!(Icon_GetTransparent, self.0);
      }

	  pub fn SetTransparent(&self, aValue: bool)  {
          method_Call_1!(Icon_SetTransparent, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Icon_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Icon_SetWidth, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Icon_SetOnChange, self.0, aEventId);
      }

      // static class
	  impl_Class_method!(Icon_StaticClassType);
}

impl_IObject!(TIcon);
impl_Drop_method!(TIcon);

impl TBitmap {
      pub fn new() -> Self {
        method_Create!(TBitmap, Bitmap_Create, );
      }

      impl_As_method!(TBitmap);

	  impl_Free_method!(Bitmap_Free);

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(Bitmap_Assign, self.0, source.Instance());
      }

	  pub fn FreeImage(&self)  {
          method_Call_1!(Bitmap_FreeImage, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool  {
          return method_Call_1!(Bitmap_HandleAllocated, self.0);
      }

	  pub fn LoadFromStream(&self, stream: &dyn IObject)  {
          method_Call_1!(Bitmap_LoadFromStream, self.0, stream.Instance());
      }

	  pub fn SaveToStream(&self, stream: &dyn IObject)  {
          method_Call_1!(Bitmap_SaveToStream, self.0, stream.Instance());
      }

	  pub fn SetSize(&self, aWidth: i32, aHeight: i32)  {
          method_Call_1!(Bitmap_SetSize, self.0, aWidth, aHeight);
      }

	  pub fn LoadFromResourceName(&self, instance: usize, resName: &str)  {
          method_Call_1!(Bitmap_LoadFromResourceName, self.0, instance, to_CString!(resName));
      }

	  pub fn LoadFromResourceID(&self, instance: usize, resID: i32)  {
          method_Call_1!(Bitmap_LoadFromResourceID, self.0, instance, resID);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Bitmap_Equals, self.0, obj.Instance());
      }

	  pub fn LoadFromFile(&self, filename: &str)  {
          method_Call_1!(Bitmap_LoadFromFile, self.0, to_CString!(filename));
      }

	  pub fn SaveToFile(&self, filename: &str)  {
          method_Call_1!(Bitmap_SaveToFile, self.0, to_CString!(filename));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Bitmap_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Bitmap_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Bitmap_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Bitmap_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Bitmap_InheritsFrom, self.0, aClass);
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Bitmap_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Bitmap_ToString, self.0));
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, Bitmap_GetCanvas, self.0);
      }

	  pub fn Handle(&self) -> HBITMAP  {
          return method_Call_1!(Bitmap_GetHandle, self.0);
      }

	  pub fn SetHandle(&self, aValue: HBITMAP)  {
          method_Call_1!(Bitmap_SetHandle, self.0, aValue);
      }

	  pub fn HandleType(&self) -> TBitmapHandleType  {
          return method_Call_1!(Bitmap_GetHandleType, self.0);
      }

	  pub fn SetHandleType(&self, aValue: TBitmapHandleType)  {
          method_Call_1!(Bitmap_SetHandleType, self.0, aValue);
      }

	  pub fn MaskHandle(&self) -> HBITMAP  {
          return method_Call_1!(Bitmap_GetMaskHandle, self.0);
      }

	  pub fn SetMaskHandle(&self, aValue: HBITMAP)  {
          method_Call_1!(Bitmap_SetMaskHandle, self.0, aValue);
      }

	  pub fn PixelFormat(&self) -> TPixelFormat  {
          return method_Call_1!(Bitmap_GetPixelFormat, self.0);
      }

	  pub fn SetPixelFormat(&self, aValue: TPixelFormat)  {
          method_Call_1!(Bitmap_SetPixelFormat, self.0, aValue);
      }

	  pub fn TransparentMode(&self) -> TTransparentMode  {
          return method_Call_1!(Bitmap_GetTransparentMode, self.0);
      }

	  pub fn SetTransparentMode(&self, aValue: TTransparentMode)  {
          method_Call_1!(Bitmap_SetTransparentMode, self.0, aValue);
      }

	  pub fn Empty(&self) -> bool  {
          return method_Call_1!(Bitmap_GetEmpty, self.0);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Bitmap_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Bitmap_SetHeight, self.0, aValue);
      }

	  pub fn Modified(&self) -> bool  {
          return method_Call_1!(Bitmap_GetModified, self.0);
      }

	  pub fn SetModified(&self, aValue: bool)  {
          method_Call_1!(Bitmap_SetModified, self.0, aValue);
      }

	  pub fn Palette(&self) -> HPALETTE  {
          return method_Call_1!(Bitmap_GetPalette, self.0);
      }

	  pub fn SetPalette(&self, aValue: HPALETTE)  {
          method_Call_1!(Bitmap_SetPalette, self.0, aValue);
      }

	  pub fn PaletteModified(&self) -> bool  {
          return method_Call_1!(Bitmap_GetPaletteModified, self.0);
      }

	  pub fn SetPaletteModified(&self, aValue: bool)  {
          method_Call_1!(Bitmap_SetPaletteModified, self.0, aValue);
      }

	  pub fn Transparent(&self) -> bool  {
          return method_Call_1!(Bitmap_GetTransparent, self.0);
      }

	  pub fn SetTransparent(&self, aValue: bool)  {
          method_Call_1!(Bitmap_SetTransparent, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Bitmap_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Bitmap_SetWidth, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Bitmap_SetOnChange, self.0, aEventId);
      }

	  pub fn ScanLine(&self, row: i32) -> usize  {
          return method_Call_1!(Bitmap_GetScanLine, self.0, row);
      }

      // static class
	  impl_Class_method!(Bitmap_StaticClassType);
	  pub fn Clear(&self)  {
          method_Call_1!(Bitmap_Clear, self.0);
      }

	  pub fn BeginUpdate(&self, aCanvasOnly: bool)  {
          method_Call_1!(Bitmap_BeginUpdate, self.0, aCanvasOnly);
      }

	  pub fn EndUpdate(&self, aStreamIsValid: bool)  {
          method_Call_1!(Bitmap_EndUpdate, self.0, aStreamIsValid);
      }

	  pub fn LoadFromDevice(&self, aDc: HDC)  {
          method_Call_1!(Bitmap_LoadFromDevice, self.0, aDc);
      }

}

impl_IObject!(TBitmap);
impl_Drop_method!(TBitmap);

impl TMemoryStream {
      pub fn new() -> Self {
        method_Create!(TMemoryStream, MemoryStream_Create, );
      }

      impl_As_method!(TMemoryStream);

	  impl_Free_method!(MemoryStream_Free);

	  pub fn Clear(&self)  {
          method_Call_1!(MemoryStream_Clear, self.0);
      }

	  pub fn LoadFromStream(&self, stream: &dyn IObject)  {
          method_Call_1!(MemoryStream_LoadFromStream, self.0, stream.Instance());
      }

	  pub fn LoadFromFile(&self, fileName: &str)  {
          method_Call_1!(MemoryStream_LoadFromFile, self.0, to_CString!(fileName));
      }

	  pub fn Seek(&self, offset: i64, origin: TSeekOrigin) -> i64  {
          let mut result = 0 as i64;
          let mut ps1 = offset;
          method_Call_1!(MemoryStream_Seek, self.0, &mut ps1, origin, &mut result);
          return result;
      }

	  pub fn SaveToStream(&self, stream: &dyn IObject)  {
          method_Call_1!(MemoryStream_SaveToStream, self.0, stream.Instance());
      }

	  pub fn SaveToFile(&self, fileName: &str)  {
          method_Call_1!(MemoryStream_SaveToFile, self.0, to_CString!(fileName));
      }

	  pub fn CopyFrom(&self, source: &dyn IObject, count: i64) -> i64  {
          let mut result = 0 as i64;
          let mut ps2 = count;
          method_Call_1!(MemoryStream_CopyFrom, self.0, source.Instance(), &mut ps2, &mut result);
          return result;
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(MemoryStream_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MemoryStream_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(MemoryStream_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(MemoryStream_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(MemoryStream_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(MemoryStream_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MemoryStream_ToString, self.0));
      }

	  pub fn Memory(&self) -> usize  {
          return method_Call_1!(MemoryStream_GetMemory, self.0);
      }

	  pub fn Position(&self) -> i64  {
          let mut result = 0 as i64;
          method_Call_1!(MemoryStream_GetPosition, self.0, &mut result);
          return result;
      }

	  pub fn SetPosition(&self, aValue: *mut i64)  {
          method_Call_1!(MemoryStream_SetPosition, self.0, aValue);
      }

	  pub fn Size(&self) -> i64  {
          let mut result = 0 as i64;
          method_Call_1!(MemoryStream_GetSize, self.0, &mut result);
          return result;
      }

	  pub fn SetSize(&self, aValue: *mut i64)  {
          method_Call_1!(MemoryStream_SetSize, self.0, aValue);
      }

      // static class
	  impl_Class_method!(MemoryStream_StaticClassType);
	  pub fn Write(&self, buffer: usize, count: i32) -> i32  {
          return method_Call_1!(MemoryStream_Write, self.0, buffer, count);
      }

	  pub fn Read(&self, buffer: usize, count: i32) -> i32  {
          return method_Call_1!(MemoryStream_Read, self.0, buffer, count);
      }

}

impl_IObject!(TMemoryStream);
impl_Drop_method!(TMemoryStream);

impl TFont {
      pub fn new() -> Self {
        method_Create!(TFont, Font_Create, );
      }

      impl_As_method!(TFont);

	  impl_Free_method!(Font_Free);

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(Font_Assign, self.0, source.Instance());
      }

	  pub fn HandleAllocated(&self) -> bool  {
          return method_Call_1!(Font_HandleAllocated, self.0);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Font_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Font_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Font_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Font_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Font_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Font_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Font_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Font_ToString, self.0));
      }

	  pub fn Handle(&self) -> HFONT  {
          return method_Call_1!(Font_GetHandle, self.0);
      }

	  pub fn SetHandle(&self, aValue: HFONT)  {
          method_Call_1!(Font_SetHandle, self.0, aValue);
      }

	  pub fn PixelsPerInch(&self) -> i32  {
          return method_Call_1!(Font_GetPixelsPerInch, self.0);
      }

	  pub fn SetPixelsPerInch(&self, aValue: i32)  {
          method_Call_1!(Font_SetPixelsPerInch, self.0, aValue);
      }

	  pub fn Charset(&self) -> TFontCharset  {
          return method_Call_1!(Font_GetCharset, self.0);
      }

	  pub fn SetCharset(&self, aValue: TFontCharset)  {
          method_Call_1!(Font_SetCharset, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(Font_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(Font_SetColor, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Font_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Font_SetHeight, self.0, aValue);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Font_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Font_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Orientation(&self) -> i32  {
          return method_Call_1!(Font_GetOrientation, self.0);
      }

	  pub fn SetOrientation(&self, aValue: i32)  {
          method_Call_1!(Font_SetOrientation, self.0, aValue);
      }

	  pub fn Pitch(&self) -> TFontPitch  {
          return method_Call_1!(Font_GetPitch, self.0);
      }

	  pub fn SetPitch(&self, aValue: TFontPitch)  {
          method_Call_1!(Font_SetPitch, self.0, aValue);
      }

	  pub fn Size(&self) -> i32  {
          return method_Call_1!(Font_GetSize, self.0);
      }

	  pub fn SetSize(&self, aValue: i32)  {
          method_Call_1!(Font_SetSize, self.0, aValue);
      }

	  pub fn Style(&self) -> TFontStyles  {
          return method_Call_1!(Font_GetStyle, self.0);
      }

	  pub fn SetStyle(&self, aValue: TFontStyles)  {
          method_Call_1!(Font_SetStyle, self.0, aValue);
      }

	  pub fn Quality(&self) -> TFontQuality  {
          return method_Call_1!(Font_GetQuality, self.0);
      }

	  pub fn SetQuality(&self, aValue: TFontQuality)  {
          method_Call_1!(Font_SetQuality, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Font_SetOnChange, self.0, aEventId);
      }

      // static class
	  impl_Class_method!(Font_StaticClassType);
}

impl_IObject!(TFont);
impl_Drop_method!(TFont);

impl TStrings {
      pub fn new() -> Self {
        method_Create!(TStrings, Strings_Create, );
      }

      impl_As_method!(TStrings);

	  impl_Free_method!(Strings_Free);

	  pub fn Add(&self, s: &str) -> i32  {
          return method_Call_1!(Strings_Add, self.0, to_CString!(s));
      }

	  pub fn AddObject(&self, s: &str, aObject: &dyn IObject) -> i32  {
          return method_Call_1!(Strings_AddObject, self.0, to_CString!(s), aObject.Instance());
      }

	  pub fn Append(&self, s: &str)  {
          method_Call_1!(Strings_Append, self.0, to_CString!(s));
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(Strings_Assign, self.0, source.Instance());
      }

	  pub fn BeginUpdate(&self)  {
          method_Call_1!(Strings_BeginUpdate, self.0);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(Strings_Clear, self.0);
      }

	  pub fn Delete(&self, index: i32)  {
          method_Call_1!(Strings_Delete, self.0, index);
      }

	  pub fn EndUpdate(&self)  {
          method_Call_1!(Strings_EndUpdate, self.0);
      }

	  pub fn Equals(&self, strings: &dyn IStrings) -> bool  {
          return method_Call_1!(Strings_Equals, self.0, strings.Instance());
      }

	  pub fn IndexOf(&self, s: &str) -> i32  {
          return method_Call_1!(Strings_IndexOf, self.0, to_CString!(s));
      }

	  pub fn IndexOfName(&self, name: &str) -> i32  {
          return method_Call_1!(Strings_IndexOfName, self.0, to_CString!(name));
      }

	  pub fn IndexOfObject(&self, aObject: &dyn IObject) -> i32  {
          return method_Call_1!(Strings_IndexOfObject, self.0, aObject.Instance());
      }

	  pub fn Insert(&self, index: i32, s: &str)  {
          method_Call_1!(Strings_Insert, self.0, index, to_CString!(s));
      }

	  pub fn InsertObject(&self, index: i32, s: &str, aObject: &dyn IObject)  {
          method_Call_1!(Strings_InsertObject, self.0, index, to_CString!(s), aObject.Instance());
      }

	  pub fn LoadFromFile(&self, fileName: &str)  {
          method_Call_1!(Strings_LoadFromFile, self.0, to_CString!(fileName));
      }

	  pub fn LoadFromStream(&self, stream: &dyn IObject)  {
          method_Call_1!(Strings_LoadFromStream, self.0, stream.Instance());
      }

	  pub fn Move(&self, curIndex: i32, newIndex: i32)  {
          method_Call_1!(Strings_Move, self.0, curIndex, newIndex);
      }

	  pub fn SaveToFile(&self, fileName: &str)  {
          method_Call_1!(Strings_SaveToFile, self.0, to_CString!(fileName));
      }

	  pub fn SaveToStream(&self, stream: &dyn IObject)  {
          method_Call_1!(Strings_SaveToStream, self.0, stream.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Strings_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Strings_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Strings_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Strings_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Strings_InheritsFrom, self.0, aClass);
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Strings_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Strings_ToString, self.0));
      }

	  pub fn Capacity(&self) -> i32  {
          return method_Call_1!(Strings_GetCapacity, self.0);
      }

	  pub fn SetCapacity(&self, aValue: i32)  {
          method_Call_1!(Strings_SetCapacity, self.0, aValue);
      }

	  pub fn CommaText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Strings_GetCommaText, self.0));
      }

	  pub fn SetCommaText(&self, aValue: &str)  {
          method_Call_1!(Strings_SetCommaText, self.0, to_CString!(aValue));
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(Strings_GetCount, self.0);
      }

	  pub fn Delimiter(&self) -> Char  {
          return method_Call_1!(Strings_GetDelimiter, self.0);
      }

	  pub fn SetDelimiter(&self, aValue: Char)  {
          method_Call_1!(Strings_SetDelimiter, self.0, aValue);
      }

	  pub fn NameValueSeparator(&self) -> Char  {
          return method_Call_1!(Strings_GetNameValueSeparator, self.0);
      }

	  pub fn SetNameValueSeparator(&self, aValue: Char)  {
          method_Call_1!(Strings_SetNameValueSeparator, self.0, aValue);
      }

	  pub fn Text<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Strings_GetText, self.0));
      }

	  pub fn SetText(&self, aValue: &str)  {
          method_Call_1!(Strings_SetText, self.0, to_CString!(aValue));
      }

	  pub fn Objects(&self, index: i32) -> TObject  {
          return method_Call_2!(TObject, Strings_GetObjects, self.0, index);
      }

	  pub fn SetObjects(&self, index: i32, aValue: &dyn IObject)  {
          method_Call_1!(Strings_SetObjects, self.0, index, aValue.Instance());
      }

	  pub fn Values<'a>(&self, name: &str) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Strings_GetValues, self.0, to_CString!(name)));
      }

	  pub fn SetValues(&self, name: &str, aValue: &str)  {
          method_Call_1!(Strings_SetValues, self.0, to_CString!(name), to_CString!(aValue));
      }

	  pub fn ValueFromIndex<'a>(&self, index: i32) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Strings_GetValueFromIndex, self.0, index));
      }

	  pub fn SetValueFromIndex(&self, index: i32, aValue: &str)  {
          method_Call_1!(Strings_SetValueFromIndex, self.0, index, to_CString!(aValue));
      }

	  pub fn Strings<'a>(&self, index: i32) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Strings_GetStrings, self.0, index));
      }

	  pub fn SetStrings(&self, index: i32, aValue: &str)  {
          method_Call_1!(Strings_SetStrings, self.0, index, to_CString!(aValue));
      }

      // static class
	  impl_Class_method!(Strings_StaticClassType);
}

impl_IObject!(TStrings);
impl_IStrings!(TStrings);
impl_Drop_method!(TStrings);

impl TStringList {
      pub fn new() -> Self {
        method_Create!(TStringList, StringList_Create, );
      }

      impl_As_method!(TStringList);

	  impl_Free_method!(StringList_Free);

	  pub fn Add(&self, s: &str) -> i32 {
          return method_Call_1!(StringList_Add, self.0, to_CString!(s));
      }

	  pub fn AddObject(&self, s: &str, aObject: &dyn IObject) -> i32 {
          return method_Call_1!(StringList_AddObject, self.0, to_CString!(s), aObject.Instance());
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(StringList_Assign, self.0, source.Instance());
      }

	  pub fn Clear(&self) {
          method_Call_1!(StringList_Clear, self.0);
      }

	  pub fn Delete(&self, index: i32) {
          method_Call_1!(StringList_Delete, self.0, index);
      }

	  pub fn IndexOf(&self, s: &str) -> i32 {
          return method_Call_1!(StringList_IndexOf, self.0, to_CString!(s));
      }

	  pub fn Insert(&self, index: i32, s: &str) {
          method_Call_1!(StringList_Insert, self.0, index, to_CString!(s));
      }

	  pub fn InsertObject(&self, index: i32, s: &str, aObject: &dyn IObject) {
          method_Call_1!(StringList_InsertObject, self.0, index, to_CString!(s), aObject.Instance());
      }

	  pub fn Append(&self, s: &str) {
          method_Call_1!(StringList_Append, self.0, to_CString!(s));
      }

	  pub fn BeginUpdate(&self) {
          method_Call_1!(StringList_BeginUpdate, self.0);
      }

	  pub fn EndUpdate(&self) {
          method_Call_1!(StringList_EndUpdate, self.0);
      }

	  pub fn Equals(&self, strings: &dyn IStrings) -> bool  {
          return method_Call_1!(StringList_Equals, self.0, strings.Instance());
      }

	  pub fn IndexOfName(&self, name: &str) -> i32 {
          return method_Call_1!(StringList_IndexOfName, self.0, to_CString!(name));
      }

	  pub fn IndexOfObject(&self, aObject: &dyn IObject) -> i32 {
          return method_Call_1!(StringList_IndexOfObject, self.0, aObject.Instance());
      }

	  pub fn LoadFromFile(&self, fileName: &str) {
          method_Call_1!(StringList_LoadFromFile, self.0, to_CString!(fileName));
      }

	  pub fn LoadFromStream(&self, stream: &dyn IObject) {
          method_Call_1!(StringList_LoadFromStream, self.0, stream.Instance());
      }

	  pub fn Move(&self, curIndex: i32, newIndex: i32) {
          method_Call_1!(StringList_Move, self.0, curIndex, newIndex);
      }

	  pub fn SaveToFile(&self, fileName: &str) {
          method_Call_1!(StringList_SaveToFile, self.0, to_CString!(fileName));
      }

	  pub fn SaveToStream(&self, stream: &dyn IObject) {
          method_Call_1!(StringList_SaveToStream, self.0, stream.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StringList_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(StringList_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StringList_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(StringList_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(StringList_InheritsFrom, self.0, aClass);
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(StringList_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StringList_ToString, self.0));
      }

	  pub fn Sorted(&self) -> bool  {
          return method_Call_1!(StringList_GetSorted, self.0);
      }

	  pub fn SetSorted(&self, aValue: bool)  {
          method_Call_1!(StringList_SetSorted, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StringList_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnChanging(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StringList_SetOnChanging, self.0, aEventId);
      }

	  pub fn Capacity(&self) -> i32  {
          return method_Call_1!(StringList_GetCapacity, self.0);
      }

	  pub fn SetCapacity(&self, aValue: i32)  {
          method_Call_1!(StringList_SetCapacity, self.0, aValue);
      }

	  pub fn CommaText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StringList_GetCommaText, self.0));
      }

	  pub fn SetCommaText(&self, aValue: &str)  {
          method_Call_1!(StringList_SetCommaText, self.0, to_CString!(aValue));
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(StringList_GetCount, self.0);
      }

	  pub fn Delimiter(&self) -> Char  {
          return method_Call_1!(StringList_GetDelimiter, self.0);
      }

	  pub fn SetDelimiter(&self, aValue: Char)  {
          method_Call_1!(StringList_SetDelimiter, self.0, aValue);
      }

	  pub fn NameValueSeparator(&self) -> Char  {
          return method_Call_1!(StringList_GetNameValueSeparator, self.0);
      }

	  pub fn SetNameValueSeparator(&self, aValue: Char)  {
          method_Call_1!(StringList_SetNameValueSeparator, self.0, aValue);
      }

	  pub fn Text<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StringList_GetText, self.0));
      }

	  pub fn SetText(&self, aValue: &str)  {
          method_Call_1!(StringList_SetText, self.0, to_CString!(aValue));
      }

	  pub fn Objects(&self, index: i32) -> TObject  {
          return method_Call_2!(TObject, StringList_GetObjects, self.0, index);
      }

	  pub fn SetObjects(&self, index: i32, aValue: &dyn IObject)  {
          method_Call_1!(StringList_SetObjects, self.0, index, aValue.Instance());
      }

	  pub fn Values<'a>(&self, name: &str) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StringList_GetValues, self.0, to_CString!(name)));
      }

	  pub fn SetValues(&self, name: &str, aValue: &str)  {
          method_Call_1!(StringList_SetValues, self.0, to_CString!(name), to_CString!(aValue));
      }

	  pub fn ValueFromIndex<'a>(&self, index: i32) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StringList_GetValueFromIndex, self.0, index));
      }

	  pub fn SetValueFromIndex(&self, index: i32, aValue: &str)  {
          method_Call_1!(StringList_SetValueFromIndex, self.0, index, to_CString!(aValue));
      }

	  pub fn Strings<'a>(&self, index: i32) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StringList_GetStrings, self.0, index));
      }

	  pub fn SetStrings(&self, index: i32, aValue: &str)  {
          method_Call_1!(StringList_SetStrings, self.0, index, to_CString!(aValue));
      }

      // static class
	  impl_Class_method!(StringList_StaticClassType);
}

impl_IObject!(TStringList);
impl_IStrings!(TStringList);

impl TBrush {
      pub fn new() -> Self {
        method_Create!(TBrush, Brush_Create, );
      }

      impl_As_method!(TBrush);

	  impl_Free_method!(Brush_Free);

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(Brush_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Brush_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Brush_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Brush_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Brush_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Brush_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Brush_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Brush_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Brush_ToString, self.0));
      }

	  pub fn Bitmap(&self) -> TBitmap  {
          return method_Call_2!(TBitmap, Brush_GetBitmap, self.0);
      }

	  pub fn SetBitmap(&self, aValue: &TBitmap)  {
          method_Call_1!(Brush_SetBitmap, self.0, aValue.Instance());
      }

	  pub fn Handle(&self) -> HBRUSH  {
          return method_Call_1!(Brush_GetHandle, self.0);
      }

	  pub fn SetHandle(&self, aValue: HBRUSH)  {
          method_Call_1!(Brush_SetHandle, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(Brush_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(Brush_SetColor, self.0, aValue);
      }

	  pub fn Style(&self) -> TBrushStyle  {
          return method_Call_1!(Brush_GetStyle, self.0);
      }

	  pub fn SetStyle(&self, aValue: TBrushStyle)  {
          method_Call_1!(Brush_SetStyle, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Brush_SetOnChange, self.0, aEventId);
      }

      // static class
	  impl_Class_method!(Brush_StaticClassType);
}

impl_IObject!(TBrush);
impl_Drop_method!(TBrush);

impl TPen {
      pub fn new() -> Self {
        method_Create!(TPen, Pen_Create, );
      }

      impl_As_method!(TPen);

	  impl_Free_method!(Pen_Free);

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(Pen_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Pen_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Pen_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Pen_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Pen_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Pen_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Pen_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Pen_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Pen_ToString, self.0));
      }

	  pub fn Handle(&self) -> HPEN  {
          return method_Call_1!(Pen_GetHandle, self.0);
      }

	  pub fn SetHandle(&self, aValue: HPEN)  {
          method_Call_1!(Pen_SetHandle, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(Pen_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(Pen_SetColor, self.0, aValue);
      }

	  pub fn Mode(&self) -> TPenMode  {
          return method_Call_1!(Pen_GetMode, self.0);
      }

	  pub fn SetMode(&self, aValue: TPenMode)  {
          method_Call_1!(Pen_SetMode, self.0, aValue);
      }

	  pub fn Style(&self) -> TPenStyle  {
          return method_Call_1!(Pen_GetStyle, self.0);
      }

	  pub fn SetStyle(&self, aValue: TPenStyle)  {
          method_Call_1!(Pen_SetStyle, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Pen_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Pen_SetWidth, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Pen_SetOnChange, self.0, aEventId);
      }

      // static class
	  impl_Class_method!(Pen_StaticClassType);
}

impl_IObject!(TPen);
impl_Drop_method!(TPen);

impl TMenuItem {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TMenuItem, MenuItem_Create, aOwner.Instance());
      }

      impl_As_method!(TMenuItem);

	  impl_Free_method!(MenuItem_Free);

	  pub fn Insert(&self, index: i32, item: &TMenuItem)  {
          method_Call_1!(MenuItem_Insert, self.0, index, item.Instance());
      }

	  pub fn Delete(&self, index: i32)  {
          method_Call_1!(MenuItem_Delete, self.0, index);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(MenuItem_Clear, self.0);
      }

	  pub fn Click(&self)  {
          method_Call_1!(MenuItem_Click, self.0);
      }

	  pub fn IndexOf(&self, item: &TMenuItem) -> i32  {
          return method_Call_1!(MenuItem_IndexOf, self.0, item.Instance());
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(MenuItem_HasParent, self.0);
      }

	  pub fn Add(&self, item: &TMenuItem)  {
          method_Call_1!(MenuItem_Add, self.0, item.Instance());
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, MenuItem_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MenuItem_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(MenuItem_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(MenuItem_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MenuItem_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(MenuItem_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(MenuItem_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(MenuItem_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(MenuItem_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MenuItem_ToString, self.0));
      }

	  pub fn Handle(&self) -> HMENU  {
          return method_Call_1!(MenuItem_GetHandle, self.0);
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(MenuItem_GetCount, self.0);
      }

	  pub fn Parent(&self) -> TMenuItem  {
          return method_Call_2!(TMenuItem, MenuItem_GetParent, self.0);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, MenuItem_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(MenuItem_SetAction, self.0, aValue.Instance());
      }

	  pub fn AutoCheck(&self) -> bool  {
          return method_Call_1!(MenuItem_GetAutoCheck, self.0);
      }

	  pub fn SetAutoCheck(&self, aValue: bool)  {
          method_Call_1!(MenuItem_SetAutoCheck, self.0, aValue);
      }

	  pub fn Bitmap(&self) -> TBitmap  {
          return method_Call_2!(TBitmap, MenuItem_GetBitmap, self.0);
      }

	  pub fn SetBitmap(&self, aValue: &TBitmap)  {
          method_Call_1!(MenuItem_SetBitmap, self.0, aValue.Instance());
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MenuItem_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(MenuItem_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Checked(&self) -> bool  {
          return method_Call_1!(MenuItem_GetChecked, self.0);
      }

	  pub fn SetChecked(&self, aValue: bool)  {
          method_Call_1!(MenuItem_SetChecked, self.0, aValue);
      }

	  pub fn Default(&self) -> bool  {
          return method_Call_1!(MenuItem_GetDefault, self.0);
      }

	  pub fn SetDefault(&self, aValue: bool)  {
          method_Call_1!(MenuItem_SetDefault, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(MenuItem_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(MenuItem_SetEnabled, self.0, aValue);
      }

	  pub fn GroupIndex(&self) -> i8  {
          return method_Call_1!(MenuItem_GetGroupIndex, self.0);
      }

	  pub fn SetGroupIndex(&self, aValue: i8)  {
          method_Call_1!(MenuItem_SetGroupIndex, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MenuItem_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(MenuItem_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ImageIndex(&self) -> i32  {
          return method_Call_1!(MenuItem_GetImageIndex, self.0);
      }

	  pub fn SetImageIndex(&self, aValue: i32)  {
          method_Call_1!(MenuItem_SetImageIndex, self.0, aValue);
      }

	  pub fn RadioItem(&self) -> bool  {
          return method_Call_1!(MenuItem_GetRadioItem, self.0);
      }

	  pub fn SetRadioItem(&self, aValue: bool)  {
          method_Call_1!(MenuItem_SetRadioItem, self.0, aValue);
      }

	  pub fn ShortCut(&self) -> TShortCut  {
          return method_Call_1!(MenuItem_GetShortCut, self.0);
      }

	  pub fn SetShortCut(&self, aValue: TShortCut)  {
          method_Call_1!(MenuItem_SetShortCut, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(MenuItem_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(MenuItem_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(MenuItem_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnMeasureItem(&self, aEventId: TMenuMeasureItemEvent)  {
          method_Call_1!(MenuItem_SetOnMeasureItem, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(MenuItem_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(MenuItem_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(MenuItem_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, MenuItem_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MenuItem_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(MenuItem_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(MenuItem_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(MenuItem_SetTag, self.0, aValue);
      }

	  pub fn Items(&self, index: i32) -> TMenuItem  {
          return method_Call_2!(TMenuItem, MenuItem_GetItems, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, MenuItem_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(MenuItem_StaticClassType);
}

impl_IObject!(TMenuItem);
impl_IComponent!(TMenuItem);

impl TPicture {
      pub fn new() -> Self {
        method_Create!(TPicture, Picture_Create, );
      }

      impl_As_method!(TPicture);

	  impl_Free_method!(Picture_Free);

	  pub fn LoadFromFile(&self, filename: &str)  {
          method_Call_1!(Picture_LoadFromFile, self.0, to_CString!(filename));
      }

	  pub fn SaveToFile(&self, filename: &str)  {
          method_Call_1!(Picture_SaveToFile, self.0, to_CString!(filename));
      }

	  pub fn LoadFromStream(&self, stream: &dyn IObject)  {
          method_Call_1!(Picture_LoadFromStream, self.0, stream.Instance());
      }

	  pub fn SaveToStream(&self, stream: &dyn IObject)  {
          method_Call_1!(Picture_SaveToStream, self.0, stream.Instance());
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(Picture_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Picture_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Picture_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Picture_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Picture_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Picture_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Picture_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Picture_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Picture_ToString, self.0));
      }

	  pub fn Bitmap(&self) -> TBitmap  {
          return method_Call_2!(TBitmap, Picture_GetBitmap, self.0);
      }

	  pub fn SetBitmap(&self, aValue: &TBitmap)  {
          method_Call_1!(Picture_SetBitmap, self.0, aValue.Instance());
      }

	  pub fn Graphic(&self) -> TGraphic  {
          return method_Call_2!(TGraphic, Picture_GetGraphic, self.0);
      }

	  pub fn SetGraphic(&self, aValue: &TGraphic)  {
          method_Call_1!(Picture_SetGraphic, self.0, aValue.Instance());
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Picture_GetHeight, self.0);
      }

	  pub fn Icon(&self) -> TIcon  {
          return method_Call_2!(TIcon, Picture_GetIcon, self.0);
      }

	  pub fn SetIcon(&self, aValue: &TIcon)  {
          method_Call_1!(Picture_SetIcon, self.0, aValue.Instance());
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Picture_GetWidth, self.0);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Picture_SetOnChange, self.0, aEventId);
      }

      // static class
	  impl_Class_method!(Picture_StaticClassType);
}

impl_IObject!(TPicture);
impl_Drop_method!(TPicture);

impl TListColumns {
      pub fn new(aOwner: &TListView) -> Self {
        method_Create!(TListColumns, ListColumns_Create, aOwner.Instance());
      }

      impl_As_method!(TListColumns);

	  impl_Free_method!(ListColumns_Free);

	  pub fn Add(&self) -> TListColumn  {
          return method_Call_2!(TListColumn, ListColumns_Add, self.0);
      }

	  pub fn Owner(&self) -> TListView  {
          return method_Call_2!(TListView, ListColumns_Owner, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(ListColumns_Assign, self.0, source.Instance());
      }

	  pub fn BeginUpdate(&self)  {
          method_Call_1!(ListColumns_BeginUpdate, self.0);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(ListColumns_Clear, self.0);
      }

	  pub fn Delete(&self, index: i32)  {
          method_Call_1!(ListColumns_Delete, self.0, index);
      }

	  pub fn EndUpdate(&self)  {
          method_Call_1!(ListColumns_EndUpdate, self.0);
      }

	  pub fn FindItemID(&self, iD: i32) -> TCollectionItem  {
          return method_Call_2!(TCollectionItem, ListColumns_FindItemID, self.0, iD);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ListColumns_GetNamePath, self.0));
      }

	  pub fn Insert(&self, index: i32) -> TCollectionItem  {
          return method_Call_2!(TCollectionItem, ListColumns_Insert, self.0, index);
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ListColumns_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ListColumns_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ListColumns_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ListColumns_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ListColumns_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ListColumns_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ListColumns_ToString, self.0));
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(ListColumns_GetCount, self.0);
      }

	  pub fn Items(&self, index: i32) -> TListColumn  {
          return method_Call_2!(TListColumn, ListColumns_GetItems, self.0, index);
      }

	  pub fn SetItems(&self, index: i32, aValue: &TListColumn)  {
          method_Call_1!(ListColumns_SetItems, self.0, index, aValue.Instance());
      }

      // static class
	  impl_Class_method!(ListColumns_StaticClassType);
}

impl_IObject!(TListColumns);
impl_Drop_method!(TListColumns);

impl TListItems {
      pub fn new(aOwner: &TListView) -> Self {
        method_Create!(TListItems, ListItems_Create, aOwner.Instance());
      }

      impl_As_method!(TListItems);

	  impl_Free_method!(ListItems_Free);

	  pub fn Add(&self) -> TListItem  {
          return method_Call_2!(TListItem, ListItems_Add, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(ListItems_Assign, self.0, source.Instance());
      }

	  pub fn BeginUpdate(&self)  {
          method_Call_1!(ListItems_BeginUpdate, self.0);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(ListItems_Clear, self.0);
      }

	  pub fn Delete(&self, index: i32)  {
          method_Call_1!(ListItems_Delete, self.0, index);
      }

	  pub fn EndUpdate(&self)  {
          method_Call_1!(ListItems_EndUpdate, self.0);
      }

	  pub fn IndexOf(&self, value: &TListItem) -> i32  {
          return method_Call_1!(ListItems_IndexOf, self.0, value.Instance());
      }

	  pub fn Insert(&self, index: i32) -> TListItem  {
          return method_Call_2!(TListItem, ListItems_Insert, self.0, index);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ListItems_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ListItems_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ListItems_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ListItems_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ListItems_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ListItems_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ListItems_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ListItems_ToString, self.0));
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(ListItems_GetCount, self.0);
      }

	  pub fn SetCount(&self, aValue: i32)  {
          method_Call_1!(ListItems_SetCount, self.0, aValue);
      }

	  pub fn Owner(&self) -> TListView  {
          return method_Call_2!(TListView, ListItems_GetOwner, self.0);
      }

	  pub fn Item(&self, index: i32) -> TListItem  {
          return method_Call_2!(TListItem, ListItems_GetItem, self.0, index);
      }

	  pub fn SetItem(&self, index: i32, aValue: &TListItem)  {
          method_Call_1!(ListItems_SetItem, self.0, index, aValue.Instance());
      }

      // static class
	  impl_Class_method!(ListItems_StaticClassType);
}

impl_IObject!(TListItems);
impl_Drop_method!(TListItems);

impl TTreeNodes {
      pub fn new(aOwner: &TTreeView) -> Self {
        method_Create!(TTreeNodes, TreeNodes_Create, aOwner.Instance());
      }

      impl_As_method!(TTreeNodes);

	  impl_Free_method!(TreeNodes_Free);

	  pub fn AddChildFirst(&self, parent: &TTreeNode, s: &str) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeNodes_AddChildFirst, self.0, parent.Instance(), to_CString!(s));
      }

	  pub fn AddChild(&self, parent: &TTreeNode, s: &str) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeNodes_AddChild, self.0, parent.Instance(), to_CString!(s));
      }

	  pub fn AddChildObjectFirst(&self, parent: &TTreeNode, s: &str, ptr: usize) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeNodes_AddChildObjectFirst, self.0, parent.Instance(), to_CString!(s), ptr);
      }

	  pub fn AddChildObject(&self, parent: &TTreeNode, s: &str, ptr: usize) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeNodes_AddChildObject, self.0, parent.Instance(), to_CString!(s), ptr);
      }

	  pub fn AddObjectFirst(&self, sibling: &TTreeNode, s: &str, ptr: usize) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeNodes_AddObjectFirst, self.0, sibling.Instance(), to_CString!(s), ptr);
      }

	  pub fn AddObject(&self, sibling: &TTreeNode, s: &str, ptr: usize) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeNodes_AddObject, self.0, sibling.Instance(), to_CString!(s), ptr);
      }

	  pub fn AddNode(&self, node: &TTreeNode, relative: &TTreeNode, s: &str, ptr: usize, method: TNodeAttachMode) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeNodes_AddNode, self.0, node.Instance(), relative.Instance(), to_CString!(s), ptr, method);
      }

	  pub fn AddFirst(&self, sibling: &TTreeNode, s: &str) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeNodes_AddFirst, self.0, sibling.Instance(), to_CString!(s));
      }

	  pub fn Add(&self, sibling: &TTreeNode, s: &str) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeNodes_Add, self.0, sibling.Instance(), to_CString!(s));
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(TreeNodes_Assign, self.0, source.Instance());
      }

	  pub fn BeginUpdate(&self)  {
          method_Call_1!(TreeNodes_BeginUpdate, self.0);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(TreeNodes_Clear, self.0);
      }

	  pub fn Delete(&self, node: &TTreeNode)  {
          method_Call_1!(TreeNodes_Delete, self.0, node.Instance());
      }

	  pub fn EndUpdate(&self)  {
          method_Call_1!(TreeNodes_EndUpdate, self.0);
      }

	  pub fn GetFirstNode(&self) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeNodes_GetFirstNode, self.0);
      }

	  pub fn Insert(&self, sibling: &TTreeNode, s: &str) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeNodes_Insert, self.0, sibling.Instance(), to_CString!(s));
      }

	  pub fn InsertObject(&self, sibling: &TTreeNode, s: &str, ptr: usize) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeNodes_InsertObject, self.0, sibling.Instance(), to_CString!(s), ptr);
      }

	  pub fn CustomSort(&self, sortProc: PFNTVCOMPARE, data: isize, aRecurse: bool) -> bool  {
          return method_Call_1!(TreeNodes_CustomSort, self.0, sortProc, data, aRecurse);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TreeNodes_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(TreeNodes_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TreeNodes_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(TreeNodes_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(TreeNodes_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(TreeNodes_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(TreeNodes_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TreeNodes_ToString, self.0));
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(TreeNodes_GetCount, self.0);
      }

	  pub fn Owner(&self) -> TTreeView  {
          return method_Call_2!(TTreeView, TreeNodes_GetOwner, self.0);
      }

	  pub fn Item(&self, index: i32) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeNodes_GetItem, self.0, index);
      }

      // static class
	  impl_Class_method!(TreeNodes_StaticClassType);
}

impl_IObject!(TTreeNodes);
impl_Drop_method!(TTreeNodes);

impl TListItem {
      pub fn new(aOwner: &TListItems) -> Self {
        method_Create!(TListItem, ListItem_Create, aOwner.Instance());
      }

      impl_As_method!(TListItem);

	  impl_Free_method!(ListItem_Free);

	  pub fn DisplayRectSubItem(&self, subItem: i32, code: TDisplayCode) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ListItem_DisplayRectSubItem, self.0, subItem, code, &mut result);
          return result;
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(ListItem_Assign, self.0, source.Instance());
      }

	  pub fn Delete(&self)  {
          method_Call_1!(ListItem_Delete, self.0);
      }

	  pub fn DisplayRect(&self, code: TDisplayCode) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ListItem_DisplayRect, self.0, code, &mut result);
          return result;
      }

	  pub fn EditCaption(&self) -> bool  {
          return method_Call_1!(ListItem_EditCaption, self.0);
      }

	  pub fn MakeVisible(&self, partialOK: bool)  {
          method_Call_1!(ListItem_MakeVisible, self.0, partialOK);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ListItem_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ListItem_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ListItem_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ListItem_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ListItem_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ListItem_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ListItem_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ListItem_ToString, self.0));
      }

	  pub fn DropTarget(&self) -> bool  {
          return method_Call_1!(ListItem_GetDropTarget, self.0);
      }

	  pub fn SetDropTarget(&self, aValue: bool)  {
          method_Call_1!(ListItem_SetDropTarget, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ListItem_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(ListItem_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Checked(&self) -> bool  {
          return method_Call_1!(ListItem_GetChecked, self.0);
      }

	  pub fn SetChecked(&self, aValue: bool)  {
          method_Call_1!(ListItem_SetChecked, self.0, aValue);
      }

	  pub fn Cut(&self) -> bool  {
          return method_Call_1!(ListItem_GetCut, self.0);
      }

	  pub fn SetCut(&self, aValue: bool)  {
          method_Call_1!(ListItem_SetCut, self.0, aValue);
      }

	  pub fn Data(&self) -> usize  {
          return method_Call_1!(ListItem_GetData, self.0);
      }

	  pub fn SetData(&self, aValue: usize)  {
          method_Call_1!(ListItem_SetData, self.0, aValue);
      }

	  pub fn Focused(&self) -> bool  {
          return method_Call_1!(ListItem_GetFocused, self.0);
      }

	  pub fn SetFocused(&self, aValue: bool)  {
          method_Call_1!(ListItem_SetFocused, self.0, aValue);
      }

	  pub fn ImageIndex(&self) -> i32  {
          return method_Call_1!(ListItem_GetImageIndex, self.0);
      }

	  pub fn SetImageIndex(&self, aValue: i32)  {
          method_Call_1!(ListItem_SetImageIndex, self.0, aValue);
      }

	  pub fn Index(&self) -> i32  {
          return method_Call_1!(ListItem_GetIndex, self.0);
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ListItem_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ListItem_SetLeft, self.0, aValue);
      }

	  pub fn ListView(&self) -> TListView  {
          return method_Call_2!(TListView, ListItem_GetListView, self.0);
      }

	  pub fn Owner(&self) -> TListItems  {
          return method_Call_2!(TListItems, ListItem_GetOwner, self.0);
      }

	  pub fn Position(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ListItem_GetPosition, self.0, &mut result);
          return result;
      }

	  pub fn SetPosition(&self, aValue: *mut TPoint)  {
          method_Call_1!(ListItem_SetPosition, self.0, aValue);
      }

	  pub fn Selected(&self) -> bool  {
          return method_Call_1!(ListItem_GetSelected, self.0);
      }

	  pub fn SetSelected(&self, aValue: bool)  {
          method_Call_1!(ListItem_SetSelected, self.0, aValue);
      }

	  pub fn StateIndex(&self) -> i32  {
          return method_Call_1!(ListItem_GetStateIndex, self.0);
      }

	  pub fn SetStateIndex(&self, aValue: i32)  {
          method_Call_1!(ListItem_SetStateIndex, self.0, aValue);
      }

	  pub fn SubItems(&self) -> TStrings  {
          return method_Call_2!(TStrings, ListItem_GetSubItems, self.0);
      }

	  pub fn SetSubItems(&self, aValue: &dyn IStrings)  {
          method_Call_1!(ListItem_SetSubItems, self.0, aValue.Instance());
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ListItem_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ListItem_SetTop, self.0, aValue);
      }

	  pub fn SubItemImages(&self, index: i32) -> i32  {
          return method_Call_1!(ListItem_GetSubItemImages, self.0, index);
      }

	  pub fn SetSubItemImages(&self, index: i32, aValue: i32)  {
          method_Call_1!(ListItem_SetSubItemImages, self.0, index, aValue);
      }

      // static class
	  impl_Class_method!(ListItem_StaticClassType);
}

impl_IObject!(TListItem);
impl_Drop_method!(TListItem);

impl TTreeNode {
      pub fn new(aOwner: &TTreeNodes) -> Self {
        method_Create!(TTreeNode, TreeNode_Create, aOwner.Instance());
      }

      impl_As_method!(TTreeNode);

	  impl_Free_method!(TreeNode_Free);

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(TreeNode_Assign, self.0, source.Instance());
      }

	  pub fn Collapse(&self, recurse: bool)  {
          method_Call_1!(TreeNode_Collapse, self.0, recurse);
      }

	  pub fn Delete(&self)  {
          method_Call_1!(TreeNode_Delete, self.0);
      }

	  pub fn DisplayRect(&self, textOnly: bool) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(TreeNode_DisplayRect, self.0, textOnly, &mut result);
          return result;
      }

	  pub fn EditText(&self) -> bool  {
          return method_Call_1!(TreeNode_EditText, self.0);
      }

	  pub fn Expand(&self, recurse: bool)  {
          method_Call_1!(TreeNode_Expand, self.0, recurse);
      }

	  pub fn IndexOf(&self, value: &TTreeNode) -> i32  {
          return method_Call_1!(TreeNode_IndexOf, self.0, value.Instance());
      }

	  pub fn MakeVisible(&self)  {
          method_Call_1!(TreeNode_MakeVisible, self.0);
      }

	  pub fn MoveTo(&self, destination: &TTreeNode, mode: TNodeAttachMode)  {
          method_Call_1!(TreeNode_MoveTo, self.0, destination.Instance(), mode);
      }

	  pub fn CustomSort(&self, sortProc: PFNTVCOMPARE, data: isize, aRecurse: bool) -> bool  {
          return method_Call_1!(TreeNode_CustomSort, self.0, sortProc, data, aRecurse);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TreeNode_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(TreeNode_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TreeNode_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(TreeNode_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(TreeNode_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(TreeNode_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(TreeNode_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TreeNode_ToString, self.0));
      }

	  pub fn AbsoluteIndex(&self) -> i32  {
          return method_Call_1!(TreeNode_GetAbsoluteIndex, self.0);
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(TreeNode_GetCount, self.0);
      }

	  pub fn Cut(&self) -> bool  {
          return method_Call_1!(TreeNode_GetCut, self.0);
      }

	  pub fn SetCut(&self, aValue: bool)  {
          method_Call_1!(TreeNode_SetCut, self.0, aValue);
      }

	  pub fn Data(&self) -> usize  {
          return method_Call_1!(TreeNode_GetData, self.0);
      }

	  pub fn SetData(&self, aValue: usize)  {
          method_Call_1!(TreeNode_SetData, self.0, aValue);
      }

	  pub fn Deleting(&self) -> bool  {
          return method_Call_1!(TreeNode_GetDeleting, self.0);
      }

	  pub fn Focused(&self) -> bool  {
          return method_Call_1!(TreeNode_GetFocused, self.0);
      }

	  pub fn SetFocused(&self, aValue: bool)  {
          method_Call_1!(TreeNode_SetFocused, self.0, aValue);
      }

	  pub fn DropTarget(&self) -> bool  {
          return method_Call_1!(TreeNode_GetDropTarget, self.0);
      }

	  pub fn SetDropTarget(&self, aValue: bool)  {
          method_Call_1!(TreeNode_SetDropTarget, self.0, aValue);
      }

	  pub fn Selected(&self) -> bool  {
          return method_Call_1!(TreeNode_GetSelected, self.0);
      }

	  pub fn SetSelected(&self, aValue: bool)  {
          method_Call_1!(TreeNode_SetSelected, self.0, aValue);
      }

	  pub fn Expanded(&self) -> bool  {
          return method_Call_1!(TreeNode_GetExpanded, self.0);
      }

	  pub fn SetExpanded(&self, aValue: bool)  {
          method_Call_1!(TreeNode_SetExpanded, self.0, aValue);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(TreeNode_GetHandle, self.0);
      }

	  pub fn HasChildren(&self) -> bool  {
          return method_Call_1!(TreeNode_GetHasChildren, self.0);
      }

	  pub fn SetHasChildren(&self, aValue: bool)  {
          method_Call_1!(TreeNode_SetHasChildren, self.0, aValue);
      }

	  pub fn ImageIndex(&self) -> i32  {
          return method_Call_1!(TreeNode_GetImageIndex, self.0);
      }

	  pub fn SetImageIndex(&self, aValue: i32)  {
          method_Call_1!(TreeNode_SetImageIndex, self.0, aValue);
      }

	  pub fn Index(&self) -> i32  {
          return method_Call_1!(TreeNode_GetIndex, self.0);
      }

	  pub fn IsVisible(&self) -> bool  {
          return method_Call_1!(TreeNode_GetIsVisible, self.0);
      }

	  pub fn Level(&self) -> i32  {
          return method_Call_1!(TreeNode_GetLevel, self.0);
      }

	  pub fn Owner(&self) -> TTreeNodes  {
          return method_Call_2!(TTreeNodes, TreeNode_GetOwner, self.0);
      }

	  pub fn Parent(&self) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeNode_GetParent, self.0);
      }

	  pub fn SelectedIndex(&self) -> i32  {
          return method_Call_1!(TreeNode_GetSelectedIndex, self.0);
      }

	  pub fn SetSelectedIndex(&self, aValue: i32)  {
          method_Call_1!(TreeNode_SetSelectedIndex, self.0, aValue);
      }

	  pub fn StateIndex(&self) -> i32  {
          return method_Call_1!(TreeNode_GetStateIndex, self.0);
      }

	  pub fn SetStateIndex(&self, aValue: i32)  {
          method_Call_1!(TreeNode_SetStateIndex, self.0, aValue);
      }

	  pub fn Text<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TreeNode_GetText, self.0));
      }

	  pub fn SetText(&self, aValue: &str)  {
          method_Call_1!(TreeNode_SetText, self.0, to_CString!(aValue));
      }

	  pub fn TreeView(&self) -> TTreeView  {
          return method_Call_2!(TTreeView, TreeNode_GetTreeView, self.0);
      }

	  pub fn Item(&self, index: i32) -> TTreeNode  {
          return method_Call_2!(TTreeNode, TreeNode_GetItem, self.0, index);
      }

	  pub fn SetItem(&self, index: i32, aValue: &TTreeNode)  {
          method_Call_1!(TreeNode_SetItem, self.0, index, aValue.Instance());
      }

      // static class
	  impl_Class_method!(TreeNode_StaticClassType);
}

impl_IObject!(TTreeNode);
impl_Drop_method!(TTreeNode);

impl TPageControl {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TPageControl, PageControl_Create, aOwner.Instance());
      }

      impl_As_method!(TPageControl);

	  impl_Free_method!(PageControl_Free);

	  pub fn SelectNextPage(&self, goForward: bool, checkTabVisible: bool)  {
          method_Call_1!(PageControl_SelectNextPage, self.0, goForward, checkTabVisible);
      }

	  pub fn TabRect(&self, index: i32) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(PageControl_TabRect, self.0, index, &mut result);
          return result;
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(PageControl_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(PageControl_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, PageControl_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(PageControl_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(PageControl_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, PageControl_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(PageControl_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(PageControl_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(PageControl_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(PageControl_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(PageControl_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(PageControl_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(PageControl_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(PageControl_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(PageControl_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(PageControl_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(PageControl_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(PageControl_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(PageControl_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(PageControl_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(PageControl_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(PageControl_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(PageControl_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(PageControl_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(PageControl_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(PageControl_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(PageControl_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(PageControl_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(PageControl_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(PageControl_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(PageControl_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(PageControl_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(PageControl_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(PageControl_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, PageControl_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PageControl_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(PageControl_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(PageControl_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PageControl_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(PageControl_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(PageControl_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(PageControl_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(PageControl_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PageControl_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(PageControl_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(PageControl_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(PageControl_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(PageControl_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(PageControl_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(PageControl_AnchorClient, self.0, aSpace);
      }

	  pub fn Options(&self) -> TCTabControlOptions  {
          return method_Call_1!(PageControl_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TCTabControlOptions)  {
          method_Call_1!(PageControl_SetOptions, self.0, aValue);
      }

	  pub fn ActivePageIndex(&self) -> i32  {
          return method_Call_1!(PageControl_GetActivePageIndex, self.0);
      }

	  pub fn SetActivePageIndex(&self, aValue: i32)  {
          method_Call_1!(PageControl_SetActivePageIndex, self.0, aValue);
      }

	  pub fn PageCount(&self) -> i32  {
          return method_Call_1!(PageControl_GetPageCount, self.0);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(PageControl_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(PageControl_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(PageControl_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(PageControl_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(PageControl_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(PageControl_SetBiDiMode, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, PageControl_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(PageControl_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(PageControl_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(PageControl_SetDockSite, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(PageControl_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(PageControl_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(PageControl_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(PageControl_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(PageControl_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(PageControl_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(PageControl_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(PageControl_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(PageControl_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(PageControl_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, PageControl_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(PageControl_SetFont, self.0, aValue.Instance());
      }

	  pub fn Images(&self) -> TImageList  {
          return method_Call_2!(TImageList, PageControl_GetImages, self.0);
      }

	  pub fn SetImages(&self, aValue: &TImageList)  {
          method_Call_1!(PageControl_SetImages, self.0, aValue.Instance());
      }

	  pub fn MultiLine(&self) -> bool  {
          return method_Call_1!(PageControl_GetMultiLine, self.0);
      }

	  pub fn SetMultiLine(&self, aValue: bool)  {
          method_Call_1!(PageControl_SetMultiLine, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(PageControl_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(PageControl_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(PageControl_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(PageControl_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(PageControl_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(PageControl_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, PageControl_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(PageControl_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(PageControl_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(PageControl_SetShowHint, self.0, aValue);
      }

	  pub fn TabHeight(&self) -> i16  {
          return method_Call_1!(PageControl_GetTabHeight, self.0);
      }

	  pub fn SetTabHeight(&self, aValue: i16)  {
          method_Call_1!(PageControl_SetTabHeight, self.0, aValue);
      }

	  pub fn TabIndex(&self) -> i32  {
          return method_Call_1!(PageControl_GetTabIndex, self.0);
      }

	  pub fn SetTabIndex(&self, aValue: i32)  {
          method_Call_1!(PageControl_SetTabIndex, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(PageControl_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(PageControl_SetTabOrder, self.0, aValue);
      }

	  pub fn TabPosition(&self) -> TTabPosition  {
          return method_Call_1!(PageControl_GetTabPosition, self.0);
      }

	  pub fn SetTabPosition(&self, aValue: TTabPosition)  {
          method_Call_1!(PageControl_SetTabPosition, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(PageControl_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(PageControl_SetTabStop, self.0, aValue);
      }

	  pub fn TabWidth(&self) -> i16  {
          return method_Call_1!(PageControl_GetTabWidth, self.0);
      }

	  pub fn SetTabWidth(&self, aValue: i16)  {
          method_Call_1!(PageControl_SetTabWidth, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(PageControl_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(PageControl_SetVisible, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PageControl_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnChanging(&self, aEventId: TTabChangingEvent)  {
          method_Call_1!(PageControl_SetOnChanging, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(PageControl_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDockDrop(&self, aEventId: TDockDropEvent)  {
          method_Call_1!(PageControl_SetOnDockDrop, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(PageControl_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(PageControl_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(PageControl_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(PageControl_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PageControl_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PageControl_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnGetSiteInfo(&self, aEventId: TGetSiteInfoEvent)  {
          method_Call_1!(PageControl_SetOnGetSiteInfo, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(PageControl_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PageControl_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PageControl_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(PageControl_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(PageControl_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnResize(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PageControl_SetOnResize, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(PageControl_SetOnStartDock, self.0, aEventId);
      }

	  pub fn SetOnUnDock(&self, aEventId: TUnDockEvent)  {
          method_Call_1!(PageControl_SetOnUnDock, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(PageControl_GetDockClientCount, self.0);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(PageControl_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(PageControl_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, PageControl_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(PageControl_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(PageControl_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(PageControl_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(PageControl_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(PageControl_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(PageControl_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(PageControl_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, PageControl_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(PageControl_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(PageControl_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(PageControl_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(PageControl_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(PageControl_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(PageControl_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(PageControl_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(PageControl_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(PageControl_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(PageControl_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(PageControl_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(PageControl_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(PageControl_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(PageControl_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, PageControl_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(PageControl_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(PageControl_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(PageControl_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(PageControl_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(PageControl_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(PageControl_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(PageControl_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(PageControl_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(PageControl_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(PageControl_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(PageControl_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(PageControl_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(PageControl_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(PageControl_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(PageControl_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(PageControl_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, PageControl_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(PageControl_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(PageControl_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(PageControl_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(PageControl_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, PageControl_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(PageControl_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, PageControl_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(PageControl_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, PageControl_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(PageControl_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, PageControl_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(PageControl_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, PageControl_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(PageControl_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, PageControl_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(PageControl_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Pages(&self, index: i32) -> TTabSheet  {
          return method_Call_2!(TTabSheet, PageControl_GetPages, self.0, index);
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, PageControl_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, PageControl_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, PageControl_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, PageControl_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(PageControl_StaticClassType);
}

impl_IObject!(TPageControl);
impl_IComponent!(TPageControl);
impl_IControl!(TPageControl);
impl_IWinControl!(TPageControl);

impl TTabSheet {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TTabSheet, TabSheet_Create, aOwner.Instance());
      }

      impl_As_method!(TTabSheet);

	  impl_Free_method!(TabSheet_Free);

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(TabSheet_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(TabSheet_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, TabSheet_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(TabSheet_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(TabSheet_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, TabSheet_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(TabSheet_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(TabSheet_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(TabSheet_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(TabSheet_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(TabSheet_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(TabSheet_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(TabSheet_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(TabSheet_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(TabSheet_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(TabSheet_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(TabSheet_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(TabSheet_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(TabSheet_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(TabSheet_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(TabSheet_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(TabSheet_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(TabSheet_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(TabSheet_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(TabSheet_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(TabSheet_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(TabSheet_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(TabSheet_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(TabSheet_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(TabSheet_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(TabSheet_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(TabSheet_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(TabSheet_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(TabSheet_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, TabSheet_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TabSheet_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(TabSheet_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(TabSheet_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TabSheet_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(TabSheet_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(TabSheet_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(TabSheet_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(TabSheet_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TabSheet_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(TabSheet_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(TabSheet_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(TabSheet_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(TabSheet_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(TabSheet_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(TabSheet_AnchorClient, self.0, aSpace);
      }

	  pub fn PageControl(&self) -> TPageControl  {
          return method_Call_2!(TPageControl, TabSheet_GetPageControl, self.0);
      }

	  pub fn SetPageControl(&self, aValue: &TPageControl)  {
          method_Call_1!(TabSheet_SetPageControl, self.0, aValue.Instance());
      }

	  pub fn TabIndex(&self) -> i32  {
          return method_Call_1!(TabSheet_GetTabIndex, self.0);
      }

	  pub fn BorderWidth(&self) -> i32  {
          return method_Call_1!(TabSheet_GetBorderWidth, self.0);
      }

	  pub fn SetBorderWidth(&self, aValue: i32)  {
          method_Call_1!(TabSheet_SetBorderWidth, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TabSheet_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(TabSheet_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(TabSheet_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(TabSheet_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(TabSheet_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(TabSheet_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, TabSheet_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(TabSheet_SetFont, self.0, aValue.Instance());
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(TabSheet_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(TabSheet_SetHeight, self.0, aValue);
      }

	  pub fn ImageIndex(&self) -> i32  {
          return method_Call_1!(TabSheet_GetImageIndex, self.0);
      }

	  pub fn SetImageIndex(&self, aValue: i32)  {
          method_Call_1!(TabSheet_SetImageIndex, self.0, aValue);
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(TabSheet_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(TabSheet_SetLeft, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, TabSheet_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(TabSheet_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn PageIndex(&self) -> i32  {
          return method_Call_1!(TabSheet_GetPageIndex, self.0);
      }

	  pub fn SetPageIndex(&self, aValue: i32)  {
          method_Call_1!(TabSheet_SetPageIndex, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(TabSheet_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(TabSheet_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(TabSheet_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(TabSheet_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(TabSheet_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(TabSheet_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, TabSheet_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(TabSheet_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(TabSheet_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(TabSheet_SetShowHint, self.0, aValue);
      }

	  pub fn TabVisible(&self) -> bool  {
          return method_Call_1!(TabSheet_GetTabVisible, self.0);
      }

	  pub fn SetTabVisible(&self, aValue: bool)  {
          method_Call_1!(TabSheet_SetTabVisible, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(TabSheet_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(TabSheet_SetTop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(TabSheet_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(TabSheet_SetVisible, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(TabSheet_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(TabSheet_SetWidth, self.0, aValue);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(TabSheet_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(TabSheet_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(TabSheet_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(TabSheet_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TabSheet_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TabSheet_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnHide(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TabSheet_SetOnHide, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(TabSheet_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TabSheet_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TabSheet_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(TabSheet_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(TabSheet_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnResize(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TabSheet_SetOnResize, self.0, aEventId);
      }

	  pub fn SetOnShow(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(TabSheet_SetOnShow, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(TabSheet_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(TabSheet_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(TabSheet_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(TabSheet_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(TabSheet_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, TabSheet_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(TabSheet_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(TabSheet_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(TabSheet_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(TabSheet_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(TabSheet_GetShowing, self.0);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(TabSheet_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(TabSheet_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(TabSheet_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(TabSheet_SetTabStop, self.0, aValue);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(TabSheet_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(TabSheet_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, TabSheet_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(TabSheet_SetAction, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(TabSheet_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(TabSheet_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(TabSheet_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(TabSheet_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(TabSheet_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(TabSheet_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(TabSheet_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(TabSheet_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(TabSheet_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(TabSheet_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(TabSheet_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(TabSheet_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(TabSheet_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(TabSheet_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(TabSheet_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(TabSheet_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(TabSheet_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(TabSheet_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(TabSheet_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, TabSheet_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(TabSheet_SetParent, self.0, aValue.Instance());
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(TabSheet_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(TabSheet_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TabSheet_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(TabSheet_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(TabSheet_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(TabSheet_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(TabSheet_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, TabSheet_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TabSheet_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(TabSheet_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(TabSheet_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(TabSheet_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, TabSheet_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(TabSheet_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, TabSheet_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(TabSheet_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, TabSheet_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(TabSheet_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, TabSheet_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(TabSheet_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, TabSheet_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(TabSheet_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, TabSheet_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(TabSheet_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, TabSheet_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, TabSheet_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, TabSheet_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, TabSheet_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(TabSheet_StaticClassType);
}

impl_IObject!(TTabSheet);
impl_IComponent!(TTabSheet);
impl_IControl!(TTabSheet);
impl_IWinControl!(TTabSheet);

impl TButton {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TButton, Button_Create, aOwner.Instance());
      }

      impl_As_method!(TButton);

	  impl_Free_method!(Button_Free);

	  pub fn Click(&self)  {
          method_Call_1!(Button_Click, self.0);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(Button_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(Button_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, Button_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(Button_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(Button_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, Button_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(Button_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(Button_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(Button_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(Button_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(Button_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(Button_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(Button_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(Button_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(Button_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(Button_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(Button_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(Button_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(Button_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(Button_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Button_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Button_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(Button_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Button_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(Button_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(Button_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(Button_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Button_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Button_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(Button_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(Button_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(Button_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(Button_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(Button_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Button_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Button_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Button_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Button_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Button_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Button_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Button_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Button_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Button_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Button_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Button_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Button_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Button_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Button_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(Button_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(Button_AnchorClient, self.0, aSpace);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, Button_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(Button_SetAction, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(Button_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(Button_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(Button_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(Button_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(Button_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(Button_SetBiDiMode, self.0, aValue);
      }

	  pub fn Cancel(&self) -> bool  {
          return method_Call_1!(Button_GetCancel, self.0);
      }

	  pub fn SetCancel(&self, aValue: bool)  {
          method_Call_1!(Button_SetCancel, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Button_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(Button_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, Button_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(Button_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn Default(&self) -> bool  {
          return method_Call_1!(Button_GetDefault, self.0);
      }

	  pub fn SetDefault(&self, aValue: bool)  {
          method_Call_1!(Button_SetDefault, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(Button_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(Button_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(Button_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(Button_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(Button_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(Button_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(Button_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(Button_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(Button_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(Button_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, Button_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(Button_SetFont, self.0, aValue.Instance());
      }

	  pub fn ModalResult(&self) -> TModalResult  {
          return method_Call_1!(Button_GetModalResult, self.0);
      }

	  pub fn SetModalResult(&self, aValue: TModalResult)  {
          method_Call_1!(Button_SetModalResult, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(Button_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(Button_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(Button_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(Button_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(Button_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(Button_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, Button_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(Button_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(Button_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(Button_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(Button_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(Button_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(Button_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(Button_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(Button_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(Button_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Button_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(Button_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(Button_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(Button_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(Button_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Button_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Button_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(Button_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(Button_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(Button_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Button_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Button_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Button_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(Button_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Button_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(Button_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(Button_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(Button_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(Button_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(Button_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, Button_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(Button_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(Button_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(Button_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(Button_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(Button_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(Button_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(Button_SetUseDockManager, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Button_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(Button_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(Button_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(Button_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(Button_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Button_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(Button_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(Button_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(Button_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(Button_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(Button_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(Button_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(Button_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Button_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(Button_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(Button_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(Button_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(Button_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(Button_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Button_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Button_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Button_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Button_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(Button_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(Button_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Button_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(Button_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Button_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Button_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Button_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Button_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Button_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Button_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Button_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Button_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Button_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Button_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Button_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Button_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Button_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Button_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Button_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Button_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, Button_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(Button_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, Button_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(Button_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, Button_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, Button_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Button_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Button_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(Button_StaticClassType);
}

impl_IObject!(TButton);
impl_IComponent!(TButton);
impl_IControl!(TButton);
impl_IWinControl!(TButton);

impl TEdit {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TEdit, Edit_Create, aOwner.Instance());
      }

      impl_As_method!(TEdit);

	  impl_Free_method!(Edit_Free);

	  pub fn Clear(&self)  {
          method_Call_1!(Edit_Clear, self.0);
      }

	  pub fn ClearSelection(&self)  {
          method_Call_1!(Edit_ClearSelection, self.0);
      }

	  pub fn CopyToClipboard(&self)  {
          method_Call_1!(Edit_CopyToClipboard, self.0);
      }

	  pub fn CutToClipboard(&self)  {
          method_Call_1!(Edit_CutToClipboard, self.0);
      }

	  pub fn PasteFromClipboard(&self)  {
          method_Call_1!(Edit_PasteFromClipboard, self.0);
      }

	  pub fn Undo(&self)  {
          method_Call_1!(Edit_Undo, self.0);
      }

	  pub fn SelectAll(&self)  {
          method_Call_1!(Edit_SelectAll, self.0);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(Edit_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(Edit_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, Edit_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(Edit_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(Edit_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, Edit_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(Edit_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(Edit_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(Edit_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(Edit_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(Edit_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(Edit_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(Edit_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(Edit_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(Edit_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(Edit_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(Edit_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(Edit_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(Edit_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(Edit_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Edit_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Edit_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(Edit_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Edit_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(Edit_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(Edit_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(Edit_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Edit_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Edit_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(Edit_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(Edit_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(Edit_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(Edit_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(Edit_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Edit_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Edit_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Edit_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Edit_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Edit_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Edit_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Edit_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Edit_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Edit_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Edit_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Edit_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Edit_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Edit_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Edit_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(Edit_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(Edit_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(Edit_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(Edit_SetAlign, self.0, aValue);
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(Edit_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(Edit_SetAlignment, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(Edit_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(Edit_SetAnchors, self.0, aValue);
      }

	  pub fn AutoSelect(&self) -> bool  {
          return method_Call_1!(Edit_GetAutoSelect, self.0);
      }

	  pub fn SetAutoSelect(&self, aValue: bool)  {
          method_Call_1!(Edit_SetAutoSelect, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(Edit_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(Edit_SetAutoSize, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(Edit_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(Edit_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(Edit_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(Edit_SetBorderStyle, self.0, aValue);
      }

	  pub fn CharCase(&self) -> TEditCharCase  {
          return method_Call_1!(Edit_GetCharCase, self.0);
      }

	  pub fn SetCharCase(&self, aValue: TEditCharCase)  {
          method_Call_1!(Edit_SetCharCase, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(Edit_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(Edit_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, Edit_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(Edit_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(Edit_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(Edit_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(Edit_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(Edit_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(Edit_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(Edit_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(Edit_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(Edit_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(Edit_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(Edit_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, Edit_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(Edit_SetFont, self.0, aValue.Instance());
      }

	  pub fn HideSelection(&self) -> bool  {
          return method_Call_1!(Edit_GetHideSelection, self.0);
      }

	  pub fn SetHideSelection(&self, aValue: bool)  {
          method_Call_1!(Edit_SetHideSelection, self.0, aValue);
      }

	  pub fn MaxLength(&self) -> i32  {
          return method_Call_1!(Edit_GetMaxLength, self.0);
      }

	  pub fn SetMaxLength(&self, aValue: i32)  {
          method_Call_1!(Edit_SetMaxLength, self.0, aValue);
      }

	  pub fn NumbersOnly(&self) -> bool  {
          return method_Call_1!(Edit_GetNumbersOnly, self.0);
      }

	  pub fn SetNumbersOnly(&self, aValue: bool)  {
          method_Call_1!(Edit_SetNumbersOnly, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(Edit_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(Edit_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(Edit_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(Edit_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(Edit_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(Edit_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(Edit_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(Edit_SetParentShowHint, self.0, aValue);
      }

	  pub fn PasswordChar(&self) -> Char  {
          return method_Call_1!(Edit_GetPasswordChar, self.0);
      }

	  pub fn SetPasswordChar(&self, aValue: Char)  {
          method_Call_1!(Edit_SetPasswordChar, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, Edit_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(Edit_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ReadOnly(&self) -> bool  {
          return method_Call_1!(Edit_GetReadOnly, self.0);
      }

	  pub fn SetReadOnly(&self, aValue: bool)  {
          method_Call_1!(Edit_SetReadOnly, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(Edit_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(Edit_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(Edit_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(Edit_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(Edit_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(Edit_SetTabStop, self.0, aValue);
      }

	  pub fn Text<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Edit_GetText, self.0));
      }

	  pub fn SetText(&self, aValue: &str)  {
          method_Call_1!(Edit_SetText, self.0, to_CString!(aValue));
      }

	  pub fn TextHint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Edit_GetTextHint, self.0));
      }

	  pub fn SetTextHint(&self, aValue: &str)  {
          method_Call_1!(Edit_SetTextHint, self.0, to_CString!(aValue));
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(Edit_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(Edit_SetVisible, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Edit_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Edit_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(Edit_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Edit_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(Edit_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(Edit_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(Edit_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Edit_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Edit_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(Edit_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(Edit_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(Edit_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Edit_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Edit_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Edit_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(Edit_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Edit_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn CanUndo(&self) -> bool  {
          return method_Call_1!(Edit_GetCanUndo, self.0);
      }

	  pub fn Modified(&self) -> bool  {
          return method_Call_1!(Edit_GetModified, self.0);
      }

	  pub fn SetModified(&self, aValue: bool)  {
          method_Call_1!(Edit_SetModified, self.0, aValue);
      }

	  pub fn SelLength(&self) -> i32  {
          return method_Call_1!(Edit_GetSelLength, self.0);
      }

	  pub fn SetSelLength(&self, aValue: i32)  {
          method_Call_1!(Edit_SetSelLength, self.0, aValue);
      }

	  pub fn SelStart(&self) -> i32  {
          return method_Call_1!(Edit_GetSelStart, self.0);
      }

	  pub fn SetSelStart(&self, aValue: i32)  {
          method_Call_1!(Edit_SetSelStart, self.0, aValue);
      }

	  pub fn SelText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Edit_GetSelText, self.0));
      }

	  pub fn SetSelText(&self, aValue: &str)  {
          method_Call_1!(Edit_SetSelText, self.0, to_CString!(aValue));
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(Edit_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(Edit_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(Edit_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(Edit_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(Edit_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, Edit_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(Edit_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(Edit_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(Edit_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(Edit_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(Edit_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(Edit_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(Edit_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, Edit_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(Edit_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Edit_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(Edit_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(Edit_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(Edit_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(Edit_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Edit_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(Edit_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(Edit_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(Edit_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(Edit_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(Edit_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(Edit_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(Edit_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Edit_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(Edit_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(Edit_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(Edit_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(Edit_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(Edit_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Edit_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Edit_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Edit_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Edit_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(Edit_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(Edit_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Edit_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(Edit_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Edit_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Edit_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Edit_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Edit_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Edit_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Edit_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Edit_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Edit_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Edit_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Edit_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Edit_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Edit_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Edit_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Edit_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Edit_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Edit_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, Edit_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(Edit_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, Edit_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(Edit_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, Edit_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, Edit_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Edit_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Edit_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(Edit_StaticClassType);
}

impl_IObject!(TEdit);
impl_IComponent!(TEdit);
impl_IControl!(TEdit);
impl_IWinControl!(TEdit);

impl TScreen {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TScreen, Screen_Create, aOwner.Instance());
      }

      impl_As_method!(TScreen);

	  impl_Free_method!(Screen_Free);

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Screen_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Screen_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Screen_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Screen_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Screen_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Screen_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Screen_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Screen_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Screen_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Screen_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Screen_ToString, self.0));
      }

	  pub fn ActiveControl(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Screen_GetActiveControl, self.0);
      }

	  pub fn ActiveForm(&self) -> TForm  {
          return method_Call_2!(TForm, Screen_GetActiveForm, self.0);
      }

	  pub fn CustomFormCount(&self) -> i32  {
          return method_Call_1!(Screen_GetCustomFormCount, self.0);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(Screen_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(Screen_SetCursor, self.0, aValue);
      }

	  pub fn FocusedForm(&self) -> TForm  {
          return method_Call_2!(TForm, Screen_GetFocusedForm, self.0);
      }

	  pub fn MonitorCount(&self) -> i32  {
          return method_Call_1!(Screen_GetMonitorCount, self.0);
      }

	  pub fn DesktopRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Screen_GetDesktopRect, self.0, &mut result);
          return result;
      }

	  pub fn DesktopHeight(&self) -> i32  {
          return method_Call_1!(Screen_GetDesktopHeight, self.0);
      }

	  pub fn DesktopLeft(&self) -> i32  {
          return method_Call_1!(Screen_GetDesktopLeft, self.0);
      }

	  pub fn DesktopTop(&self) -> i32  {
          return method_Call_1!(Screen_GetDesktopTop, self.0);
      }

	  pub fn DesktopWidth(&self) -> i32  {
          return method_Call_1!(Screen_GetDesktopWidth, self.0);
      }

	  pub fn WorkAreaRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Screen_GetWorkAreaRect, self.0, &mut result);
          return result;
      }

	  pub fn WorkAreaHeight(&self) -> i32  {
          return method_Call_1!(Screen_GetWorkAreaHeight, self.0);
      }

	  pub fn WorkAreaLeft(&self) -> i32  {
          return method_Call_1!(Screen_GetWorkAreaLeft, self.0);
      }

	  pub fn WorkAreaTop(&self) -> i32  {
          return method_Call_1!(Screen_GetWorkAreaTop, self.0);
      }

	  pub fn WorkAreaWidth(&self) -> i32  {
          return method_Call_1!(Screen_GetWorkAreaWidth, self.0);
      }

	  pub fn Fonts(&self) -> TStrings  {
          return method_Call_2!(TStrings, Screen_GetFonts, self.0);
      }

	  pub fn FormCount(&self) -> i32  {
          return method_Call_1!(Screen_GetFormCount, self.0);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Screen_GetHeight, self.0);
      }

	  pub fn PixelsPerInch(&self) -> i32  {
          return method_Call_1!(Screen_GetPixelsPerInch, self.0);
      }

	  pub fn PrimaryMonitor(&self) -> TMonitor  {
          return method_Call_2!(TMonitor, Screen_GetPrimaryMonitor, self.0);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Screen_GetWidth, self.0);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Screen_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Screen_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Screen_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Screen_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Screen_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Screen_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Screen_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Screen_SetTag, self.0, aValue);
      }

	  pub fn Cursors(&self, index: i32) -> HICON  {
          return method_Call_1!(Screen_GetCursors, self.0, index);
      }

	  pub fn SetCursors(&self, index: i32, aValue: HICON)  {
          method_Call_1!(Screen_SetCursors, self.0, index, aValue);
      }

	  pub fn Monitors(&self, index: i32) -> TMonitor  {
          return method_Call_2!(TMonitor, Screen_GetMonitors, self.0, index);
      }

	  pub fn Forms(&self, index: i32) -> TForm  {
          return method_Call_2!(TForm, Screen_GetForms, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Screen_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(Screen_StaticClassType);
}

impl_IObject!(TScreen);
impl_IComponent!(TScreen);

impl TMouse {
      pub fn new() -> Self {
        method_Create!(TMouse, Mouse_Create, );
      }

      impl_As_method!(TMouse);

	  impl_Free_method!(Mouse_Free);

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Mouse_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Mouse_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Mouse_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Mouse_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Mouse_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Mouse_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Mouse_ToString, self.0));
      }

	  pub fn Capture(&self) -> HWND  {
          return method_Call_1!(Mouse_GetCapture, self.0);
      }

	  pub fn SetCapture(&self, aValue: HWND)  {
          method_Call_1!(Mouse_SetCapture, self.0, aValue);
      }

	  pub fn CursorPos(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(Mouse_GetCursorPos, self.0, &mut result);
          return result;
      }

	  pub fn SetCursorPos(&self, aValue: *mut TPoint)  {
          method_Call_1!(Mouse_SetCursorPos, self.0, aValue);
      }

	  pub fn IsDragging(&self) -> bool  {
          return method_Call_1!(Mouse_GetIsDragging, self.0);
      }

	  pub fn WheelScrollLines(&self) -> i32  {
          return method_Call_1!(Mouse_GetWheelScrollLines, self.0);
      }

      // static class
	  impl_Class_method!(Mouse_StaticClassType);
}

impl_IObject!(TMouse);
impl_Drop_method!(TMouse);

impl TListColumn {
      pub fn new(aOwner: &TCollection) -> Self {
        method_Create!(TListColumn, ListColumn_Create, aOwner.Instance());
      }

      impl_As_method!(TListColumn);

	  impl_Free_method!(ListColumn_Free);

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(ListColumn_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ListColumn_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ListColumn_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ListColumn_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ListColumn_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ListColumn_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ListColumn_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ListColumn_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ListColumn_ToString, self.0));
      }

	  pub fn SortIndicator(&self) -> TSortIndicator  {
          return method_Call_1!(ListColumn_GetSortIndicator, self.0);
      }

	  pub fn SetSortIndicator(&self, aValue: TSortIndicator)  {
          method_Call_1!(ListColumn_SetSortIndicator, self.0, aValue);
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(ListColumn_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(ListColumn_SetAlignment, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(ListColumn_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(ListColumn_SetAutoSize, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ListColumn_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(ListColumn_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn ImageIndex(&self) -> i32  {
          return method_Call_1!(ListColumn_GetImageIndex, self.0);
      }

	  pub fn SetImageIndex(&self, aValue: i32)  {
          method_Call_1!(ListColumn_SetImageIndex, self.0, aValue);
      }

	  pub fn MaxWidth(&self) -> i32  {
          return method_Call_1!(ListColumn_GetMaxWidth, self.0);
      }

	  pub fn SetMaxWidth(&self, aValue: i32)  {
          method_Call_1!(ListColumn_SetMaxWidth, self.0, aValue);
      }

	  pub fn MinWidth(&self) -> i32  {
          return method_Call_1!(ListColumn_GetMinWidth, self.0);
      }

	  pub fn SetMinWidth(&self, aValue: i32)  {
          method_Call_1!(ListColumn_SetMinWidth, self.0, aValue);
      }

	  pub fn Tag(&self) -> i32  {
          return method_Call_1!(ListColumn_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: i32)  {
          method_Call_1!(ListColumn_SetTag, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ListColumn_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ListColumn_SetWidth, self.0, aValue);
      }

	  pub fn Collection(&self) -> TCollection  {
          return method_Call_2!(TCollection, ListColumn_GetCollection, self.0);
      }

	  pub fn SetCollection(&self, aValue: &TCollection)  {
          method_Call_1!(ListColumn_SetCollection, self.0, aValue.Instance());
      }

	  pub fn Index(&self) -> i32  {
          return method_Call_1!(ListColumn_GetIndex, self.0);
      }

	  pub fn SetIndex(&self, aValue: i32)  {
          method_Call_1!(ListColumn_SetIndex, self.0, aValue);
      }

	  pub fn DisplayName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ListColumn_GetDisplayName, self.0));
      }

	  pub fn SetDisplayName(&self, aValue: &str)  {
          method_Call_1!(ListColumn_SetDisplayName, self.0, to_CString!(aValue));
      }

      // static class
	  impl_Class_method!(ListColumn_StaticClassType);
}

impl_IObject!(TListColumn);
impl_Drop_method!(TListColumn);

impl TCollectionItem {
      pub fn new(aOwner: &TCollection) -> Self {
        method_Create!(TCollectionItem, CollectionItem_Create, aOwner.Instance());
      }

      impl_As_method!(TCollectionItem);

	  impl_Free_method!(CollectionItem_Free);

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CollectionItem_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(CollectionItem_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(CollectionItem_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CollectionItem_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(CollectionItem_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(CollectionItem_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(CollectionItem_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(CollectionItem_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CollectionItem_ToString, self.0));
      }

	  pub fn Collection(&self) -> TCollection  {
          return method_Call_2!(TCollection, CollectionItem_GetCollection, self.0);
      }

	  pub fn SetCollection(&self, aValue: &TCollection)  {
          method_Call_1!(CollectionItem_SetCollection, self.0, aValue.Instance());
      }

	  pub fn Index(&self) -> i32  {
          return method_Call_1!(CollectionItem_GetIndex, self.0);
      }

	  pub fn SetIndex(&self, aValue: i32)  {
          method_Call_1!(CollectionItem_SetIndex, self.0, aValue);
      }

	  pub fn DisplayName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CollectionItem_GetDisplayName, self.0));
      }

	  pub fn SetDisplayName(&self, aValue: &str)  {
          method_Call_1!(CollectionItem_SetDisplayName, self.0, to_CString!(aValue));
      }

      // static class
	  impl_Class_method!(CollectionItem_StaticClassType);
}

impl_IObject!(TCollectionItem);
impl_Drop_method!(TCollectionItem);

impl TStatusPanels {
      pub fn new(aOwner: &TStatusBar) -> Self {
        method_Create!(TStatusPanels, StatusPanels_Create, aOwner.Instance());
      }

      impl_As_method!(TStatusPanels);

	  impl_Free_method!(StatusPanels_Free);

	  pub fn Add(&self) -> TStatusPanel  {
          return method_Call_2!(TStatusPanel, StatusPanels_Add, self.0);
      }

	  pub fn Insert(&self, index: i32) -> TStatusPanel  {
          return method_Call_2!(TStatusPanel, StatusPanels_Insert, self.0, index);
      }

	  pub fn Owner(&self) -> TObject  {
          return method_Call_2!(TObject, StatusPanels_Owner, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(StatusPanels_Assign, self.0, source.Instance());
      }

	  pub fn BeginUpdate(&self)  {
          method_Call_1!(StatusPanels_BeginUpdate, self.0);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(StatusPanels_Clear, self.0);
      }

	  pub fn Delete(&self, index: i32)  {
          method_Call_1!(StatusPanels_Delete, self.0, index);
      }

	  pub fn EndUpdate(&self)  {
          method_Call_1!(StatusPanels_EndUpdate, self.0);
      }

	  pub fn FindItemID(&self, iD: i32) -> TCollectionItem  {
          return method_Call_2!(TCollectionItem, StatusPanels_FindItemID, self.0, iD);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StatusPanels_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(StatusPanels_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StatusPanels_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(StatusPanels_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(StatusPanels_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(StatusPanels_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(StatusPanels_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StatusPanels_ToString, self.0));
      }

	  pub fn Capacity(&self) -> i32  {
          return method_Call_1!(StatusPanels_GetCapacity, self.0);
      }

	  pub fn SetCapacity(&self, aValue: i32)  {
          method_Call_1!(StatusPanels_SetCapacity, self.0, aValue);
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(StatusPanels_GetCount, self.0);
      }

	  pub fn Items(&self, index: i32) -> TStatusPanel  {
          return method_Call_2!(TStatusPanel, StatusPanels_GetItems, self.0, index);
      }

	  pub fn SetItems(&self, index: i32, aValue: &TStatusPanel)  {
          method_Call_1!(StatusPanels_SetItems, self.0, index, aValue.Instance());
      }

      // static class
	  impl_Class_method!(StatusPanels_StaticClassType);
}

impl_IObject!(TStatusPanels);
impl_Drop_method!(TStatusPanels);

impl TStatusPanel {
      pub fn new(aOwner: &TCollection) -> Self {
        method_Create!(TStatusPanel, StatusPanel_Create, aOwner.Instance());
      }

      impl_As_method!(TStatusPanel);

	  impl_Free_method!(StatusPanel_Free);

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(StatusPanel_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StatusPanel_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(StatusPanel_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StatusPanel_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(StatusPanel_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(StatusPanel_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(StatusPanel_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(StatusPanel_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StatusPanel_ToString, self.0));
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(StatusPanel_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(StatusPanel_SetAlignment, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(StatusPanel_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(StatusPanel_SetBiDiMode, self.0, aValue);
      }

	  pub fn Style(&self) -> TStatusPanelStyle  {
          return method_Call_1!(StatusPanel_GetStyle, self.0);
      }

	  pub fn SetStyle(&self, aValue: TStatusPanelStyle)  {
          method_Call_1!(StatusPanel_SetStyle, self.0, aValue);
      }

	  pub fn Text<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StatusPanel_GetText, self.0));
      }

	  pub fn SetText(&self, aValue: &str)  {
          method_Call_1!(StatusPanel_SetText, self.0, to_CString!(aValue));
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(StatusPanel_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(StatusPanel_SetWidth, self.0, aValue);
      }

	  pub fn Collection(&self) -> TCollection  {
          return method_Call_2!(TCollection, StatusPanel_GetCollection, self.0);
      }

	  pub fn SetCollection(&self, aValue: &TCollection)  {
          method_Call_1!(StatusPanel_SetCollection, self.0, aValue.Instance());
      }

	  pub fn Index(&self) -> i32  {
          return method_Call_1!(StatusPanel_GetIndex, self.0);
      }

	  pub fn SetIndex(&self, aValue: i32)  {
          method_Call_1!(StatusPanel_SetIndex, self.0, aValue);
      }

	  pub fn DisplayName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StatusPanel_GetDisplayName, self.0));
      }

	  pub fn SetDisplayName(&self, aValue: &str)  {
          method_Call_1!(StatusPanel_SetDisplayName, self.0, to_CString!(aValue));
      }

      // static class
	  impl_Class_method!(StatusPanel_StaticClassType);
}

impl_IObject!(TStatusPanel);
impl_Drop_method!(TStatusPanel);

impl TSpinEdit {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TSpinEdit, SpinEdit_Create, aOwner.Instance());
      }

      impl_As_method!(TSpinEdit);

	  impl_Free_method!(SpinEdit_Free);

	  pub fn Clear(&self)  {
          method_Call_1!(SpinEdit_Clear, self.0);
      }

	  pub fn ClearSelection(&self)  {
          method_Call_1!(SpinEdit_ClearSelection, self.0);
      }

	  pub fn CopyToClipboard(&self)  {
          method_Call_1!(SpinEdit_CopyToClipboard, self.0);
      }

	  pub fn CutToClipboard(&self)  {
          method_Call_1!(SpinEdit_CutToClipboard, self.0);
      }

	  pub fn PasteFromClipboard(&self)  {
          method_Call_1!(SpinEdit_PasteFromClipboard, self.0);
      }

	  pub fn Undo(&self)  {
          method_Call_1!(SpinEdit_Undo, self.0);
      }

	  pub fn SelectAll(&self)  {
          method_Call_1!(SpinEdit_SelectAll, self.0);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(SpinEdit_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(SpinEdit_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, SpinEdit_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(SpinEdit_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(SpinEdit_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, SpinEdit_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(SpinEdit_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(SpinEdit_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(SpinEdit_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(SpinEdit_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(SpinEdit_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(SpinEdit_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(SpinEdit_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(SpinEdit_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(SpinEdit_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(SpinEdit_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(SpinEdit_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(SpinEdit_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(SpinEdit_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(SpinEdit_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(SpinEdit_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(SpinEdit_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(SpinEdit_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(SpinEdit_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(SpinEdit_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(SpinEdit_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(SpinEdit_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(SpinEdit_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(SpinEdit_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(SpinEdit_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(SpinEdit_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(SpinEdit_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(SpinEdit_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(SpinEdit_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, SpinEdit_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SpinEdit_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(SpinEdit_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(SpinEdit_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SpinEdit_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(SpinEdit_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(SpinEdit_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(SpinEdit_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(SpinEdit_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SpinEdit_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(SpinEdit_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(SpinEdit_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(SpinEdit_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(SpinEdit_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(SpinEdit_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(SpinEdit_AnchorClient, self.0, aSpace);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(SpinEdit_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(SpinEdit_SetAnchors, self.0, aValue);
      }

	  pub fn AutoSelect(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetAutoSelect, self.0);
      }

	  pub fn SetAutoSelect(&self, aValue: bool)  {
          method_Call_1!(SpinEdit_SetAutoSelect, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(SpinEdit_SetAutoSize, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(SpinEdit_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(SpinEdit_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, SpinEdit_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(SpinEdit_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(SpinEdit_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, SpinEdit_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(SpinEdit_SetFont, self.0, aValue.Instance());
      }

	  pub fn Increment(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetIncrement, self.0);
      }

	  pub fn SetIncrement(&self, aValue: i32)  {
          method_Call_1!(SpinEdit_SetIncrement, self.0, aValue);
      }

	  pub fn MaxLength(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetMaxLength, self.0);
      }

	  pub fn SetMaxLength(&self, aValue: i32)  {
          method_Call_1!(SpinEdit_SetMaxLength, self.0, aValue);
      }

	  pub fn MaxValue(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetMaxValue, self.0);
      }

	  pub fn SetMaxValue(&self, aValue: i32)  {
          method_Call_1!(SpinEdit_SetMaxValue, self.0, aValue);
      }

	  pub fn MinValue(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetMinValue, self.0);
      }

	  pub fn SetMinValue(&self, aValue: i32)  {
          method_Call_1!(SpinEdit_SetMinValue, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(SpinEdit_SetParentColor, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(SpinEdit_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(SpinEdit_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, SpinEdit_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(SpinEdit_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ReadOnly(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetReadOnly, self.0);
      }

	  pub fn SetReadOnly(&self, aValue: bool)  {
          method_Call_1!(SpinEdit_SetReadOnly, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(SpinEdit_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(SpinEdit_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(SpinEdit_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(SpinEdit_SetTabStop, self.0, aValue);
      }

	  pub fn Value(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetValue, self.0);
      }

	  pub fn SetValue(&self, aValue: i32)  {
          method_Call_1!(SpinEdit_SetValue, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(SpinEdit_SetVisible, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(SpinEdit_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(SpinEdit_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(SpinEdit_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(SpinEdit_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(SpinEdit_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(SpinEdit_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(SpinEdit_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(SpinEdit_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(SpinEdit_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(SpinEdit_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(SpinEdit_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(SpinEdit_SetAlignment, self.0, aValue);
      }

	  pub fn CanUndo(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetCanUndo, self.0);
      }

	  pub fn Modified(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetModified, self.0);
      }

	  pub fn SetModified(&self, aValue: bool)  {
          method_Call_1!(SpinEdit_SetModified, self.0, aValue);
      }

	  pub fn SelLength(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetSelLength, self.0);
      }

	  pub fn SetSelLength(&self, aValue: i32)  {
          method_Call_1!(SpinEdit_SetSelLength, self.0, aValue);
      }

	  pub fn SelStart(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetSelStart, self.0);
      }

	  pub fn SetSelStart(&self, aValue: i32)  {
          method_Call_1!(SpinEdit_SetSelStart, self.0, aValue);
      }

	  pub fn SelText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SpinEdit_GetSelText, self.0));
      }

	  pub fn SetSelText(&self, aValue: &str)  {
          method_Call_1!(SpinEdit_SetSelText, self.0, to_CString!(aValue));
      }

	  pub fn Text<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SpinEdit_GetText, self.0));
      }

	  pub fn SetText(&self, aValue: &str)  {
          method_Call_1!(SpinEdit_SetText, self.0, to_CString!(aValue));
      }

	  pub fn TextHint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SpinEdit_GetTextHint, self.0));
      }

	  pub fn SetTextHint(&self, aValue: &str)  {
          method_Call_1!(SpinEdit_SetTextHint, self.0, to_CString!(aValue));
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(SpinEdit_SetDockSite, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(SpinEdit_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, SpinEdit_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(SpinEdit_GetHandle, self.0);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(SpinEdit_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(SpinEdit_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(SpinEdit_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(SpinEdit_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, SpinEdit_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(SpinEdit_SetAction, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(SpinEdit_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(SpinEdit_SetAlign, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(SpinEdit_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(SpinEdit_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(SpinEdit_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(SpinEdit_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(SpinEdit_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(SpinEdit_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(SpinEdit_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(SpinEdit_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(SpinEdit_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(SpinEdit_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(SpinEdit_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(SpinEdit_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(SpinEdit_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, SpinEdit_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(SpinEdit_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(SpinEdit_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(SpinEdit_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(SpinEdit_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(SpinEdit_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(SpinEdit_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(SpinEdit_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SpinEdit_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(SpinEdit_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(SpinEdit_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(SpinEdit_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, SpinEdit_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SpinEdit_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(SpinEdit_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(SpinEdit_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(SpinEdit_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, SpinEdit_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(SpinEdit_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, SpinEdit_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(SpinEdit_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, SpinEdit_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(SpinEdit_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, SpinEdit_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(SpinEdit_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, SpinEdit_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(SpinEdit_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, SpinEdit_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(SpinEdit_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, SpinEdit_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, SpinEdit_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, SpinEdit_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, SpinEdit_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(SpinEdit_StaticClassType);
}

impl_IObject!(TSpinEdit);
impl_IComponent!(TSpinEdit);
impl_IControl!(TSpinEdit);
impl_IWinControl!(TSpinEdit);

impl TMiniWebview {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TMiniWebview, MiniWebview_Create, aOwner.Instance());
      }

      impl_As_method!(TMiniWebview);

	  impl_Free_method!(MiniWebview_Free);

	  pub fn Navigate(&self, aURL: &str)  {
          method_Call_1!(MiniWebview_Navigate, self.0, to_CString!(aURL));
      }

	  pub fn GoBack(&self)  {
          method_Call_1!(MiniWebview_GoBack, self.0);
      }

	  pub fn GoForward(&self)  {
          method_Call_1!(MiniWebview_GoForward, self.0);
      }

	  pub fn GoHome(&self)  {
          method_Call_1!(MiniWebview_GoHome, self.0);
      }

	  pub fn GoSearch(&self)  {
          method_Call_1!(MiniWebview_GoSearch, self.0);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(MiniWebview_Refresh, self.0);
      }

	  pub fn Stop(&self)  {
          method_Call_1!(MiniWebview_Stop, self.0);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(MiniWebview_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn ExecuteScript<'a>(&self, aScriptText: &str, aScriptType: &str) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MiniWebview_ExecuteScript, self.0, to_CString!(aScriptText), to_CString!(aScriptType)));
      }

	  pub fn ExecuteJS<'a>(&self, aScriptText: &str) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MiniWebview_ExecuteJS, self.0, to_CString!(aScriptText)));
      }

	  pub fn LoadHTML(&self, aStr: &str)  {
          method_Call_1!(MiniWebview_LoadHTML, self.0, to_CString!(aStr));
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(MiniWebview_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(MiniWebview_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, MiniWebview_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(MiniWebview_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(MiniWebview_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, MiniWebview_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(MiniWebview_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(MiniWebview_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(MiniWebview_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(MiniWebview_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(MiniWebview_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(MiniWebview_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(MiniWebview_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(MiniWebview_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(MiniWebview_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(MiniWebview_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(MiniWebview_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(MiniWebview_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(MiniWebview_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(MiniWebview_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(MiniWebview_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(MiniWebview_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(MiniWebview_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(MiniWebview_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(MiniWebview_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(MiniWebview_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(MiniWebview_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(MiniWebview_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(MiniWebview_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(MiniWebview_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(MiniWebview_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(MiniWebview_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, MiniWebview_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MiniWebview_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(MiniWebview_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(MiniWebview_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MiniWebview_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(MiniWebview_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(MiniWebview_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(MiniWebview_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(MiniWebview_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MiniWebview_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(MiniWebview_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(MiniWebview_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(MiniWebview_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(MiniWebview_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(MiniWebview_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(MiniWebview_AnchorClient, self.0, aSpace);
      }

	  pub fn ReadyState(&self) -> TReadyState  {
          return method_Call_1!(MiniWebview_GetReadyState, self.0);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(MiniWebview_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(MiniWebview_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(MiniWebview_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(MiniWebview_SetAnchors, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, MiniWebview_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(MiniWebview_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(MiniWebview_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(MiniWebview_SetEnabled, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(MiniWebview_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(MiniWebview_SetVisible, self.0, aValue);
      }

	  pub fn SetOnTitleChange(&self, aEventId: TWebTitleChangeEvent)  {
          method_Call_1!(MiniWebview_SetOnTitleChange, self.0, aEventId);
      }

	  pub fn SetOnJSExternal(&self, aEventId: TWebJSExternalEvent)  {
          method_Call_1!(MiniWebview_SetOnJSExternal, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(MiniWebview_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(MiniWebview_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(MiniWebview_SetDockSite, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(MiniWebview_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(MiniWebview_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(MiniWebview_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(MiniWebview_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, MiniWebview_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(MiniWebview_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(MiniWebview_GetHandle, self.0);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(MiniWebview_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(MiniWebview_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(MiniWebview_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(MiniWebview_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(MiniWebview_GetShowing, self.0);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(MiniWebview_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(MiniWebview_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(MiniWebview_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(MiniWebview_SetTabStop, self.0, aValue);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(MiniWebview_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(MiniWebview_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, MiniWebview_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(MiniWebview_SetAction, self.0, aValue.Instance());
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(MiniWebview_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(MiniWebview_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(MiniWebview_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(MiniWebview_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(MiniWebview_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(MiniWebview_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(MiniWebview_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(MiniWebview_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(MiniWebview_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(MiniWebview_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(MiniWebview_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(MiniWebview_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(MiniWebview_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(MiniWebview_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(MiniWebview_GetFloating, self.0);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(MiniWebview_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(MiniWebview_SetShowHint, self.0, aValue);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, MiniWebview_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(MiniWebview_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(MiniWebview_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(MiniWebview_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(MiniWebview_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(MiniWebview_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(MiniWebview_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(MiniWebview_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(MiniWebview_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(MiniWebview_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(MiniWebview_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(MiniWebview_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MiniWebview_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(MiniWebview_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(MiniWebview_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(MiniWebview_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(MiniWebview_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, MiniWebview_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MiniWebview_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(MiniWebview_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(MiniWebview_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(MiniWebview_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, MiniWebview_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(MiniWebview_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, MiniWebview_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(MiniWebview_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, MiniWebview_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(MiniWebview_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, MiniWebview_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(MiniWebview_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, MiniWebview_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(MiniWebview_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, MiniWebview_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(MiniWebview_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, MiniWebview_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, MiniWebview_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, MiniWebview_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, MiniWebview_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(MiniWebview_StaticClassType);
}

impl_IObject!(TMiniWebview);
impl_IComponent!(TMiniWebview);
impl_IControl!(TMiniWebview);
impl_IWinControl!(TMiniWebview);

impl TCanvas {
      pub fn new() -> Self {
        method_Create!(TCanvas, Canvas_Create, );
      }

      impl_As_method!(TCanvas);

	  impl_Free_method!(Canvas_Free);

	  pub fn Arc(&self, x1: i32, y1: i32, x2: i32, y2: i32, x3: i32, y3: i32, x4: i32, y4: i32)  {
          method_Call_1!(Canvas_Arc, self.0, x1, y1, x2, y2, x3, y3, x4, y4);
      }

	  pub fn ArcTo(&self, x1: i32, y1: i32, x2: i32, y2: i32, x3: i32, y3: i32, x4: i32, y4: i32)  {
          method_Call_1!(Canvas_ArcTo, self.0, x1, y1, x2, y2, x3, y3, x4, y4);
      }

	  pub fn AngleArc(&self, x: i32, y: i32, radius: u32, startAngle: f32, sweepAngle: f32)  {
          let mut ps4 = startAngle;
          let mut ps5 = sweepAngle;
          method_Call_1!(Canvas_AngleArc, self.0, x, y, radius, &mut ps4, &mut ps5);
      }

	  pub fn Chord(&self, x1: i32, y1: i32, x2: i32, y2: i32, x3: i32, y3: i32, x4: i32, y4: i32)  {
          method_Call_1!(Canvas_Chord, self.0, x1, y1, x2, y2, x3, y3, x4, y4);
      }

	  pub fn Ellipse(&self, x1: i32, y1: i32, x2: i32, y2: i32)  {
          method_Call_1!(Canvas_Ellipse, self.0, x1, y1, x2, y2);
      }

	  pub fn FloodFill(&self, x: i32, y: i32, color: TColor, fillStyle: TFillStyle)  {
          method_Call_1!(Canvas_FloodFill, self.0, x, y, color, fillStyle);
      }

	  pub fn HandleAllocated(&self) -> bool  {
          return method_Call_1!(Canvas_HandleAllocated, self.0);
      }

	  pub fn LineTo(&self, x: i32, y: i32)  {
          method_Call_1!(Canvas_LineTo, self.0, x, y);
      }

	  pub fn MoveTo(&self, x: i32, y: i32)  {
          method_Call_1!(Canvas_MoveTo, self.0, x, y);
      }

	  pub fn Pie(&self, x1: i32, y1: i32, x2: i32, y2: i32, x3: i32, y3: i32, x4: i32, y4: i32)  {
          method_Call_1!(Canvas_Pie, self.0, x1, y1, x2, y2, x3, y3, x4, y4);
      }

	  pub fn Rectangle(&self, x1: i32, y1: i32, x2: i32, y2: i32)  {
          method_Call_1!(Canvas_Rectangle, self.0, x1, y1, x2, y2);
      }

	  pub fn Refresh(&self)  {
          method_Call_1!(Canvas_Refresh, self.0);
      }

	  pub fn RoundRect(&self, x1: i32, y1: i32, x2: i32, y2: i32, x3: i32, y3: i32)  {
          method_Call_1!(Canvas_RoundRect, self.0, x1, y1, x2, y2, x3, y3);
      }

	  pub fn TextExtent(&self, text: &str) -> TSize  {
          let mut result = TSize::Empty();
          method_Call_1!(Canvas_TextExtent, self.0, to_CString!(text), &mut result);
          return result;
      }

	  pub fn TextOut(&self, x: i32, y: i32, text: &str)  {
          method_Call_1!(Canvas_TextOut, self.0, x, y, to_CString!(text));
      }

	  pub fn Lock(&self)  {
          method_Call_1!(Canvas_Lock, self.0);
      }

	  pub fn TextHeight(&self, text: &str) -> i32  {
          return method_Call_1!(Canvas_TextHeight, self.0, to_CString!(text));
      }

	  pub fn TextWidth(&self, text: &str) -> i32  {
          return method_Call_1!(Canvas_TextWidth, self.0, to_CString!(text));
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(Canvas_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Canvas_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Canvas_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Canvas_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Canvas_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Canvas_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Canvas_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Canvas_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Canvas_ToString, self.0));
      }

	  pub fn Handle(&self) -> HDC  {
          return method_Call_1!(Canvas_GetHandle, self.0);
      }

	  pub fn SetHandle(&self, aValue: HDC)  {
          method_Call_1!(Canvas_SetHandle, self.0, aValue);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, Canvas_GetBrush, self.0);
      }

	  pub fn SetBrush(&self, aValue: &TBrush)  {
          method_Call_1!(Canvas_SetBrush, self.0, aValue.Instance());
      }

	  pub fn CopyMode(&self) -> i32  {
          return method_Call_1!(Canvas_GetCopyMode, self.0);
      }

	  pub fn SetCopyMode(&self, aValue: i32)  {
          method_Call_1!(Canvas_SetCopyMode, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, Canvas_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(Canvas_SetFont, self.0, aValue.Instance());
      }

	  pub fn Pen(&self) -> TPen  {
          return method_Call_2!(TPen, Canvas_GetPen, self.0);
      }

	  pub fn SetPen(&self, aValue: &TPen)  {
          method_Call_1!(Canvas_SetPen, self.0, aValue.Instance());
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Canvas_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnChanging(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Canvas_SetOnChanging, self.0, aEventId);
      }

      // static class
	  impl_Class_method!(Canvas_StaticClassType);
	  pub fn BrushCopy(&self, dest: &TRect, bitmap: &TBitmap, source: &TRect, color: TColor)  {
          let mut ps1 = TRect::From(dest);
          let mut ps3 = TRect::From(source);
          method_Call_1!(Canvas_BrushCopy, self.0, &mut ps1, bitmap.Instance(), &mut ps3, color);
      }

	  pub fn CopyRect(&self, dest: &TRect, canvas: &TCanvas, source: &TRect)  {
          let mut ps1 = TRect::From(dest);
          let mut ps3 = TRect::From(source);
          method_Call_1!(Canvas_CopyRect, self.0, &mut ps1, canvas.Instance(), &mut ps3);
      }

	  pub fn Draw1(&self, x: i32, y: i32, graphic: &TGraphic)  {
          method_Call_1!(Canvas_Draw1, self.0, x, y, graphic.Instance());
      }

	  pub fn Draw2(&self, x: i32, y: i32, graphic: &TGraphic, opacity: i8)  {
          method_Call_1!(Canvas_Draw2, self.0, x, y, graphic.Instance(), opacity);
      }

	  pub fn DrawFocusRect(&self, aRect: &TRect)  {
          let mut ps1 = TRect::From(aRect);
          method_Call_1!(Canvas_DrawFocusRect, self.0, &mut ps1);
      }

	  pub fn FillRect(&self, rect: &TRect)  {
          let mut ps1 = TRect::From(rect);
          method_Call_1!(Canvas_FillRect, self.0, &mut ps1);
      }

	  pub fn FrameRect(&self, rect: &TRect)  {
          let mut ps1 = TRect::From(rect);
          method_Call_1!(Canvas_FrameRect, self.0, &mut ps1);
      }

	  pub fn StretchDraw(&self, rect: &TRect, graphic: &TGraphic)  {
          let mut ps1 = TRect::From(rect);
          method_Call_1!(Canvas_StretchDraw, self.0, &mut ps1, graphic.Instance());
      }

	  pub fn TextRect1(&self, rect: &TRect, x: i32, y: i32, text: &str)  {
          let mut ps1 = TRect::From(rect);
          method_Call_1!(Canvas_TextRect1, self.0, &mut ps1, x, y, to_CString!(text));
      }


	  pub fn Polygon(&self, aPoints: *mut TPoint, aLen: i32)  {
          method_Call_1!(Canvas_Polygon, self.0, aPoints, aLen);
      }

	  pub fn Polyline(&self, aPoints: *mut TPoint, aLen: i32)  {
          method_Call_1!(Canvas_Polyline, self.0, aPoints, aLen);
      }

	  pub fn PolyBezier(&self, aPoints: *mut TPoint, aLen: i32)  {
          method_Call_1!(Canvas_PolyBezier, self.0, aPoints, aLen);
      }

	  pub fn Pixels(&self, x: i32, y: i32) -> TColor  {
          return method_Call_1!(Canvas_Pixels, self.0, x, y);
      }

	  pub fn SetPixels(&self, x: i32, y: i32, aColor: TColor)  {
          method_Call_1!(Canvas_SetPixels, self.0, x, y, aColor);
      }

}

impl_IObject!(TCanvas);
impl_Drop_method!(TCanvas);

impl TApplication {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TApplication, Application_Create, aOwner.Instance());
      }

      impl_As_method!(TApplication);

	  impl_Free_method!(Application_Free);

	  pub fn ActivateHint(&self, cursorPos: &TPoint)  {
          let mut ps1 = TPoint::From(cursorPos);
          method_Call_1!(Application_ActivateHint, self.0, &mut ps1);
      }

	  pub fn BringToFront(&self)  {
          method_Call_1!(Application_BringToFront, self.0);
      }

	  pub fn CancelHint(&self)  {
          method_Call_1!(Application_CancelHint, self.0);
      }

	  pub fn HandleMessage(&self)  {
          method_Call_1!(Application_HandleMessage, self.0);
      }

	  pub fn HideHint(&self)  {
          method_Call_1!(Application_HideHint, self.0);
      }

	  pub fn Minimize(&self)  {
          method_Call_1!(Application_Minimize, self.0);
      }

	  pub fn ModalStarted(&self)  {
          method_Call_1!(Application_ModalStarted, self.0);
      }

	  pub fn ModalFinished(&self)  {
          method_Call_1!(Application_ModalFinished, self.0);
      }

	  pub fn ProcessMessages(&self)  {
          method_Call_1!(Application_ProcessMessages, self.0);
      }

	  pub fn Restore(&self)  {
          method_Call_1!(Application_Restore, self.0);
      }

	  pub fn RestoreTopMosts(&self)  {
          method_Call_1!(Application_RestoreTopMosts, self.0);
      }

	  pub fn Terminate(&self)  {
          method_Call_1!(Application_Terminate, self.0);
      }

	  pub fn MessageBox(&self, text: &str, caption: &str, flags: i32) -> i32  {
          return method_Call_1!(Application_MessageBox, self.0, to_CString!(text), to_CString!(caption), flags);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Application_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Application_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Application_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Application_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Application_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Application_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Application_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Application_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Application_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Application_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Application_ToString, self.0));
      }

	  pub fn Scaled(&self) -> bool  {
          return method_Call_1!(Application_GetScaled, self.0);
      }

	  pub fn SetScaled(&self, aValue: bool)  {
          method_Call_1!(Application_SetScaled, self.0, aValue);
      }

	  pub fn SingleInstanceEnabled(&self) -> bool  {
          return method_Call_1!(Application_GetSingleInstanceEnabled, self.0);
      }

	  pub fn SetSingleInstanceEnabled(&self, aValue: bool)  {
          method_Call_1!(Application_SetSingleInstanceEnabled, self.0, aValue);
      }

	  pub fn Location<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Application_GetLocation, self.0));
      }

	  pub fn StopOnException(&self) -> bool  {
          return method_Call_1!(Application_GetStopOnException, self.0);
      }

	  pub fn SetStopOnException(&self, aValue: bool)  {
          method_Call_1!(Application_SetStopOnException, self.0, aValue);
      }

	  pub fn ExceptionExitCode(&self) -> i32  {
          return method_Call_1!(Application_GetExceptionExitCode, self.0);
      }

	  pub fn SetExceptionExitCode(&self, aValue: i32)  {
          method_Call_1!(Application_SetExceptionExitCode, self.0, aValue);
      }

	  pub fn ExeName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Application_GetExeName, self.0));
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Application_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(Application_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn HintColor(&self) -> TColor  {
          return method_Call_1!(Application_GetHintColor, self.0);
      }

	  pub fn SetHintColor(&self, aValue: TColor)  {
          method_Call_1!(Application_SetHintColor, self.0, aValue);
      }

	  pub fn HintHidePause(&self) -> i32  {
          return method_Call_1!(Application_GetHintHidePause, self.0);
      }

	  pub fn SetHintHidePause(&self, aValue: i32)  {
          method_Call_1!(Application_SetHintHidePause, self.0, aValue);
      }

	  pub fn HintPause(&self) -> i32  {
          return method_Call_1!(Application_GetHintPause, self.0);
      }

	  pub fn SetHintPause(&self, aValue: i32)  {
          method_Call_1!(Application_SetHintPause, self.0, aValue);
      }

	  pub fn HintShortCuts(&self) -> bool  {
          return method_Call_1!(Application_GetHintShortCuts, self.0);
      }

	  pub fn SetHintShortCuts(&self, aValue: bool)  {
          method_Call_1!(Application_SetHintShortCuts, self.0, aValue);
      }

	  pub fn HintShortPause(&self) -> i32  {
          return method_Call_1!(Application_GetHintShortPause, self.0);
      }

	  pub fn SetHintShortPause(&self, aValue: i32)  {
          method_Call_1!(Application_SetHintShortPause, self.0, aValue);
      }

	  pub fn Icon(&self) -> TIcon  {
          return method_Call_2!(TIcon, Application_GetIcon, self.0);
      }

	  pub fn SetIcon(&self, aValue: &TIcon)  {
          method_Call_1!(Application_SetIcon, self.0, aValue.Instance());
      }

	  pub fn MainForm(&self) -> TForm  {
          return method_Call_2!(TForm, Application_GetMainForm, self.0);
      }

	  pub fn MainFormHandle(&self) -> HWND  {
          return method_Call_1!(Application_GetMainFormHandle, self.0);
      }

	  pub fn MainFormOnTaskBar(&self) -> bool  {
          return method_Call_1!(Application_GetMainFormOnTaskBar, self.0);
      }

	  pub fn SetMainFormOnTaskBar(&self, aValue: bool)  {
          method_Call_1!(Application_SetMainFormOnTaskBar, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(Application_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(Application_SetBiDiMode, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(Application_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(Application_SetShowHint, self.0, aValue);
      }

	  pub fn ShowMainForm(&self) -> bool  {
          return method_Call_1!(Application_GetShowMainForm, self.0);
      }

	  pub fn SetShowMainForm(&self, aValue: bool)  {
          method_Call_1!(Application_SetShowMainForm, self.0, aValue);
      }

	  pub fn Title<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Application_GetTitle, self.0));
      }

	  pub fn SetTitle(&self, aValue: &str)  {
          method_Call_1!(Application_SetTitle, self.0, to_CString!(aValue));
      }

	  pub fn SetOnActivate(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Application_SetOnActivate, self.0, aEventId);
      }

	  pub fn SetOnDeactivate(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Application_SetOnDeactivate, self.0, aEventId);
      }

	  pub fn SetOnException(&self, aEventId: TExceptionEvent)  {
          method_Call_1!(Application_SetOnException, self.0, aEventId);
      }

	  pub fn SetOnHelp(&self, aEventId: THelpEvent)  {
          method_Call_1!(Application_SetOnHelp, self.0, aEventId);
      }

	  pub fn SetOnHint(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Application_SetOnHint, self.0, aEventId);
      }

	  pub fn SetOnMinimize(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Application_SetOnMinimize, self.0, aEventId);
      }

	  pub fn SetOnRestore(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Application_SetOnRestore, self.0, aEventId);
      }

	  pub fn SetOnShortCut(&self, aEventId: TShortCutEvent)  {
          method_Call_1!(Application_SetOnShortCut, self.0, aEventId);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(Application_GetHandle, self.0);
      }

	  pub fn SetHandle(&self, aValue: HWND)  {
          method_Call_1!(Application_SetHandle, self.0, aValue);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Application_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Application_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Application_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Application_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Application_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Application_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Application_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Application_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Application_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(Application_StaticClassType);
	  pub fn Initialize(&self)  {
          method_Call_1!(Application_Initialize, self.0);
      }

      pub fn CreateForm(&self) -> TForm  {
	      return method_Call_2!(TForm, Application_CreateForm, self.0, false);
      }

	  pub fn Run(&self)  {
          method_Call_1!(Application_Run, self.0);
      }

}

impl_IObject!(TApplication);
impl_IComponent!(TApplication);

impl TGraphic {
      pub fn new() -> Self {
        method_Create!(TGraphic, Graphic_Create, );
      }

      impl_As_method!(TGraphic);

	  impl_Free_method!(Graphic_Free);

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Graphic_Equals, self.0, obj.Instance());
      }

	  pub fn LoadFromFile(&self, filename: &str)  {
          method_Call_1!(Graphic_LoadFromFile, self.0, to_CString!(filename));
      }

	  pub fn SaveToFile(&self, filename: &str)  {
          method_Call_1!(Graphic_SaveToFile, self.0, to_CString!(filename));
      }

	  pub fn LoadFromStream(&self, stream: &dyn IObject)  {
          method_Call_1!(Graphic_LoadFromStream, self.0, stream.Instance());
      }

	  pub fn SaveToStream(&self, stream: &dyn IObject)  {
          method_Call_1!(Graphic_SaveToStream, self.0, stream.Instance());
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(Graphic_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Graphic_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Graphic_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Graphic_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Graphic_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Graphic_InheritsFrom, self.0, aClass);
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Graphic_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Graphic_ToString, self.0));
      }

	  pub fn Empty(&self) -> bool  {
          return method_Call_1!(Graphic_GetEmpty, self.0);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Graphic_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Graphic_SetHeight, self.0, aValue);
      }

	  pub fn Modified(&self) -> bool  {
          return method_Call_1!(Graphic_GetModified, self.0);
      }

	  pub fn SetModified(&self, aValue: bool)  {
          method_Call_1!(Graphic_SetModified, self.0, aValue);
      }

	  pub fn Palette(&self) -> HPALETTE  {
          return method_Call_1!(Graphic_GetPalette, self.0);
      }

	  pub fn SetPalette(&self, aValue: HPALETTE)  {
          method_Call_1!(Graphic_SetPalette, self.0, aValue);
      }

	  pub fn PaletteModified(&self) -> bool  {
          return method_Call_1!(Graphic_GetPaletteModified, self.0);
      }

	  pub fn SetPaletteModified(&self, aValue: bool)  {
          method_Call_1!(Graphic_SetPaletteModified, self.0, aValue);
      }

	  pub fn Transparent(&self) -> bool  {
          return method_Call_1!(Graphic_GetTransparent, self.0);
      }

	  pub fn SetTransparent(&self, aValue: bool)  {
          method_Call_1!(Graphic_SetTransparent, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Graphic_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Graphic_SetWidth, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Graphic_SetOnChange, self.0, aEventId);
      }

      // static class
	  impl_Class_method!(Graphic_StaticClassType);
}

impl_IObject!(TGraphic);
impl_Drop_method!(TGraphic);

impl TPngImage {
      pub fn new() -> Self {
        method_Create!(TPngImage, PngImage_Create, );
      }

      impl_As_method!(TPngImage);

	  impl_Free_method!(PngImage_Free);

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(PngImage_Assign, self.0, source.Instance());
      }

	  pub fn LoadFromStream(&self, stream: &dyn IObject)  {
          method_Call_1!(PngImage_LoadFromStream, self.0, stream.Instance());
      }

	  pub fn SaveToStream(&self, stream: &dyn IObject)  {
          method_Call_1!(PngImage_SaveToStream, self.0, stream.Instance());
      }

	  pub fn LoadFromResourceName(&self, instance: usize, name: &str)  {
          method_Call_1!(PngImage_LoadFromResourceName, self.0, instance, to_CString!(name));
      }

	  pub fn LoadFromResourceID(&self, instance: usize, resID: i32)  {
          method_Call_1!(PngImage_LoadFromResourceID, self.0, instance, resID);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(PngImage_Equals, self.0, obj.Instance());
      }

	  pub fn LoadFromFile(&self, filename: &str)  {
          method_Call_1!(PngImage_LoadFromFile, self.0, to_CString!(filename));
      }

	  pub fn SaveToFile(&self, filename: &str)  {
          method_Call_1!(PngImage_SaveToFile, self.0, to_CString!(filename));
      }

	  pub fn SetSize(&self, aWidth: i32, aHeight: i32)  {
          method_Call_1!(PngImage_SetSize, self.0, aWidth, aHeight);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(PngImage_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(PngImage_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PngImage_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(PngImage_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(PngImage_InheritsFrom, self.0, aClass);
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(PngImage_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PngImage_ToString, self.0));
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, PngImage_GetCanvas, self.0);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(PngImage_GetWidth, self.0);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(PngImage_GetHeight, self.0);
      }

	  pub fn Empty(&self) -> bool  {
          return method_Call_1!(PngImage_GetEmpty, self.0);
      }

	  pub fn Modified(&self) -> bool  {
          return method_Call_1!(PngImage_GetModified, self.0);
      }

	  pub fn SetModified(&self, aValue: bool)  {
          method_Call_1!(PngImage_SetModified, self.0, aValue);
      }

	  pub fn Palette(&self) -> HPALETTE  {
          return method_Call_1!(PngImage_GetPalette, self.0);
      }

	  pub fn SetPalette(&self, aValue: HPALETTE)  {
          method_Call_1!(PngImage_SetPalette, self.0, aValue);
      }

	  pub fn PaletteModified(&self) -> bool  {
          return method_Call_1!(PngImage_GetPaletteModified, self.0);
      }

	  pub fn SetPaletteModified(&self, aValue: bool)  {
          method_Call_1!(PngImage_SetPaletteModified, self.0, aValue);
      }

	  pub fn Transparent(&self) -> bool  {
          return method_Call_1!(PngImage_GetTransparent, self.0);
      }

	  pub fn SetTransparent(&self, aValue: bool)  {
          method_Call_1!(PngImage_SetTransparent, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PngImage_SetOnChange, self.0, aEventId);
      }

      // static class
	  impl_Class_method!(PngImage_StaticClassType);
}

impl_IObject!(TPngImage);
impl_Drop_method!(TPngImage);

impl TJPEGImage {
      pub fn new() -> Self {
        method_Create!(TJPEGImage, JPEGImage_Create, );
      }

      impl_As_method!(TJPEGImage);

	  impl_Free_method!(JPEGImage_Free);

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(JPEGImage_Assign, self.0, source.Instance());
      }

	  pub fn LoadFromStream(&self, stream: &dyn IObject)  {
          method_Call_1!(JPEGImage_LoadFromStream, self.0, stream.Instance());
      }

	  pub fn SaveToStream(&self, stream: &dyn IObject)  {
          method_Call_1!(JPEGImage_SaveToStream, self.0, stream.Instance());
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(JPEGImage_Equals, self.0, obj.Instance());
      }

	  pub fn LoadFromFile(&self, filename: &str)  {
          method_Call_1!(JPEGImage_LoadFromFile, self.0, to_CString!(filename));
      }

	  pub fn SaveToFile(&self, filename: &str)  {
          method_Call_1!(JPEGImage_SaveToFile, self.0, to_CString!(filename));
      }

	  pub fn SetSize(&self, aWidth: i32, aHeight: i32)  {
          method_Call_1!(JPEGImage_SetSize, self.0, aWidth, aHeight);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(JPEGImage_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(JPEGImage_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(JPEGImage_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(JPEGImage_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(JPEGImage_InheritsFrom, self.0, aClass);
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(JPEGImage_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(JPEGImage_ToString, self.0));
      }

	  pub fn PixelFormat(&self) -> TPixelFormat  {
          return method_Call_1!(JPEGImage_GetPixelFormat, self.0);
      }

	  pub fn SetPixelFormat(&self, aValue: TJPEGPixelFormat)  {
          method_Call_1!(JPEGImage_SetPixelFormat, self.0, aValue);
      }

	  pub fn Performance(&self) -> TJPEGPerformance  {
          return method_Call_1!(JPEGImage_GetPerformance, self.0);
      }

	  pub fn SetPerformance(&self, aValue: TJPEGPerformance)  {
          method_Call_1!(JPEGImage_SetPerformance, self.0, aValue);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, JPEGImage_GetCanvas, self.0);
      }

	  pub fn Empty(&self) -> bool  {
          return method_Call_1!(JPEGImage_GetEmpty, self.0);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(JPEGImage_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(JPEGImage_SetHeight, self.0, aValue);
      }

	  pub fn Modified(&self) -> bool  {
          return method_Call_1!(JPEGImage_GetModified, self.0);
      }

	  pub fn SetModified(&self, aValue: bool)  {
          method_Call_1!(JPEGImage_SetModified, self.0, aValue);
      }

	  pub fn Palette(&self) -> HPALETTE  {
          return method_Call_1!(JPEGImage_GetPalette, self.0);
      }

	  pub fn SetPalette(&self, aValue: HPALETTE)  {
          method_Call_1!(JPEGImage_SetPalette, self.0, aValue);
      }

	  pub fn PaletteModified(&self) -> bool  {
          return method_Call_1!(JPEGImage_GetPaletteModified, self.0);
      }

	  pub fn SetPaletteModified(&self, aValue: bool)  {
          method_Call_1!(JPEGImage_SetPaletteModified, self.0, aValue);
      }

	  pub fn Transparent(&self) -> bool  {
          return method_Call_1!(JPEGImage_GetTransparent, self.0);
      }

	  pub fn SetTransparent(&self, aValue: bool)  {
          method_Call_1!(JPEGImage_SetTransparent, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(JPEGImage_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(JPEGImage_SetWidth, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(JPEGImage_SetOnChange, self.0, aEventId);
      }

      // static class
	  impl_Class_method!(JPEGImage_StaticClassType);
}

impl_IObject!(TJPEGImage);
impl_Drop_method!(TJPEGImage);

impl TGIFImage {
      pub fn new() -> Self {
        method_Create!(TGIFImage, GIFImage_Create, );
      }

      impl_As_method!(TGIFImage);

	  impl_Free_method!(GIFImage_Free);

	  pub fn SaveToStream(&self, stream: &dyn IObject)  {
          method_Call_1!(GIFImage_SaveToStream, self.0, stream.Instance());
      }

	  pub fn LoadFromStream(&self, stream: &dyn IObject)  {
          method_Call_1!(GIFImage_LoadFromStream, self.0, stream.Instance());
      }

	  pub fn Clear(&self)  {
          method_Call_1!(GIFImage_Clear, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(GIFImage_Assign, self.0, source.Instance());
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(GIFImage_Equals, self.0, obj.Instance());
      }

	  pub fn LoadFromFile(&self, filename: &str)  {
          method_Call_1!(GIFImage_LoadFromFile, self.0, to_CString!(filename));
      }

	  pub fn SaveToFile(&self, filename: &str)  {
          method_Call_1!(GIFImage_SaveToFile, self.0, to_CString!(filename));
      }

	  pub fn SetSize(&self, aWidth: i32, aHeight: i32)  {
          method_Call_1!(GIFImage_SetSize, self.0, aWidth, aHeight);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(GIFImage_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(GIFImage_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(GIFImage_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(GIFImage_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(GIFImage_InheritsFrom, self.0, aClass);
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(GIFImage_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(GIFImage_ToString, self.0));
      }

	  pub fn BitsPerPixel(&self) -> i32  {
          return method_Call_1!(GIFImage_GetBitsPerPixel, self.0);
      }

	  pub fn Empty(&self) -> bool  {
          return method_Call_1!(GIFImage_GetEmpty, self.0);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(GIFImage_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(GIFImage_SetHeight, self.0, aValue);
      }

	  pub fn Modified(&self) -> bool  {
          return method_Call_1!(GIFImage_GetModified, self.0);
      }

	  pub fn SetModified(&self, aValue: bool)  {
          method_Call_1!(GIFImage_SetModified, self.0, aValue);
      }

	  pub fn Palette(&self) -> HPALETTE  {
          return method_Call_1!(GIFImage_GetPalette, self.0);
      }

	  pub fn SetPalette(&self, aValue: HPALETTE)  {
          method_Call_1!(GIFImage_SetPalette, self.0, aValue);
      }

	  pub fn PaletteModified(&self) -> bool  {
          return method_Call_1!(GIFImage_GetPaletteModified, self.0);
      }

	  pub fn SetPaletteModified(&self, aValue: bool)  {
          method_Call_1!(GIFImage_SetPaletteModified, self.0, aValue);
      }

	  pub fn Transparent(&self) -> bool  {
          return method_Call_1!(GIFImage_GetTransparent, self.0);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(GIFImage_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(GIFImage_SetWidth, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(GIFImage_SetOnChange, self.0, aEventId);
      }

      // static class
	  impl_Class_method!(GIFImage_StaticClassType);
}

impl_IObject!(TGIFImage);
impl_Drop_method!(TGIFImage);

impl TActionList {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TActionList, ActionList_Create, aOwner.Instance());
      }

      impl_As_method!(TActionList);

	  impl_Free_method!(ActionList_Free);

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ActionList_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ActionList_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ActionList_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ActionList_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ActionList_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ActionList_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ActionList_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ActionList_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ActionList_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ActionList_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ActionList_ToString, self.0));
      }

	  pub fn Images(&self) -> TImageList  {
          return method_Call_2!(TImageList, ActionList_GetImages, self.0);
      }

	  pub fn SetImages(&self, aValue: &TImageList)  {
          method_Call_1!(ActionList_SetImages, self.0, aValue.Instance());
      }

	  pub fn State(&self) -> TActionListState  {
          return method_Call_1!(ActionList_GetState, self.0);
      }

	  pub fn SetState(&self, aValue: TActionListState)  {
          method_Call_1!(ActionList_SetState, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ActionList_SetOnChange, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ActionList_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ActionList_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ActionList_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ActionList_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ActionList_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ActionList_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ActionList_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ActionList_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ActionList_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(ActionList_StaticClassType);
}

impl_IObject!(TActionList);
impl_IComponent!(TActionList);

impl TAction {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TAction, Action_Create, aOwner.Instance());
      }

      impl_As_method!(TAction);

	  impl_Free_method!(Action_Free);

	  pub fn Execute(&self) -> bool  {
          return method_Call_1!(Action_Execute, self.0);
      }

	  pub fn Update(&self) -> bool  {
          return method_Call_1!(Action_Update, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Action_HasParent, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Action_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Action_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Action_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Action_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Action_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Action_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Action_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Action_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Action_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Action_ToString, self.0));
      }

	  pub fn AutoCheck(&self) -> bool  {
          return method_Call_1!(Action_GetAutoCheck, self.0);
      }

	  pub fn SetAutoCheck(&self, aValue: bool)  {
          method_Call_1!(Action_SetAutoCheck, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Action_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(Action_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Checked(&self) -> bool  {
          return method_Call_1!(Action_GetChecked, self.0);
      }

	  pub fn SetChecked(&self, aValue: bool)  {
          method_Call_1!(Action_SetChecked, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(Action_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(Action_SetEnabled, self.0, aValue);
      }

	  pub fn GroupIndex(&self) -> i32  {
          return method_Call_1!(Action_GetGroupIndex, self.0);
      }

	  pub fn SetGroupIndex(&self, aValue: i32)  {
          method_Call_1!(Action_SetGroupIndex, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Action_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(Action_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ImageIndex(&self) -> i32  {
          return method_Call_1!(Action_GetImageIndex, self.0);
      }

	  pub fn SetImageIndex(&self, aValue: i32)  {
          method_Call_1!(Action_SetImageIndex, self.0, aValue);
      }

	  pub fn ShortCut(&self) -> TShortCut  {
          return method_Call_1!(Action_GetShortCut, self.0);
      }

	  pub fn SetShortCut(&self, aValue: TShortCut)  {
          method_Call_1!(Action_SetShortCut, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(Action_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(Action_SetVisible, self.0, aValue);
      }

	  pub fn SetOnExecute(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Action_SetOnExecute, self.0, aEventId);
      }

	  pub fn SetOnUpdate(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Action_SetOnUpdate, self.0, aEventId);
      }

	  pub fn Index(&self) -> i32  {
          return method_Call_1!(Action_GetIndex, self.0);
      }

	  pub fn SetIndex(&self, aValue: i32)  {
          method_Call_1!(Action_SetIndex, self.0, aValue);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Action_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Action_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Action_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Action_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Action_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Action_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Action_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Action_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Action_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(Action_StaticClassType);
}

impl_IObject!(TAction);
impl_IComponent!(TAction);

impl TToolButton {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TToolButton, ToolButton_Create, aOwner.Instance());
      }

      impl_As_method!(TToolButton);

	  impl_Free_method!(ToolButton_Free);

	  pub fn CheckMenuDropdown(&self) -> bool  {
          return method_Call_1!(ToolButton_CheckMenuDropdown, self.0);
      }

	  pub fn Click(&self)  {
          method_Call_1!(ToolButton_Click, self.0);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(ToolButton_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(ToolButton_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ToolButton_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ToolButton_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(ToolButton_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ToolButton_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(ToolButton_Hide, self.0);
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(ToolButton_Invalidate, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(ToolButton_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(ToolButton_Refresh, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(ToolButton_Repaint, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ToolButton_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ToolButton_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(ToolButton_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(ToolButton_Show, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(ToolButton_Update, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(ToolButton_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(ToolButton_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(ToolButton_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ToolButton_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ToolButton_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ToolButton_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ToolButton_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ToolButton_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ToolButton_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ToolButton_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ToolButton_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ToolButton_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ToolButton_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ToolButton_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ToolButton_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ToolButton_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ToolButton_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(ToolButton_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(ToolButton_AnchorClient, self.0, aSpace);
      }

	  pub fn Index(&self) -> i32  {
          return method_Call_1!(ToolButton_GetIndex, self.0);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, ToolButton_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(ToolButton_SetAction, self.0, aValue.Instance());
      }

	  pub fn AllowAllUp(&self) -> bool  {
          return method_Call_1!(ToolButton_GetAllowAllUp, self.0);
      }

	  pub fn SetAllowAllUp(&self, aValue: bool)  {
          method_Call_1!(ToolButton_SetAllowAllUp, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(ToolButton_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(ToolButton_SetAutoSize, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ToolButton_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(ToolButton_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Down(&self) -> bool  {
          return method_Call_1!(ToolButton_GetDown, self.0);
      }

	  pub fn SetDown(&self, aValue: bool)  {
          method_Call_1!(ToolButton_SetDown, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(ToolButton_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(ToolButton_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(ToolButton_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(ToolButton_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(ToolButton_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(ToolButton_SetDragMode, self.0, aValue);
      }

	  pub fn DropdownMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, ToolButton_GetDropdownMenu, self.0);
      }

	  pub fn SetDropdownMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(ToolButton_SetDropdownMenu, self.0, aValue.Instance());
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(ToolButton_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(ToolButton_SetEnabled, self.0, aValue);
      }

	  pub fn Grouped(&self) -> bool  {
          return method_Call_1!(ToolButton_GetGrouped, self.0);
      }

	  pub fn SetGrouped(&self, aValue: bool)  {
          method_Call_1!(ToolButton_SetGrouped, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(ToolButton_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(ToolButton_SetHeight, self.0, aValue);
      }

	  pub fn ImageIndex(&self) -> i32  {
          return method_Call_1!(ToolButton_GetImageIndex, self.0);
      }

	  pub fn SetImageIndex(&self, aValue: i32)  {
          method_Call_1!(ToolButton_SetImageIndex, self.0, aValue);
      }

	  pub fn Indeterminate(&self) -> bool  {
          return method_Call_1!(ToolButton_GetIndeterminate, self.0);
      }

	  pub fn SetIndeterminate(&self, aValue: bool)  {
          method_Call_1!(ToolButton_SetIndeterminate, self.0, aValue);
      }

	  pub fn Marked(&self) -> bool  {
          return method_Call_1!(ToolButton_GetMarked, self.0);
      }

	  pub fn SetMarked(&self, aValue: bool)  {
          method_Call_1!(ToolButton_SetMarked, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(ToolButton_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(ToolButton_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, ToolButton_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(ToolButton_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn Wrap(&self) -> bool  {
          return method_Call_1!(ToolButton_GetWrap, self.0);
      }

	  pub fn SetWrap(&self, aValue: bool)  {
          method_Call_1!(ToolButton_SetWrap, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(ToolButton_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(ToolButton_SetShowHint, self.0, aValue);
      }

	  pub fn Style(&self) -> TToolButtonStyle  {
          return method_Call_1!(ToolButton_GetStyle, self.0);
      }

	  pub fn SetStyle(&self, aValue: TToolButtonStyle)  {
          method_Call_1!(ToolButton_SetStyle, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(ToolButton_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(ToolButton_SetVisible, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ToolButton_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ToolButton_SetWidth, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToolButton_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(ToolButton_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(ToolButton_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(ToolButton_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ToolButton_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ToolButton_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ToolButton_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToolButton_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToolButton_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(ToolButton_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ToolButton_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(ToolButton_SetOnStartDock, self.0, aEventId);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(ToolButton_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(ToolButton_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(ToolButton_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(ToolButton_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(ToolButton_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(ToolButton_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ToolButton_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(ToolButton_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(ToolButton_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(ToolButton_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ToolButton_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ToolButton_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(ToolButton_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(ToolButton_SetClientWidth, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, ToolButton_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(ToolButton_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(ToolButton_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(ToolButton_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(ToolButton_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(ToolButton_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(ToolButton_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, ToolButton_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(ToolButton_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ToolButton_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ToolButton_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ToolButton_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ToolButton_SetTop, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(ToolButton_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(ToolButton_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ToolButton_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(ToolButton_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ToolButton_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ToolButton_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ToolButton_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ToolButton_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ToolButton_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ToolButton_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ToolButton_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ToolButton_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ToolButton_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ToolButton_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ToolButton_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ToolButton_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ToolButton_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ToolButton_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ToolButton_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ToolButton_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, ToolButton_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(ToolButton_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ToolButton_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ToolButton_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(ToolButton_StaticClassType);
}

impl_IObject!(TToolButton);
impl_IComponent!(TToolButton);
impl_IControl!(TToolButton);

impl TIniFile {
      pub fn new(aFileName: &str) -> Self {
        method_Create!(TIniFile, IniFile_Create, to_CString!(aFileName));
      }

      impl_As_method!(TIniFile);

	  impl_Free_method!(IniFile_Free);

	  pub fn ReadString<'a>(&self, section: &str, ident: &str, default: &str) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(IniFile_ReadString, self.0, to_CString!(section), to_CString!(ident), to_CString!(default)));
      }

	  pub fn WriteString(&self, section: &str, ident: &str, value: &str)  {
          method_Call_1!(IniFile_WriteString, self.0, to_CString!(section), to_CString!(ident), to_CString!(value));
      }

	  pub fn ReadSections(&self, strings: &dyn IStrings)  {
          method_Call_1!(IniFile_ReadSections, self.0, strings.Instance());
      }

	  pub fn ReadSectionValues(&self, section: &str, strings: &dyn IStrings)  {
          method_Call_1!(IniFile_ReadSectionValues, self.0, to_CString!(section), strings.Instance());
      }

	  pub fn EraseSection(&self, section: &str)  {
          method_Call_1!(IniFile_EraseSection, self.0, to_CString!(section));
      }

	  pub fn DeleteKey(&self, section: &str, ident: &str)  {
          method_Call_1!(IniFile_DeleteKey, self.0, to_CString!(section), to_CString!(ident));
      }

	  pub fn UpdateFile(&self)  {
          method_Call_1!(IniFile_UpdateFile, self.0);
      }

	  pub fn SectionExists(&self, section: &str) -> bool  {
          return method_Call_1!(IniFile_SectionExists, self.0, to_CString!(section));
      }

	  pub fn ReadInteger(&self, section: &str, ident: &str, default: i32) -> i32  {
          return method_Call_1!(IniFile_ReadInteger, self.0, to_CString!(section), to_CString!(ident), default);
      }

	  pub fn WriteInteger(&self, section: &str, ident: &str, value: i32)  {
          method_Call_1!(IniFile_WriteInteger, self.0, to_CString!(section), to_CString!(ident), value);
      }

	  pub fn ReadBool(&self, section: &str, ident: &str, default: bool) -> bool  {
          return method_Call_1!(IniFile_ReadBool, self.0, to_CString!(section), to_CString!(ident), default);
      }

	  pub fn WriteBool(&self, section: &str, ident: &str, value: bool)  {
          method_Call_1!(IniFile_WriteBool, self.0, to_CString!(section), to_CString!(ident), value);
      }

	  pub fn ReadDate(&self, section: &str, name: &str, default: u32) -> u32  {
          return method_Call_1!(IniFile_ReadDate, self.0, to_CString!(section), to_CString!(name), default);
      }

	  pub fn ReadDateTime(&self, section: &str, name: &str, default: u32) -> u32  {
          return method_Call_1!(IniFile_ReadDateTime, self.0, to_CString!(section), to_CString!(name), default);
      }

	  pub fn ReadFloat(&self, section: &str, name: &str, default: f64) -> f64  {
          let mut result = 0 as f64;
          let mut ps3 = default;
          method_Call_1!(IniFile_ReadFloat, self.0, to_CString!(section), to_CString!(name), &mut ps3, &mut result);
          return result;
      }

	  pub fn ReadTime(&self, section: &str, name: &str, default: u32) -> u32  {
          return method_Call_1!(IniFile_ReadTime, self.0, to_CString!(section), to_CString!(name), default);
      }

	  pub fn WriteDate(&self, section: &str, name: &str, value: u32)  {
          method_Call_1!(IniFile_WriteDate, self.0, to_CString!(section), to_CString!(name), value);
      }

	  pub fn WriteDateTime(&self, section: &str, name: &str, value: u32)  {
          method_Call_1!(IniFile_WriteDateTime, self.0, to_CString!(section), to_CString!(name), value);
      }

	  pub fn WriteFloat(&self, section: &str, name: &str, value: f64)  {
          let mut ps3 = value;
          method_Call_1!(IniFile_WriteFloat, self.0, to_CString!(section), to_CString!(name), &mut ps3);
      }

	  pub fn WriteTime(&self, section: &str, name: &str, value: u32)  {
          method_Call_1!(IniFile_WriteTime, self.0, to_CString!(section), to_CString!(name), value);
      }

	  pub fn ValueExists(&self, section: &str, ident: &str) -> bool  {
          return method_Call_1!(IniFile_ValueExists, self.0, to_CString!(section), to_CString!(ident));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(IniFile_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(IniFile_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(IniFile_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(IniFile_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(IniFile_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(IniFile_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(IniFile_ToString, self.0));
      }

	  pub fn FileName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(IniFile_GetFileName, self.0));
      }

      // static class
	  impl_Class_method!(IniFile_StaticClassType);
}

impl_IObject!(TIniFile);
impl_Drop_method!(TIniFile);

impl TRegistry {
      pub fn new(aAccess: u32) -> Self {
        method_Create!(TRegistry, Registry_Create, aAccess);
      }

      impl_As_method!(TRegistry);

	  impl_Free_method!(Registry_Free);

	  pub fn CloseKey(&self)  {
          method_Call_1!(Registry_CloseKey, self.0);
      }

	  pub fn CreateKey(&self, key: &str) -> bool  {
          return method_Call_1!(Registry_CreateKey, self.0, to_CString!(key));
      }

	  pub fn DeleteKey(&self, key: &str) -> bool  {
          return method_Call_1!(Registry_DeleteKey, self.0, to_CString!(key));
      }

	  pub fn DeleteValue(&self, name: &str) -> bool  {
          return method_Call_1!(Registry_DeleteValue, self.0, to_CString!(name));
      }

	  pub fn HasSubKeys(&self) -> bool  {
          return method_Call_1!(Registry_HasSubKeys, self.0);
      }

	  pub fn KeyExists(&self, key: &str) -> bool  {
          return method_Call_1!(Registry_KeyExists, self.0, to_CString!(key));
      }

	  pub fn LoadKey(&self, key: &str, fileName: &str) -> bool  {
          return method_Call_1!(Registry_LoadKey, self.0, to_CString!(key), to_CString!(fileName));
      }

	  pub fn MoveKey(&self, oldName: &str, newName: &str, delete: bool)  {
          method_Call_1!(Registry_MoveKey, self.0, to_CString!(oldName), to_CString!(newName), delete);
      }

	  pub fn OpenKey(&self, key: &str, canCreate: bool) -> bool  {
          return method_Call_1!(Registry_OpenKey, self.0, to_CString!(key), canCreate);
      }

	  pub fn OpenKeyReadOnly(&self, key: &str) -> bool  {
          return method_Call_1!(Registry_OpenKeyReadOnly, self.0, to_CString!(key));
      }

	  pub fn ReadBool(&self, name: &str) -> bool  {
          return method_Call_1!(Registry_ReadBool, self.0, to_CString!(name));
      }

	  pub fn ReadDate(&self, name: &str) -> u32  {
          return method_Call_1!(Registry_ReadDate, self.0, to_CString!(name));
      }

	  pub fn ReadDateTime(&self, name: &str) -> u32  {
          return method_Call_1!(Registry_ReadDateTime, self.0, to_CString!(name));
      }

	  pub fn ReadFloat(&self, name: &str) -> f64  {
          let mut result = 0 as f64;
          method_Call_1!(Registry_ReadFloat, self.0, to_CString!(name), &mut result);
          return result;
      }

	  pub fn ReadInteger(&self, name: &str) -> i32  {
          return method_Call_1!(Registry_ReadInteger, self.0, to_CString!(name));
      }

	  pub fn ReadString<'a>(&self, name: &str) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Registry_ReadString, self.0, to_CString!(name)));
      }

	  pub fn ReadTime(&self, name: &str) -> u32  {
          return method_Call_1!(Registry_ReadTime, self.0, to_CString!(name));
      }

	  pub fn RegistryConnect(&self, uNCName: &str) -> bool  {
          return method_Call_1!(Registry_RegistryConnect, self.0, to_CString!(uNCName));
      }

	  pub fn RenameValue(&self, oldName: &str, newName: &str)  {
          method_Call_1!(Registry_RenameValue, self.0, to_CString!(oldName), to_CString!(newName));
      }

	  pub fn ReplaceKey(&self, key: &str, fileName: &str, backUpFileName: &str) -> bool  {
          return method_Call_1!(Registry_ReplaceKey, self.0, to_CString!(key), to_CString!(fileName), to_CString!(backUpFileName));
      }

	  pub fn RestoreKey(&self, key: &str, fileName: &str) -> bool  {
          return method_Call_1!(Registry_RestoreKey, self.0, to_CString!(key), to_CString!(fileName));
      }

	  pub fn SaveKey(&self, key: &str, fileName: &str) -> bool  {
          return method_Call_1!(Registry_SaveKey, self.0, to_CString!(key), to_CString!(fileName));
      }

	  pub fn UnLoadKey(&self, key: &str) -> bool  {
          return method_Call_1!(Registry_UnLoadKey, self.0, to_CString!(key));
      }

	  pub fn ValueExists(&self, name: &str) -> bool  {
          return method_Call_1!(Registry_ValueExists, self.0, to_CString!(name));
      }

	  pub fn WriteBool(&self, name: &str, value: bool)  {
          method_Call_1!(Registry_WriteBool, self.0, to_CString!(name), value);
      }

	  pub fn WriteDate(&self, name: &str, value: u32)  {
          method_Call_1!(Registry_WriteDate, self.0, to_CString!(name), value);
      }

	  pub fn WriteDateTime(&self, name: &str, value: u32)  {
          method_Call_1!(Registry_WriteDateTime, self.0, to_CString!(name), value);
      }

	  pub fn WriteFloat(&self, name: &str, value: f64)  {
          let mut ps2 = value;
          method_Call_1!(Registry_WriteFloat, self.0, to_CString!(name), &mut ps2);
      }

	  pub fn WriteInteger(&self, name: &str, value: i32)  {
          method_Call_1!(Registry_WriteInteger, self.0, to_CString!(name), value);
      }

	  pub fn WriteString(&self, name: &str, value: &str)  {
          method_Call_1!(Registry_WriteString, self.0, to_CString!(name), to_CString!(value));
      }

	  pub fn WriteExpandString(&self, name: &str, value: &str)  {
          method_Call_1!(Registry_WriteExpandString, self.0, to_CString!(name), to_CString!(value));
      }

	  pub fn WriteTime(&self, name: &str, value: u32)  {
          method_Call_1!(Registry_WriteTime, self.0, to_CString!(name), value);
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Registry_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Registry_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Registry_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Registry_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Registry_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Registry_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Registry_ToString, self.0));
      }

	  pub fn CurrentKey(&self) -> HKEY  {
          return method_Call_1!(Registry_GetCurrentKey, self.0);
      }

	  pub fn CurrentPath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Registry_GetCurrentPath, self.0));
      }

	  pub fn LazyWrite(&self) -> bool  {
          return method_Call_1!(Registry_GetLazyWrite, self.0);
      }

	  pub fn SetLazyWrite(&self, aValue: bool)  {
          method_Call_1!(Registry_SetLazyWrite, self.0, aValue);
      }

	  pub fn LastError(&self) -> i32  {
          return method_Call_1!(Registry_GetLastError, self.0);
      }

	  pub fn LastErrorMsg<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Registry_GetLastErrorMsg, self.0));
      }

	  pub fn RootKey(&self) -> HKEY  {
          return method_Call_1!(Registry_GetRootKey, self.0);
      }

	  pub fn SetRootKey(&self, aValue: HKEY)  {
          method_Call_1!(Registry_SetRootKey, self.0, aValue);
      }

	  pub fn Access(&self) -> u32  {
          return method_Call_1!(Registry_GetAccess, self.0);
      }

	  pub fn SetAccess(&self, aValue: u32)  {
          method_Call_1!(Registry_SetAccess, self.0, aValue);
      }

      // static class
	  impl_Class_method!(Registry_StaticClassType);
}

impl_IObject!(TRegistry);
impl_Drop_method!(TRegistry);

impl TClipboard {
      pub fn new() -> Self {
        method_Create!(TClipboard, Clipboard_Create, );
      }

      impl_As_method!(TClipboard);

	  impl_Free_method!(Clipboard_Free);

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(Clipboard_Assign, self.0, source.Instance());
      }

	  pub fn Clear(&self)  {
          method_Call_1!(Clipboard_Clear, self.0);
      }

	  pub fn Close(&self)  {
          method_Call_1!(Clipboard_Close, self.0);
      }

	  pub fn HasFormat(&self, format: u16) -> bool  {
          return method_Call_1!(Clipboard_HasFormat, self.0, format);
      }

	  pub fn Open(&self)  {
          method_Call_1!(Clipboard_Open, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32  {
          return method_Call_1!(Clipboard_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn SetTextBuf(&self, buffer: &str)  {
          method_Call_1!(Clipboard_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Clipboard_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Clipboard_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Clipboard_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Clipboard_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Clipboard_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Clipboard_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Clipboard_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Clipboard_ToString, self.0));
      }

	  pub fn AsText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Clipboard_GetAsText, self.0));
      }

	  pub fn SetAsText(&self, aValue: &str)  {
          method_Call_1!(Clipboard_SetAsText, self.0, to_CString!(aValue));
      }

	  pub fn FormatCount(&self) -> i32  {
          return method_Call_1!(Clipboard_GetFormatCount, self.0);
      }

	  pub fn Formats(&self, index: i32) -> u16  {
          return method_Call_1!(Clipboard_GetFormats, self.0, index);
      }

      // static class
	  impl_Class_method!(Clipboard_StaticClassType);
	  pub fn SetClipboard(&self) -> TClipboard  {
          return method_Call_2!(TClipboard, Clipboard_SetClipboard, self.0);
      }

}

impl_IObject!(TClipboard);
impl_Drop_method!(TClipboard);

impl TMonitor {
      pub fn new() -> Self {
        method_Create!(TMonitor, Monitor_Create, );
      }

      impl_As_method!(TMonitor);

	  impl_Free_method!(Monitor_Free);

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Monitor_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Monitor_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Monitor_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Monitor_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Monitor_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Monitor_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Monitor_ToString, self.0));
      }

	  pub fn Handle(&self) -> HMONITOR  {
          return method_Call_1!(Monitor_GetHandle, self.0);
      }

	  pub fn MonitorNum(&self) -> i32  {
          return method_Call_1!(Monitor_GetMonitorNum, self.0);
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(Monitor_GetLeft, self.0);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Monitor_GetHeight, self.0);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(Monitor_GetTop, self.0);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Monitor_GetWidth, self.0);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Monitor_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn WorkareaRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Monitor_GetWorkareaRect, self.0, &mut result);
          return result;
      }

	  pub fn Primary(&self) -> bool  {
          return method_Call_1!(Monitor_GetPrimary, self.0);
      }

	  pub fn PixelsPerInch(&self) -> i32  {
          return method_Call_1!(Monitor_GetPixelsPerInch, self.0);
      }

      // static class
	  impl_Class_method!(Monitor_StaticClassType);
}

impl_IObject!(TMonitor);
impl_Drop_method!(TMonitor);

impl TPaintBox {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TPaintBox, PaintBox_Create, aOwner.Instance());
      }

      impl_As_method!(TPaintBox);

	  impl_Free_method!(PaintBox_Free);

	  pub fn BringToFront(&self) {
          method_Call_1!(PaintBox_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(PaintBox_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(PaintBox_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(PaintBox_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(PaintBox_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(PaintBox_Hide, self.0);
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(PaintBox_Invalidate, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(PaintBox_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(PaintBox_Refresh, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(PaintBox_Repaint, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(PaintBox_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(PaintBox_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(PaintBox_SendToBack, self.0);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(PaintBox_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn Show(&self) {
          method_Call_1!(PaintBox_Show, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(PaintBox_Update, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(PaintBox_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(PaintBox_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(PaintBox_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, PaintBox_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PaintBox_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(PaintBox_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(PaintBox_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PaintBox_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(PaintBox_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(PaintBox_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(PaintBox_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(PaintBox_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PaintBox_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(PaintBox_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(PaintBox_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(PaintBox_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(PaintBox_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(PaintBox_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(PaintBox_AnchorClient, self.0, aSpace);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, PaintBox_GetCanvas, self.0);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(PaintBox_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(PaintBox_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(PaintBox_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(PaintBox_SetAnchors, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(PaintBox_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(PaintBox_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, PaintBox_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(PaintBox_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(PaintBox_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(PaintBox_SetDragCursor, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(PaintBox_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(PaintBox_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(PaintBox_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(PaintBox_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, PaintBox_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(PaintBox_SetFont, self.0, aValue.Instance());
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(PaintBox_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(PaintBox_SetParentColor, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(PaintBox_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(PaintBox_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(PaintBox_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(PaintBox_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, PaintBox_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(PaintBox_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(PaintBox_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(PaintBox_SetShowHint, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(PaintBox_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(PaintBox_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PaintBox_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PaintBox_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(PaintBox_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(PaintBox_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(PaintBox_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(PaintBox_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PaintBox_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PaintBox_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(PaintBox_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(PaintBox_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnPaint(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PaintBox_SetOnPaint, self.0, aEventId);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, PaintBox_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(PaintBox_SetAction, self.0, aValue.Instance());
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(PaintBox_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(PaintBox_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(PaintBox_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(PaintBox_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(PaintBox_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(PaintBox_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(PaintBox_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(PaintBox_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(PaintBox_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(PaintBox_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(PaintBox_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(PaintBox_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(PaintBox_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(PaintBox_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(PaintBox_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, PaintBox_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(PaintBox_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(PaintBox_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(PaintBox_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(PaintBox_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(PaintBox_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(PaintBox_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(PaintBox_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(PaintBox_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(PaintBox_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(PaintBox_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(PaintBox_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(PaintBox_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(PaintBox_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(PaintBox_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(PaintBox_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(PaintBox_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, PaintBox_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(PaintBox_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(PaintBox_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(PaintBox_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(PaintBox_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, PaintBox_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(PaintBox_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, PaintBox_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(PaintBox_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, PaintBox_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(PaintBox_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, PaintBox_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(PaintBox_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, PaintBox_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(PaintBox_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, PaintBox_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, PaintBox_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(PaintBox_StaticClassType);
}

impl_IObject!(TPaintBox);
impl_IComponent!(TPaintBox);
impl_IControl!(TPaintBox);

impl TTimer {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TTimer, Timer_Create, aOwner.Instance());
      }

      impl_As_method!(TTimer);

	  impl_Free_method!(Timer_Free);

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Timer_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Timer_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Timer_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Timer_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Timer_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Timer_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Timer_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Timer_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Timer_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Timer_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Timer_ToString, self.0));
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(Timer_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(Timer_SetEnabled, self.0, aValue);
      }

	  pub fn Interval(&self) -> u32  {
          return method_Call_1!(Timer_GetInterval, self.0);
      }

	  pub fn SetInterval(&self, aValue: u32)  {
          method_Call_1!(Timer_SetInterval, self.0, aValue);
      }

	  pub fn SetOnTimer(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Timer_SetOnTimer, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Timer_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Timer_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Timer_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Timer_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Timer_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Timer_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Timer_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Timer_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Timer_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(Timer_StaticClassType);
}

impl_IObject!(TTimer);
impl_IComponent!(TTimer);

impl TList {
      pub fn new() -> Self {
        method_Create!(TList, List_Create, );
      }

      impl_As_method!(TList);

	  impl_Free_method!(List_Free);

	  pub fn Add(&self, item: usize) -> i32  {
          return method_Call_1!(List_Add, self.0, item);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(List_Clear, self.0);
      }

	  pub fn Delete(&self, index: i32)  {
          method_Call_1!(List_Delete, self.0, index);
      }

	  pub fn Expand(&self) -> TList  {
          return method_Call_2!(TList, List_Expand, self.0);
      }

	  pub fn IndexOf(&self, item: usize) -> i32  {
          return method_Call_1!(List_IndexOf, self.0, item);
      }

	  pub fn Insert(&self, index: i32, item: usize)  {
          method_Call_1!(List_Insert, self.0, index, item);
      }

	  pub fn Move(&self, curIndex: i32, newIndex: i32)  {
          method_Call_1!(List_Move, self.0, curIndex, newIndex);
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(List_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(List_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(List_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(List_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(List_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(List_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(List_ToString, self.0));
      }

	  pub fn Capacity(&self) -> i32  {
          return method_Call_1!(List_GetCapacity, self.0);
      }

	  pub fn SetCapacity(&self, aValue: i32)  {
          method_Call_1!(List_SetCapacity, self.0, aValue);
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(List_GetCount, self.0);
      }

	  pub fn SetCount(&self, aValue: i32)  {
          method_Call_1!(List_SetCount, self.0, aValue);
      }

	  pub fn List(&self) -> usize  {
          return method_Call_1!(List_GetList, self.0);
      }

	  pub fn Items(&self, index: i32) -> usize  {
          return method_Call_1!(List_GetItems, self.0, index);
      }

	  pub fn SetItems(&self, index: i32, aValue: usize)  {
          method_Call_1!(List_SetItems, self.0, index, aValue);
      }

      // static class
	  impl_Class_method!(List_StaticClassType);
}

impl_IObject!(TList);
impl_Drop_method!(TList);

impl TForm {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TForm, Form_Create, aOwner.Instance());
      }

      impl_As_method!(TForm);

	  impl_Free_method!(Form_Free);

	  pub fn Close(&self)  {
          method_Call_1!(Form_Close, self.0);
      }

	  pub fn FocusControl(&self, control: &dyn IWinControl)  {
          method_Call_1!(Form_FocusControl, self.0, control.Instance());
      }

	  pub fn Hide(&self) {
          method_Call_1!(Form_Hide, self.0);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(Form_SetFocus, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(Form_Show, self.0);
      }

	  pub fn ShowModal(&self) -> i32  {
          return method_Call_1!(Form_ShowModal, self.0);
      }

	  pub fn ScrollInView(&self, aControl: &dyn IControl)  {
          method_Call_1!(Form_ScrollInView, self.0, aControl.Instance());
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(Form_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(Form_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, Form_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(Form_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(Form_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, Form_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(Form_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(Form_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(Form_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(Form_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(Form_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(Form_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(Form_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(Form_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(Form_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(Form_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(Form_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn Update(&self) {
          method_Call_1!(Form_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(Form_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Form_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Form_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(Form_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Form_HasParent, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(Form_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(Form_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Form_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Form_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(Form_SendToBack, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(Form_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(Form_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(Form_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Form_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Form_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Form_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Form_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Form_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Form_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Form_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Form_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Form_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Form_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Form_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Form_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Form_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Form_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(Form_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(Form_AnchorClient, self.0, aSpace);
      }

	  pub fn AllowDropFiles(&self) -> bool  {
          return method_Call_1!(Form_GetAllowDropFiles, self.0);
      }

	  pub fn SetAllowDropFiles(&self, aValue: bool)  {
          method_Call_1!(Form_SetAllowDropFiles, self.0, aValue);
      }

	  pub fn SetOnDropFiles(&self, aEventId: TDropFilesEvent)  {
          method_Call_1!(Form_SetOnDropFiles, self.0, aEventId);
      }

	  pub fn ShowInTaskBar(&self) -> TShowInTaskbar  {
          return method_Call_1!(Form_GetShowInTaskBar, self.0);
      }

	  pub fn SetShowInTaskBar(&self, aValue: TShowInTaskbar)  {
          method_Call_1!(Form_SetShowInTaskBar, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, Form_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(Form_SetAction, self.0, aValue.Instance());
      }

	  pub fn ActiveControl(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Form_GetActiveControl, self.0);
      }

	  pub fn SetActiveControl(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(Form_SetActiveControl, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(Form_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(Form_SetAlign, self.0, aValue);
      }

	  pub fn AlphaBlend(&self) -> bool  {
          return method_Call_1!(Form_GetAlphaBlend, self.0);
      }

	  pub fn SetAlphaBlend(&self, aValue: bool)  {
          method_Call_1!(Form_SetAlphaBlend, self.0, aValue);
      }

	  pub fn AlphaBlendValue(&self) -> i8  {
          return method_Call_1!(Form_GetAlphaBlendValue, self.0);
      }

	  pub fn SetAlphaBlendValue(&self, aValue: i8)  {
          method_Call_1!(Form_SetAlphaBlendValue, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(Form_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(Form_SetAnchors, self.0, aValue);
      }

	  pub fn AutoScroll(&self) -> bool  {
          return method_Call_1!(Form_GetAutoScroll, self.0);
      }

	  pub fn SetAutoScroll(&self, aValue: bool)  {
          method_Call_1!(Form_SetAutoScroll, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(Form_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(Form_SetAutoSize, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(Form_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(Form_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderIcons(&self) -> TBorderIcons  {
          return method_Call_1!(Form_GetBorderIcons, self.0);
      }

	  pub fn SetBorderIcons(&self, aValue: TBorderIcons)  {
          method_Call_1!(Form_SetBorderIcons, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TFormBorderStyle  {
          return method_Call_1!(Form_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TFormBorderStyle)  {
          method_Call_1!(Form_SetBorderStyle, self.0, aValue);
      }

	  pub fn BorderWidth(&self) -> i32  {
          return method_Call_1!(Form_GetBorderWidth, self.0);
      }

	  pub fn SetBorderWidth(&self, aValue: i32)  {
          method_Call_1!(Form_SetBorderWidth, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Form_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(Form_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(Form_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(Form_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(Form_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(Form_SetClientWidth, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(Form_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(Form_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, Form_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(Form_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(Form_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(Form_SetUseDockManager, self.0, aValue);
      }

	  pub fn DefaultMonitor(&self) -> TDefaultMonitor  {
          return method_Call_1!(Form_GetDefaultMonitor, self.0);
      }

	  pub fn SetDefaultMonitor(&self, aValue: TDefaultMonitor)  {
          method_Call_1!(Form_SetDefaultMonitor, self.0, aValue);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(Form_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(Form_SetDockSite, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(Form_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(Form_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(Form_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(Form_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(Form_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(Form_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(Form_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(Form_SetEnabled, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(Form_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(Form_SetParentFont, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, Form_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(Form_SetFont, self.0, aValue.Instance());
      }

	  pub fn FormStyle(&self) -> TFormStyle  {
          return method_Call_1!(Form_GetFormStyle, self.0);
      }

	  pub fn SetFormStyle(&self, aValue: TFormStyle)  {
          method_Call_1!(Form_SetFormStyle, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Form_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Form_SetHeight, self.0, aValue);
      }

	  pub fn HorzScrollBar(&self) -> TControlScrollBar  {
          return method_Call_2!(TControlScrollBar, Form_GetHorzScrollBar, self.0);
      }

	  pub fn SetHorzScrollBar(&self, aValue: &TControlScrollBar)  {
          method_Call_1!(Form_SetHorzScrollBar, self.0, aValue.Instance());
      }

	  pub fn Icon(&self) -> TIcon  {
          return method_Call_2!(TIcon, Form_GetIcon, self.0);
      }

	  pub fn SetIcon(&self, aValue: &TIcon)  {
          method_Call_1!(Form_SetIcon, self.0, aValue.Instance());
      }

	  pub fn KeyPreview(&self) -> bool  {
          return method_Call_1!(Form_GetKeyPreview, self.0);
      }

	  pub fn SetKeyPreview(&self, aValue: bool)  {
          method_Call_1!(Form_SetKeyPreview, self.0, aValue);
      }

	  pub fn Menu(&self) -> TMainMenu  {
          return method_Call_2!(TMainMenu, Form_GetMenu, self.0);
      }

	  pub fn SetMenu(&self, aValue: &TMainMenu)  {
          method_Call_1!(Form_SetMenu, self.0, aValue.Instance());
      }

	  pub fn PixelsPerInch(&self) -> i32  {
          return method_Call_1!(Form_GetPixelsPerInch, self.0);
      }

	  pub fn SetPixelsPerInch(&self, aValue: i32)  {
          method_Call_1!(Form_SetPixelsPerInch, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, Form_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(Form_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn Position(&self) -> TPosition  {
          return method_Call_1!(Form_GetPosition, self.0);
      }

	  pub fn SetPosition(&self, aValue: TPosition)  {
          method_Call_1!(Form_SetPosition, self.0, aValue);
      }

	  pub fn Scaled(&self) -> bool  {
          return method_Call_1!(Form_GetScaled, self.0);
      }

	  pub fn SetScaled(&self, aValue: bool)  {
          method_Call_1!(Form_SetScaled, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(Form_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(Form_SetShowHint, self.0, aValue);
      }

	  pub fn VertScrollBar(&self) -> TControlScrollBar  {
          return method_Call_2!(TControlScrollBar, Form_GetVertScrollBar, self.0);
      }

	  pub fn SetVertScrollBar(&self, aValue: &TControlScrollBar)  {
          method_Call_1!(Form_SetVertScrollBar, self.0, aValue.Instance());
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(Form_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(Form_SetVisible, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Form_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Form_SetWidth, self.0, aValue);
      }

	  pub fn WindowState(&self) -> TWindowState  {
          return method_Call_1!(Form_GetWindowState, self.0);
      }

	  pub fn SetWindowState(&self, aValue: TWindowState)  {
          method_Call_1!(Form_SetWindowState, self.0, aValue);
      }

	  pub fn SetOnActivate(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Form_SetOnActivate, self.0, aEventId);
      }

	  pub fn SetOnAlignPosition(&self, aEventId: TAlignPositionEvent)  {
          method_Call_1!(Form_SetOnAlignPosition, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Form_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnClose(&self, aEventId: TCloseEvent)  {
          method_Call_1!(Form_SetOnClose, self.0, aEventId);
      }

	  pub fn SetOnCloseQuery(&self, aEventId: TCloseQueryEvent)  {
          method_Call_1!(Form_SetOnCloseQuery, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(Form_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Form_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDeactivate(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Form_SetOnDeactivate, self.0, aEventId);
      }

	  pub fn SetOnDockDrop(&self, aEventId: TDockDropEvent)  {
          method_Call_1!(Form_SetOnDockDrop, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(Form_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(Form_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(Form_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnGetSiteInfo(&self, aEventId: TGetSiteInfoEvent)  {
          method_Call_1!(Form_SetOnGetSiteInfo, self.0, aEventId);
      }

	  pub fn SetOnHide(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Form_SetOnHide, self.0, aEventId);
      }

	  pub fn SetOnHelp(&self, aEventId: THelpEvent)  {
          method_Call_1!(Form_SetOnHelp, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(Form_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(Form_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(Form_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Form_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Form_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Form_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(Form_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Form_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnMouseWheel(&self, aEventId: TMouseWheelEvent)  {
          method_Call_1!(Form_SetOnMouseWheel, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelDown(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(Form_SetOnMouseWheelDown, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelUp(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(Form_SetOnMouseWheelUp, self.0, aEventId);
      }

	  pub fn SetOnPaint(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Form_SetOnPaint, self.0, aEventId);
      }

	  pub fn SetOnResize(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Form_SetOnResize, self.0, aEventId);
      }

	  pub fn SetOnShortCut(&self, aEventId: TShortCutEvent)  {
          method_Call_1!(Form_SetOnShortCut, self.0, aEventId);
      }

	  pub fn SetOnShow(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Form_SetOnShow, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(Form_SetOnStartDock, self.0, aEventId);
      }

	  pub fn SetOnUnDock(&self, aEventId: TUnDockEvent)  {
          method_Call_1!(Form_SetOnUnDock, self.0, aEventId);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, Form_GetCanvas, self.0);
      }

	  pub fn ModalResult(&self) -> TModalResult  {
          return method_Call_1!(Form_GetModalResult, self.0);
      }

	  pub fn SetModalResult(&self, aValue: TModalResult)  {
          method_Call_1!(Form_SetModalResult, self.0, aValue);
      }

	  pub fn Monitor(&self) -> TMonitor  {
          return method_Call_2!(TMonitor, Form_GetMonitor, self.0);
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(Form_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(Form_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(Form_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(Form_SetTop, self.0, aValue);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(Form_GetDockClientCount, self.0);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(Form_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(Form_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, Form_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(Form_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(Form_GetHandle, self.0);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(Form_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(Form_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(Form_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(Form_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(Form_GetShowing, self.0);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(Form_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(Form_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(Form_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(Form_SetTabStop, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Form_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(Form_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(Form_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Form_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(Form_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(Form_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(Form_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(Form_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(Form_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Form_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(Form_SetParent, self.0, aValue.Instance());
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(Form_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(Form_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Form_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(Form_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Form_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Form_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Form_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Form_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Form_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Form_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Form_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Form_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Form_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Form_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Form_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Form_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Form_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Form_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Form_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Form_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, Form_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(Form_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, Form_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(Form_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, Form_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, Form_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Form_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Form_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(Form_StaticClassType);
	  pub fn Create2(&self, aInitScale: bool) -> TForm  {
          return method_Call_2!(TForm, Form_Create2, self.0, aInitScale);
      }

	  pub fn EnabledMaximize(&self, aValue: bool)  {
          method_Call_1!(Form_EnabledMaximize, self.0, aValue);
      }

	  pub fn EnabledMinimize(&self, aValue: bool)  {
          method_Call_1!(Form_EnabledMinimize, self.0, aValue);
      }

	  pub fn EnabledSystemMenu(&self, aValue: bool)  {
          method_Call_1!(Form_EnabledSystemMenu, self.0, aValue);
      }

	  pub fn SetOnDestroy(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Form_SetOnDestroy, self.0, aEventId);
      }

	  pub fn SetOnConstrainedResize(&self, aEventId: TConstrainedResizeEvent)  {
          method_Call_1!(Form_SetOnConstrainedResize, self.0, aEventId);
      }

	  pub fn SetOnWndProc(&self, aEventId: TWndProcEvent)  {
          method_Call_1!(Form_SetOnWndProc, self.0, aEventId);
      }

	  pub fn ScaleForPPI(&self, aNewPPI: i32)  {
          method_Call_1!(Form_ScaleForPPI, self.0, aNewPPI);
      }

	  pub fn ScaleControlsForDpi(&self, aNewPPI: i32)  {
          method_Call_1!(Form_ScaleControlsForDpi, self.0, aNewPPI);
      }

	  pub fn ScaleForCurrentDpi(&self)  {
          method_Call_1!(Form_ScaleForCurrentDpi, self.0);
      }

	  pub fn InheritedWndProc(&self, aMsg: *mut TMessage)  {
          method_Call_1!(Form_InheritedWndProc, self.0, aMsg);
      }

}

impl_IObject!(TForm);
impl_IComponent!(TForm);
impl_IControl!(TForm);
impl_IWinControl!(TForm);

impl TParaAttributes {
	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(ParaAttributes_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ParaAttributes_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ParaAttributes_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ParaAttributes_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ParaAttributes_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ParaAttributes_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ParaAttributes_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ParaAttributes_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ParaAttributes_ToString, self.0));
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(ParaAttributes_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(ParaAttributes_SetAlignment, self.0, aValue);
      }

	  pub fn FirstIndent(&self) -> i32  {
          return method_Call_1!(ParaAttributes_GetFirstIndent, self.0);
      }

	  pub fn SetFirstIndent(&self, aValue: i32)  {
          method_Call_1!(ParaAttributes_SetFirstIndent, self.0, aValue);
      }

	  pub fn LeftIndent(&self) -> i32  {
          return method_Call_1!(ParaAttributes_GetLeftIndent, self.0);
      }

	  pub fn SetLeftIndent(&self, aValue: i32)  {
          method_Call_1!(ParaAttributes_SetLeftIndent, self.0, aValue);
      }

	  pub fn Numbering(&self) -> TNumberingStyle  {
          return method_Call_1!(ParaAttributes_GetNumbering, self.0);
      }

	  pub fn SetNumbering(&self, aValue: TNumberingStyle)  {
          method_Call_1!(ParaAttributes_SetNumbering, self.0, aValue);
      }

	  pub fn RightIndent(&self) -> i32  {
          return method_Call_1!(ParaAttributes_GetRightIndent, self.0);
      }

	  pub fn SetRightIndent(&self, aValue: i32)  {
          method_Call_1!(ParaAttributes_SetRightIndent, self.0, aValue);
      }

	  pub fn TabCount(&self) -> i32  {
          return method_Call_1!(ParaAttributes_GetTabCount, self.0);
      }

	  pub fn SetTabCount(&self, aValue: i32)  {
          method_Call_1!(ParaAttributes_SetTabCount, self.0, aValue);
      }

	  pub fn Tab(&self, index: i8) -> i32  {
          return method_Call_1!(ParaAttributes_GetTab, self.0, index);
      }

	  pub fn SetTab(&self, index: i8, aValue: i32)  {
          method_Call_1!(ParaAttributes_SetTab, self.0, index, aValue);
      }

      // static class
	  impl_Class_method!(ParaAttributes_StaticClassType);
}

impl_IObject!(TParaAttributes);

impl TTextAttributes {
	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(TextAttributes_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TextAttributes_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(TextAttributes_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TextAttributes_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(TextAttributes_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(TextAttributes_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(TextAttributes_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(TextAttributes_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TextAttributes_ToString, self.0));
      }

	  pub fn Charset(&self) -> TFontCharset  {
          return method_Call_1!(TextAttributes_GetCharset, self.0);
      }

	  pub fn SetCharset(&self, aValue: TFontCharset)  {
          method_Call_1!(TextAttributes_SetCharset, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(TextAttributes_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(TextAttributes_SetColor, self.0, aValue);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TextAttributes_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(TextAttributes_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Pitch(&self) -> TFontPitch  {
          return method_Call_1!(TextAttributes_GetPitch, self.0);
      }

	  pub fn SetPitch(&self, aValue: TFontPitch)  {
          method_Call_1!(TextAttributes_SetPitch, self.0, aValue);
      }

	  pub fn Size(&self) -> i32  {
          return method_Call_1!(TextAttributes_GetSize, self.0);
      }

	  pub fn SetSize(&self, aValue: i32)  {
          method_Call_1!(TextAttributes_SetSize, self.0, aValue);
      }

	  pub fn Style(&self) -> TFontStyles  {
          return method_Call_1!(TextAttributes_GetStyle, self.0);
      }

	  pub fn SetStyle(&self, aValue: TFontStyles)  {
          method_Call_1!(TextAttributes_SetStyle, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(TextAttributes_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(TextAttributes_SetHeight, self.0, aValue);
      }

      // static class
	  impl_Class_method!(TextAttributes_StaticClassType);
}

impl_IObject!(TTextAttributes);

impl TIconOptions {
	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(IconOptions_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(IconOptions_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(IconOptions_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(IconOptions_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(IconOptions_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(IconOptions_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(IconOptions_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(IconOptions_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(IconOptions_ToString, self.0));
      }

	  pub fn Arrangement(&self) -> TIconArrangement  {
          return method_Call_1!(IconOptions_GetArrangement, self.0);
      }

	  pub fn SetArrangement(&self, aValue: TIconArrangement)  {
          method_Call_1!(IconOptions_SetArrangement, self.0, aValue);
      }

	  pub fn AutoArrange(&self) -> bool  {
          return method_Call_1!(IconOptions_GetAutoArrange, self.0);
      }

	  pub fn SetAutoArrange(&self, aValue: bool)  {
          method_Call_1!(IconOptions_SetAutoArrange, self.0, aValue);
      }

      // static class
	  impl_Class_method!(IconOptions_StaticClassType);
}

impl_IObject!(TIconOptions);

impl Exception {
	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Exception_ToString, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Exception_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Exception_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Exception_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Exception_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Exception_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Exception_GetHashCode, self.0);
      }

	  pub fn Message<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Exception_GetMessage, self.0));
      }

	  pub fn SetMessage(&self, aValue: &str)  {
          method_Call_1!(Exception_SetMessage, self.0, to_CString!(aValue));
      }

      // static class
	  impl_Class_method!(Exception_StaticClassType);
}

impl_IObject!(Exception);

impl TScrollBar {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TScrollBar, ScrollBar_Create, aOwner.Instance());
      }

      impl_As_method!(TScrollBar);

	  impl_Free_method!(ScrollBar_Free);

	  pub fn SetParams(&self, aPosition: i32, aMin: i32, aMax: i32)  {
          method_Call_1!(ScrollBar_SetParams, self.0, aPosition, aMin, aMax);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(ScrollBar_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(ScrollBar_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, ScrollBar_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(ScrollBar_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(ScrollBar_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, ScrollBar_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(ScrollBar_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(ScrollBar_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(ScrollBar_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ScrollBar_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(ScrollBar_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ScrollBar_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(ScrollBar_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(ScrollBar_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(ScrollBar_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(ScrollBar_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(ScrollBar_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(ScrollBar_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(ScrollBar_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(ScrollBar_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ScrollBar_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ScrollBar_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(ScrollBar_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ScrollBar_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(ScrollBar_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(ScrollBar_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(ScrollBar_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ScrollBar_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ScrollBar_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(ScrollBar_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(ScrollBar_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(ScrollBar_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(ScrollBar_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(ScrollBar_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ScrollBar_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ScrollBar_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ScrollBar_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ScrollBar_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ScrollBar_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ScrollBar_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ScrollBar_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ScrollBar_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ScrollBar_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ScrollBar_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ScrollBar_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ScrollBar_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ScrollBar_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ScrollBar_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(ScrollBar_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(ScrollBar_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(ScrollBar_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(ScrollBar_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(ScrollBar_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(ScrollBar_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(ScrollBar_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(ScrollBar_SetBiDiMode, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, ScrollBar_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(ScrollBar_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(ScrollBar_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ScrollBar_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(ScrollBar_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(ScrollBar_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(ScrollBar_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(ScrollBar_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(ScrollBar_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(ScrollBar_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(ScrollBar_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(ScrollBar_SetEnabled, self.0, aValue);
      }

	  pub fn LargeChange(&self) -> TScrollBarInc  {
          return method_Call_1!(ScrollBar_GetLargeChange, self.0);
      }

	  pub fn SetLargeChange(&self, aValue: TScrollBarInc)  {
          method_Call_1!(ScrollBar_SetLargeChange, self.0, aValue);
      }

	  pub fn Max(&self) -> i32  {
          return method_Call_1!(ScrollBar_GetMax, self.0);
      }

	  pub fn SetMax(&self, aValue: i32)  {
          method_Call_1!(ScrollBar_SetMax, self.0, aValue);
      }

	  pub fn Min(&self) -> i32  {
          return method_Call_1!(ScrollBar_GetMin, self.0);
      }

	  pub fn SetMin(&self, aValue: i32)  {
          method_Call_1!(ScrollBar_SetMin, self.0, aValue);
      }

	  pub fn PageSize(&self) -> i32  {
          return method_Call_1!(ScrollBar_GetPageSize, self.0);
      }

	  pub fn SetPageSize(&self, aValue: i32)  {
          method_Call_1!(ScrollBar_SetPageSize, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(ScrollBar_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ScrollBar_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(ScrollBar_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(ScrollBar_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, ScrollBar_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(ScrollBar_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn Position(&self) -> i32  {
          return method_Call_1!(ScrollBar_GetPosition, self.0);
      }

	  pub fn SetPosition(&self, aValue: i32)  {
          method_Call_1!(ScrollBar_SetPosition, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(ScrollBar_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(ScrollBar_SetShowHint, self.0, aValue);
      }

	  pub fn SmallChange(&self) -> TScrollBarInc  {
          return method_Call_1!(ScrollBar_GetSmallChange, self.0);
      }

	  pub fn SetSmallChange(&self, aValue: TScrollBarInc)  {
          method_Call_1!(ScrollBar_SetSmallChange, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(ScrollBar_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(ScrollBar_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(ScrollBar_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(ScrollBar_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(ScrollBar_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(ScrollBar_SetVisible, self.0, aValue);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(ScrollBar_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ScrollBar_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(ScrollBar_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(ScrollBar_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ScrollBar_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ScrollBar_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ScrollBar_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ScrollBar_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(ScrollBar_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ScrollBar_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(ScrollBar_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(ScrollBar_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(ScrollBar_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(ScrollBar_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(ScrollBar_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, ScrollBar_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(ScrollBar_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(ScrollBar_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(ScrollBar_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(ScrollBar_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(ScrollBar_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(ScrollBar_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(ScrollBar_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, ScrollBar_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(ScrollBar_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ScrollBar_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(ScrollBar_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(ScrollBar_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(ScrollBar_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ScrollBar_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ScrollBar_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(ScrollBar_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(ScrollBar_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(ScrollBar_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(ScrollBar_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(ScrollBar_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(ScrollBar_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(ScrollBar_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, ScrollBar_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(ScrollBar_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ScrollBar_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ScrollBar_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ScrollBar_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ScrollBar_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ScrollBar_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ScrollBar_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(ScrollBar_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(ScrollBar_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(ScrollBar_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(ScrollBar_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ScrollBar_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(ScrollBar_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ScrollBar_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ScrollBar_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ScrollBar_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ScrollBar_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ScrollBar_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ScrollBar_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ScrollBar_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ScrollBar_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ScrollBar_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ScrollBar_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ScrollBar_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ScrollBar_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ScrollBar_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ScrollBar_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ScrollBar_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ScrollBar_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, ScrollBar_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(ScrollBar_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, ScrollBar_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(ScrollBar_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ScrollBar_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ScrollBar_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ScrollBar_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ScrollBar_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(ScrollBar_StaticClassType);
}

impl_IObject!(TScrollBar);
impl_IComponent!(TScrollBar);
impl_IControl!(TScrollBar);
impl_IWinControl!(TScrollBar);

impl TMaskEdit {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TMaskEdit, MaskEdit_Create, aOwner.Instance());
      }

      impl_As_method!(TMaskEdit);

	  impl_Free_method!(MaskEdit_Free);

	  pub fn ValidateEdit(&self)  {
          method_Call_1!(MaskEdit_ValidateEdit, self.0);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(MaskEdit_Clear, self.0);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(MaskEdit_GetTextLen, self.0);
      }

	  pub fn ClearSelection(&self)  {
          method_Call_1!(MaskEdit_ClearSelection, self.0);
      }

	  pub fn CopyToClipboard(&self)  {
          method_Call_1!(MaskEdit_CopyToClipboard, self.0);
      }

	  pub fn CutToClipboard(&self)  {
          method_Call_1!(MaskEdit_CutToClipboard, self.0);
      }

	  pub fn PasteFromClipboard(&self)  {
          method_Call_1!(MaskEdit_PasteFromClipboard, self.0);
      }

	  pub fn Undo(&self)  {
          method_Call_1!(MaskEdit_Undo, self.0);
      }

	  pub fn SelectAll(&self)  {
          method_Call_1!(MaskEdit_SelectAll, self.0);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(MaskEdit_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(MaskEdit_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, MaskEdit_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(MaskEdit_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(MaskEdit_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, MaskEdit_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(MaskEdit_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(MaskEdit_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(MaskEdit_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(MaskEdit_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(MaskEdit_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(MaskEdit_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(MaskEdit_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(MaskEdit_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(MaskEdit_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(MaskEdit_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(MaskEdit_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(MaskEdit_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(MaskEdit_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(MaskEdit_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(MaskEdit_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(MaskEdit_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(MaskEdit_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(MaskEdit_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(MaskEdit_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(MaskEdit_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(MaskEdit_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(MaskEdit_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(MaskEdit_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(MaskEdit_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(MaskEdit_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(MaskEdit_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(MaskEdit_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, MaskEdit_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MaskEdit_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(MaskEdit_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(MaskEdit_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MaskEdit_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(MaskEdit_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(MaskEdit_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(MaskEdit_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(MaskEdit_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(MaskEdit_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(MaskEdit_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(MaskEdit_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(MaskEdit_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(MaskEdit_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(MaskEdit_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(MaskEdit_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(MaskEdit_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(MaskEdit_SetAlign, self.0, aValue);
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(MaskEdit_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(MaskEdit_SetAlignment, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(MaskEdit_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(MaskEdit_SetAnchors, self.0, aValue);
      }

	  pub fn AutoSelect(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetAutoSelect, self.0);
      }

	  pub fn SetAutoSelect(&self, aValue: bool)  {
          method_Call_1!(MaskEdit_SetAutoSelect, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(MaskEdit_SetAutoSize, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(MaskEdit_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(MaskEdit_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(MaskEdit_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(MaskEdit_SetBorderStyle, self.0, aValue);
      }

	  pub fn CharCase(&self) -> TEditCharCase  {
          return method_Call_1!(MaskEdit_GetCharCase, self.0);
      }

	  pub fn SetCharCase(&self, aValue: TEditCharCase)  {
          method_Call_1!(MaskEdit_SetCharCase, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(MaskEdit_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(MaskEdit_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, MaskEdit_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(MaskEdit_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(MaskEdit_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(MaskEdit_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(MaskEdit_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(MaskEdit_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(MaskEdit_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(MaskEdit_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(MaskEdit_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(MaskEdit_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, MaskEdit_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(MaskEdit_SetFont, self.0, aValue.Instance());
      }

	  pub fn MaxLength(&self) -> i32  {
          return method_Call_1!(MaskEdit_GetMaxLength, self.0);
      }

	  pub fn SetMaxLength(&self, aValue: i32)  {
          method_Call_1!(MaskEdit_SetMaxLength, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(MaskEdit_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(MaskEdit_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(MaskEdit_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(MaskEdit_SetParentShowHint, self.0, aValue);
      }

	  pub fn PasswordChar(&self) -> Char  {
          return method_Call_1!(MaskEdit_GetPasswordChar, self.0);
      }

	  pub fn SetPasswordChar(&self, aValue: Char)  {
          method_Call_1!(MaskEdit_SetPasswordChar, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, MaskEdit_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(MaskEdit_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ReadOnly(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetReadOnly, self.0);
      }

	  pub fn SetReadOnly(&self, aValue: bool)  {
          method_Call_1!(MaskEdit_SetReadOnly, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(MaskEdit_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(MaskEdit_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(MaskEdit_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(MaskEdit_SetTabStop, self.0, aValue);
      }

	  pub fn Text<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MaskEdit_GetText, self.0));
      }

	  pub fn SetText(&self, aValue: &str)  {
          method_Call_1!(MaskEdit_SetText, self.0, to_CString!(aValue));
      }

	  pub fn TextHint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MaskEdit_GetTextHint, self.0));
      }

	  pub fn SetTextHint(&self, aValue: &str)  {
          method_Call_1!(MaskEdit_SetTextHint, self.0, to_CString!(aValue));
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(MaskEdit_SetVisible, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(MaskEdit_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(MaskEdit_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(MaskEdit_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(MaskEdit_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(MaskEdit_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(MaskEdit_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(MaskEdit_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(MaskEdit_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(MaskEdit_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(MaskEdit_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(MaskEdit_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(MaskEdit_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(MaskEdit_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(MaskEdit_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(MaskEdit_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(MaskEdit_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(MaskEdit_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(MaskEdit_SetOnStartDock, self.0, aEventId);
      }

	  pub fn IsMasked(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetIsMasked, self.0);
      }

	  pub fn EditText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MaskEdit_GetEditText, self.0));
      }

	  pub fn SetEditText(&self, aValue: &str)  {
          method_Call_1!(MaskEdit_SetEditText, self.0, to_CString!(aValue));
      }

	  pub fn CanUndo(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetCanUndo, self.0);
      }

	  pub fn Modified(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetModified, self.0);
      }

	  pub fn SetModified(&self, aValue: bool)  {
          method_Call_1!(MaskEdit_SetModified, self.0, aValue);
      }

	  pub fn SelLength(&self) -> i32  {
          return method_Call_1!(MaskEdit_GetSelLength, self.0);
      }

	  pub fn SetSelLength(&self, aValue: i32)  {
          method_Call_1!(MaskEdit_SetSelLength, self.0, aValue);
      }

	  pub fn SelStart(&self) -> i32  {
          return method_Call_1!(MaskEdit_GetSelStart, self.0);
      }

	  pub fn SetSelStart(&self, aValue: i32)  {
          method_Call_1!(MaskEdit_SetSelStart, self.0, aValue);
      }

	  pub fn SelText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MaskEdit_GetSelText, self.0));
      }

	  pub fn SetSelText(&self, aValue: &str)  {
          method_Call_1!(MaskEdit_SetSelText, self.0, to_CString!(aValue));
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(MaskEdit_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(MaskEdit_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(MaskEdit_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, MaskEdit_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(MaskEdit_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(MaskEdit_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(MaskEdit_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(MaskEdit_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(MaskEdit_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, MaskEdit_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(MaskEdit_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(MaskEdit_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(MaskEdit_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(MaskEdit_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(MaskEdit_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(MaskEdit_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(MaskEdit_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(MaskEdit_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(MaskEdit_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(MaskEdit_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(MaskEdit_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(MaskEdit_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(MaskEdit_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(MaskEdit_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, MaskEdit_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(MaskEdit_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(MaskEdit_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(MaskEdit_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(MaskEdit_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(MaskEdit_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(MaskEdit_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(MaskEdit_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(MaskEdit_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(MaskEdit_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(MaskEdit_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(MaskEdit_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MaskEdit_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(MaskEdit_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(MaskEdit_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(MaskEdit_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(MaskEdit_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, MaskEdit_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(MaskEdit_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(MaskEdit_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(MaskEdit_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(MaskEdit_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, MaskEdit_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(MaskEdit_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, MaskEdit_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(MaskEdit_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, MaskEdit_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(MaskEdit_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, MaskEdit_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(MaskEdit_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, MaskEdit_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(MaskEdit_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, MaskEdit_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(MaskEdit_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, MaskEdit_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, MaskEdit_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, MaskEdit_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, MaskEdit_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(MaskEdit_StaticClassType);
}

impl_IObject!(TMaskEdit);
impl_IComponent!(TMaskEdit);
impl_IControl!(TMaskEdit);
impl_IWinControl!(TMaskEdit);

impl TShape {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TShape, Shape_Create, aOwner.Instance());
      }

      impl_As_method!(TShape);

	  impl_Free_method!(Shape_Free);

	  pub fn BringToFront(&self) {
          method_Call_1!(Shape_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Shape_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Shape_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(Shape_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Shape_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(Shape_Hide, self.0);
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(Shape_Invalidate, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(Shape_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(Shape_Refresh, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(Shape_Repaint, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Shape_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Shape_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(Shape_SendToBack, self.0);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(Shape_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn Show(&self) {
          method_Call_1!(Shape_Show, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(Shape_Update, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(Shape_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(Shape_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(Shape_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Shape_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Shape_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Shape_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Shape_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Shape_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Shape_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Shape_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Shape_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Shape_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Shape_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Shape_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Shape_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Shape_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Shape_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(Shape_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(Shape_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(Shape_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(Shape_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(Shape_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(Shape_SetAnchors, self.0, aValue);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, Shape_GetBrush, self.0);
      }

	  pub fn SetBrush(&self, aValue: &TBrush)  {
          method_Call_1!(Shape_SetBrush, self.0, aValue.Instance());
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(Shape_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(Shape_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(Shape_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(Shape_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(Shape_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(Shape_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(Shape_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(Shape_SetEnabled, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, Shape_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(Shape_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(Shape_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(Shape_SetParentShowHint, self.0, aValue);
      }

	  pub fn Pen(&self) -> TPen  {
          return method_Call_2!(TPen, Shape_GetPen, self.0);
      }

	  pub fn SetPen(&self, aValue: &TPen)  {
          method_Call_1!(Shape_SetPen, self.0, aValue.Instance());
      }

	  pub fn Shape(&self) -> TShapeType  {
          return method_Call_1!(Shape_GetShape, self.0);
      }

	  pub fn SetShape(&self, aValue: TShapeType)  {
          method_Call_1!(Shape_SetShape, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(Shape_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(Shape_SetShowHint, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(Shape_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(Shape_SetVisible, self.0, aValue);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(Shape_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(Shape_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(Shape_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Shape_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Shape_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Shape_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(Shape_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Shape_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, Shape_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(Shape_SetAction, self.0, aValue.Instance());
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(Shape_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(Shape_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Shape_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(Shape_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(Shape_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(Shape_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(Shape_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Shape_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(Shape_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(Shape_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(Shape_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(Shape_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(Shape_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(Shape_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(Shape_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Shape_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(Shape_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(Shape_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(Shape_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(Shape_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(Shape_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Shape_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Shape_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Shape_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Shape_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(Shape_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(Shape_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Shape_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(Shape_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Shape_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Shape_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Shape_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Shape_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Shape_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Shape_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Shape_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Shape_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Shape_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Shape_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Shape_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Shape_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Shape_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Shape_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Shape_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Shape_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, Shape_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(Shape_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Shape_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Shape_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(Shape_StaticClassType);
}

impl_IObject!(TShape);
impl_IComponent!(TShape);
impl_IControl!(TShape);

impl TBevel {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TBevel, Bevel_Create, aOwner.Instance());
      }

      impl_As_method!(TBevel);

	  impl_Free_method!(Bevel_Free);

	  pub fn BringToFront(&self) {
          method_Call_1!(Bevel_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Bevel_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Bevel_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(Bevel_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Bevel_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(Bevel_Hide, self.0);
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(Bevel_Invalidate, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(Bevel_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(Bevel_Refresh, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(Bevel_Repaint, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Bevel_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Bevel_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(Bevel_SendToBack, self.0);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(Bevel_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn Show(&self) {
          method_Call_1!(Bevel_Show, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(Bevel_Update, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(Bevel_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(Bevel_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(Bevel_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Bevel_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Bevel_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Bevel_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Bevel_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Bevel_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Bevel_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Bevel_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Bevel_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Bevel_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Bevel_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Bevel_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Bevel_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Bevel_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Bevel_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(Bevel_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(Bevel_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(Bevel_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(Bevel_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(Bevel_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(Bevel_SetAnchors, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, Bevel_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(Bevel_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(Bevel_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(Bevel_SetParentShowHint, self.0, aValue);
      }

	  pub fn Shape(&self) -> TBevelShape  {
          return method_Call_1!(Bevel_GetShape, self.0);
      }

	  pub fn SetShape(&self, aValue: TBevelShape)  {
          method_Call_1!(Bevel_SetShape, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(Bevel_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(Bevel_SetShowHint, self.0, aValue);
      }

	  pub fn Style(&self) -> TBevelStyle  {
          return method_Call_1!(Bevel_GetStyle, self.0);
      }

	  pub fn SetStyle(&self, aValue: TBevelStyle)  {
          method_Call_1!(Bevel_SetStyle, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(Bevel_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(Bevel_SetVisible, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(Bevel_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(Bevel_SetEnabled, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, Bevel_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(Bevel_SetAction, self.0, aValue.Instance());
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(Bevel_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(Bevel_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Bevel_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(Bevel_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(Bevel_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(Bevel_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(Bevel_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Bevel_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(Bevel_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(Bevel_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(Bevel_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(Bevel_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(Bevel_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(Bevel_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(Bevel_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Bevel_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(Bevel_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(Bevel_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(Bevel_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(Bevel_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(Bevel_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Bevel_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Bevel_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Bevel_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Bevel_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(Bevel_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(Bevel_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Bevel_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(Bevel_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Bevel_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Bevel_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Bevel_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Bevel_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Bevel_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Bevel_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Bevel_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Bevel_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Bevel_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Bevel_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Bevel_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Bevel_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Bevel_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Bevel_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Bevel_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Bevel_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, Bevel_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(Bevel_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Bevel_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Bevel_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(Bevel_StaticClassType);
}

impl_IObject!(TBevel);
impl_IComponent!(TBevel);
impl_IControl!(TBevel);

impl TScrollBox {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TScrollBox, ScrollBox_Create, aOwner.Instance());
      }

      impl_As_method!(TScrollBox);

	  impl_Free_method!(ScrollBox_Free);

	  pub fn ScrollInView(&self, aControl: &dyn IControl)  {
          method_Call_1!(ScrollBox_ScrollInView, self.0, aControl.Instance());
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(ScrollBox_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(ScrollBox_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, ScrollBox_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(ScrollBox_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(ScrollBox_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, ScrollBox_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(ScrollBox_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(ScrollBox_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(ScrollBox_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ScrollBox_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(ScrollBox_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ScrollBox_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(ScrollBox_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(ScrollBox_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(ScrollBox_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(ScrollBox_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(ScrollBox_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(ScrollBox_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(ScrollBox_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(ScrollBox_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ScrollBox_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ScrollBox_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(ScrollBox_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ScrollBox_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(ScrollBox_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(ScrollBox_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(ScrollBox_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ScrollBox_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ScrollBox_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(ScrollBox_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(ScrollBox_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(ScrollBox_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(ScrollBox_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(ScrollBox_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ScrollBox_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ScrollBox_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ScrollBox_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ScrollBox_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ScrollBox_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ScrollBox_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ScrollBox_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ScrollBox_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ScrollBox_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ScrollBox_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ScrollBox_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ScrollBox_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ScrollBox_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ScrollBox_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(ScrollBox_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(ScrollBox_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(ScrollBox_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(ScrollBox_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(ScrollBox_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(ScrollBox_SetAnchors, self.0, aValue);
      }

	  pub fn AutoScroll(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetAutoScroll, self.0);
      }

	  pub fn SetAutoScroll(&self, aValue: bool)  {
          method_Call_1!(ScrollBox_SetAutoScroll, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(ScrollBox_SetAutoSize, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(ScrollBox_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(ScrollBox_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(ScrollBox_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(ScrollBox_SetBorderStyle, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, ScrollBox_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(ScrollBox_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(ScrollBox_SetDockSite, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ScrollBox_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(ScrollBox_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(ScrollBox_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(ScrollBox_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(ScrollBox_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(ScrollBox_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(ScrollBox_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(ScrollBox_SetEnabled, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(ScrollBox_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(ScrollBox_SetColor, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, ScrollBox_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(ScrollBox_SetFont, self.0, aValue.Instance());
      }

	  pub fn ParentBackground(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetParentBackground, self.0);
      }

	  pub fn SetParentBackground(&self, aValue: bool)  {
          method_Call_1!(ScrollBox_SetParentBackground, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(ScrollBox_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ScrollBox_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(ScrollBox_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(ScrollBox_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, ScrollBox_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(ScrollBox_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(ScrollBox_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(ScrollBox_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(ScrollBox_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(ScrollBox_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(ScrollBox_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ScrollBox_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ScrollBox_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDockDrop(&self, aEventId: TDockDropEvent)  {
          method_Call_1!(ScrollBox_SetOnDockDrop, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(ScrollBox_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(ScrollBox_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ScrollBox_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ScrollBox_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ScrollBox_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnGetSiteInfo(&self, aEventId: TGetSiteInfoEvent)  {
          method_Call_1!(ScrollBox_SetOnGetSiteInfo, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ScrollBox_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ScrollBox_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ScrollBox_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(ScrollBox_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ScrollBox_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnMouseWheel(&self, aEventId: TMouseWheelEvent)  {
          method_Call_1!(ScrollBox_SetOnMouseWheel, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelDown(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(ScrollBox_SetOnMouseWheelDown, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelUp(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(ScrollBox_SetOnMouseWheelUp, self.0, aEventId);
      }

	  pub fn SetOnResize(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ScrollBox_SetOnResize, self.0, aEventId);
      }

	  pub fn SetOnUnDock(&self, aEventId: TUnDockEvent)  {
          method_Call_1!(ScrollBox_SetOnUnDock, self.0, aEventId);
      }

	  pub fn SetOnAlignPosition(&self, aEventId: TAlignPositionEvent)  {
          method_Call_1!(ScrollBox_SetOnAlignPosition, self.0, aEventId);
      }

	  pub fn HorzScrollBar(&self) -> TControlScrollBar  {
          return method_Call_2!(TControlScrollBar, ScrollBox_GetHorzScrollBar, self.0);
      }

	  pub fn SetHorzScrollBar(&self, aValue: &TControlScrollBar)  {
          method_Call_1!(ScrollBox_SetHorzScrollBar, self.0, aValue.Instance());
      }

	  pub fn VertScrollBar(&self) -> TControlScrollBar  {
          return method_Call_2!(TControlScrollBar, ScrollBox_GetVertScrollBar, self.0);
      }

	  pub fn SetVertScrollBar(&self, aValue: &TControlScrollBar)  {
          method_Call_1!(ScrollBox_SetVertScrollBar, self.0, aValue.Instance());
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(ScrollBox_GetDockClientCount, self.0);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(ScrollBox_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, ScrollBox_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(ScrollBox_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(ScrollBox_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(ScrollBox_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(ScrollBox_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(ScrollBox_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, ScrollBox_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(ScrollBox_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ScrollBox_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(ScrollBox_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(ScrollBox_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(ScrollBox_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ScrollBox_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ScrollBox_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(ScrollBox_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(ScrollBox_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(ScrollBox_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(ScrollBox_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(ScrollBox_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(ScrollBox_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(ScrollBox_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, ScrollBox_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(ScrollBox_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ScrollBox_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ScrollBox_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ScrollBox_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ScrollBox_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ScrollBox_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ScrollBox_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(ScrollBox_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(ScrollBox_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(ScrollBox_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(ScrollBox_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ScrollBox_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(ScrollBox_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ScrollBox_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ScrollBox_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ScrollBox_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ScrollBox_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ScrollBox_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ScrollBox_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ScrollBox_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ScrollBox_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ScrollBox_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ScrollBox_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ScrollBox_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ScrollBox_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ScrollBox_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ScrollBox_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ScrollBox_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ScrollBox_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, ScrollBox_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(ScrollBox_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, ScrollBox_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(ScrollBox_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ScrollBox_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ScrollBox_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ScrollBox_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ScrollBox_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(ScrollBox_StaticClassType);
}

impl_IObject!(TScrollBox);
impl_IComponent!(TScrollBox);
impl_IControl!(TScrollBox);
impl_IWinControl!(TScrollBox);

impl TCheckListBox {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TCheckListBox, CheckListBox_Create, aOwner.Instance());
      }

      impl_As_method!(TCheckListBox);

	  impl_Free_method!(CheckListBox_Free);

	  pub fn CheckAll(&self, aState: TCheckBoxState, allowGrayed: bool, allowDisabled: bool)  {
          method_Call_1!(CheckListBox_CheckAll, self.0, aState, allowGrayed, allowDisabled);
      }

	  pub fn AddItem(&self, item: &str, aObject: &dyn IObject)  {
          method_Call_1!(CheckListBox_AddItem, self.0, to_CString!(item), aObject.Instance());
      }

	  pub fn Clear(&self)  {
          method_Call_1!(CheckListBox_Clear, self.0);
      }

	  pub fn ClearSelection(&self)  {
          method_Call_1!(CheckListBox_ClearSelection, self.0);
      }

	  pub fn DeleteSelected(&self)  {
          method_Call_1!(CheckListBox_DeleteSelected, self.0);
      }

	  pub fn ItemAtPos(&self, pos: &TPoint, existing: bool) -> i32  {
          let mut ps1 = TPoint::From(pos);
          return method_Call_1!(CheckListBox_ItemAtPos, self.0, &mut ps1, existing);
      }

	  pub fn ItemRect(&self, index: i32) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(CheckListBox_ItemRect, self.0, index, &mut result);
          return result;
      }

	  pub fn SelectAll(&self)  {
          method_Call_1!(CheckListBox_SelectAll, self.0);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(CheckListBox_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(CheckListBox_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, CheckListBox_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(CheckListBox_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(CheckListBox_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, CheckListBox_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(CheckListBox_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(CheckListBox_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(CheckListBox_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(CheckListBox_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(CheckListBox_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(CheckListBox_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(CheckListBox_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(CheckListBox_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(CheckListBox_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(CheckListBox_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(CheckListBox_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(CheckListBox_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(CheckListBox_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(CheckListBox_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CheckListBox_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CheckListBox_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(CheckListBox_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(CheckListBox_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(CheckListBox_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(CheckListBox_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(CheckListBox_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CheckListBox_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CheckListBox_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(CheckListBox_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(CheckListBox_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(CheckListBox_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(CheckListBox_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(CheckListBox_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, CheckListBox_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CheckListBox_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(CheckListBox_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(CheckListBox_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CheckListBox_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(CheckListBox_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(CheckListBox_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(CheckListBox_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(CheckListBox_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CheckListBox_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(CheckListBox_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(CheckListBox_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(CheckListBox_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(CheckListBox_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(CheckListBox_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(CheckListBox_AnchorClient, self.0, aSpace);
      }

	  pub fn SetOnClickCheck(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckListBox_SetOnClickCheck, self.0, aEventId);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(CheckListBox_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(CheckListBox_SetAlign, self.0, aValue);
      }

	  pub fn AllowGrayed(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetAllowGrayed, self.0);
      }

	  pub fn SetAllowGrayed(&self, aValue: bool)  {
          method_Call_1!(CheckListBox_SetAllowGrayed, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(CheckListBox_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(CheckListBox_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(CheckListBox_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(CheckListBox_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(CheckListBox_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(CheckListBox_SetBorderStyle, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(CheckListBox_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(CheckListBox_SetColor, self.0, aValue);
      }

	  pub fn Columns(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetColumns, self.0);
      }

	  pub fn SetColumns(&self, aValue: i32)  {
          method_Call_1!(CheckListBox_SetColumns, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, CheckListBox_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(CheckListBox_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(CheckListBox_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(CheckListBox_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(CheckListBox_SetDragCursor, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(CheckListBox_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(CheckListBox_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(CheckListBox_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, CheckListBox_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(CheckListBox_SetFont, self.0, aValue.Instance());
      }

	  pub fn ItemHeight(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetItemHeight, self.0);
      }

	  pub fn SetItemHeight(&self, aValue: i32)  {
          method_Call_1!(CheckListBox_SetItemHeight, self.0, aValue);
      }

	  pub fn Items(&self) -> TStrings  {
          return method_Call_2!(TStrings, CheckListBox_GetItems, self.0);
      }

	  pub fn SetItems(&self, aValue: &dyn IStrings)  {
          method_Call_1!(CheckListBox_SetItems, self.0, aValue.Instance());
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(CheckListBox_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(CheckListBox_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(CheckListBox_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(CheckListBox_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, CheckListBox_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(CheckListBox_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(CheckListBox_SetShowHint, self.0, aValue);
      }

	  pub fn Sorted(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetSorted, self.0);
      }

	  pub fn SetSorted(&self, aValue: bool)  {
          method_Call_1!(CheckListBox_SetSorted, self.0, aValue);
      }

	  pub fn Style(&self) -> TListBoxStyle  {
          return method_Call_1!(CheckListBox_GetStyle, self.0);
      }

	  pub fn SetStyle(&self, aValue: TListBoxStyle)  {
          method_Call_1!(CheckListBox_SetStyle, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(CheckListBox_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(CheckListBox_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(CheckListBox_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(CheckListBox_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckListBox_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(CheckListBox_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckListBox_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(CheckListBox_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(CheckListBox_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(CheckListBox_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckListBox_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckListBox_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(CheckListBox_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(CheckListBox_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(CheckListBox_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMeasureItem(&self, aEventId: TMeasureItemEvent)  {
          method_Call_1!(CheckListBox_SetOnMeasureItem, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(CheckListBox_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckListBox_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckListBox_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(CheckListBox_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(CheckListBox_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, CheckListBox_GetCanvas, self.0);
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetCount, self.0);
      }

	  pub fn TopIndex(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetTopIndex, self.0);
      }

	  pub fn SetTopIndex(&self, aValue: i32)  {
          method_Call_1!(CheckListBox_SetTopIndex, self.0, aValue);
      }

	  pub fn MultiSelect(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetMultiSelect, self.0);
      }

	  pub fn SetMultiSelect(&self, aValue: bool)  {
          method_Call_1!(CheckListBox_SetMultiSelect, self.0, aValue);
      }

	  pub fn SelCount(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetSelCount, self.0);
      }

	  pub fn ItemIndex(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetItemIndex, self.0);
      }

	  pub fn SetItemIndex(&self, aValue: i32)  {
          method_Call_1!(CheckListBox_SetItemIndex, self.0, aValue);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(CheckListBox_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, CheckListBox_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(CheckListBox_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(CheckListBox_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(CheckListBox_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(CheckListBox_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, CheckListBox_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(CheckListBox_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(CheckListBox_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(CheckListBox_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(CheckListBox_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(CheckListBox_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(CheckListBox_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(CheckListBox_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(CheckListBox_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(CheckListBox_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(CheckListBox_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(CheckListBox_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(CheckListBox_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, CheckListBox_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(CheckListBox_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(CheckListBox_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(CheckListBox_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(CheckListBox_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(CheckListBox_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(CheckListBox_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(CheckListBox_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CheckListBox_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(CheckListBox_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(CheckListBox_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(CheckListBox_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, CheckListBox_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CheckListBox_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(CheckListBox_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(CheckListBox_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(CheckListBox_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CheckListBox_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CheckListBox_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CheckListBox_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CheckListBox_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CheckListBox_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CheckListBox_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CheckListBox_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CheckListBox_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, CheckListBox_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(CheckListBox_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, CheckListBox_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(CheckListBox_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Checked(&self, index: i32) -> bool  {
          return method_Call_1!(CheckListBox_GetChecked, self.0, index);
      }

	  pub fn SetChecked(&self, index: i32, aValue: bool)  {
          method_Call_1!(CheckListBox_SetChecked, self.0, index, aValue);
      }

	  pub fn ItemEnabled(&self, index: i32) -> bool  {
          return method_Call_1!(CheckListBox_GetItemEnabled, self.0, index);
      }

	  pub fn SetItemEnabled(&self, index: i32, aValue: bool)  {
          method_Call_1!(CheckListBox_SetItemEnabled, self.0, index, aValue);
      }

	  pub fn State(&self, index: i32) -> TCheckBoxState  {
          return method_Call_1!(CheckListBox_GetState, self.0, index);
      }

	  pub fn SetState(&self, index: i32, aValue: TCheckBoxState)  {
          method_Call_1!(CheckListBox_SetState, self.0, index, aValue);
      }

	  pub fn Header(&self, index: i32) -> bool  {
          return method_Call_1!(CheckListBox_GetHeader, self.0, index);
      }

	  pub fn SetHeader(&self, index: i32, aValue: bool)  {
          method_Call_1!(CheckListBox_SetHeader, self.0, index, aValue);
      }

	  pub fn Selected(&self, index: i32) -> bool  {
          return method_Call_1!(CheckListBox_GetSelected, self.0, index);
      }

	  pub fn SetSelected(&self, index: i32, aValue: bool)  {
          method_Call_1!(CheckListBox_SetSelected, self.0, index, aValue);
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, CheckListBox_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, CheckListBox_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, CheckListBox_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CheckListBox_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(CheckListBox_StaticClassType);
}

impl_IObject!(TCheckListBox);
impl_IComponent!(TCheckListBox);
impl_IControl!(TCheckListBox);
impl_IWinControl!(TCheckListBox);

impl TGauge {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TGauge, Gauge_Create, aOwner.Instance());
      }

      impl_As_method!(TGauge);

	  impl_Free_method!(Gauge_Free);

	  pub fn AddProgress(&self, value: i32)  {
          method_Call_1!(Gauge_AddProgress, self.0, value);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(Gauge_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Gauge_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Gauge_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(Gauge_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Gauge_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(Gauge_Hide, self.0);
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(Gauge_Invalidate, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(Gauge_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(Gauge_Refresh, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(Gauge_Repaint, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Gauge_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Gauge_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(Gauge_SendToBack, self.0);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(Gauge_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn Show(&self) {
          method_Call_1!(Gauge_Show, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(Gauge_Update, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(Gauge_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(Gauge_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(Gauge_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Gauge_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Gauge_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Gauge_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Gauge_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Gauge_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Gauge_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Gauge_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Gauge_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Gauge_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Gauge_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Gauge_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Gauge_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Gauge_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Gauge_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(Gauge_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(Gauge_AnchorClient, self.0, aSpace);
      }

	  pub fn PercentDone(&self) -> i32  {
          return method_Call_1!(Gauge_GetPercentDone, self.0);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(Gauge_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(Gauge_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(Gauge_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(Gauge_SetAnchors, self.0, aValue);
      }

	  pub fn BackColor(&self) -> TColor  {
          return method_Call_1!(Gauge_GetBackColor, self.0);
      }

	  pub fn SetBackColor(&self, aValue: TColor)  {
          method_Call_1!(Gauge_SetBackColor, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(Gauge_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(Gauge_SetBorderStyle, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(Gauge_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(Gauge_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, Gauge_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(Gauge_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(Gauge_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(Gauge_SetEnabled, self.0, aValue);
      }

	  pub fn ForeColor(&self) -> TColor  {
          return method_Call_1!(Gauge_GetForeColor, self.0);
      }

	  pub fn SetForeColor(&self, aValue: TColor)  {
          method_Call_1!(Gauge_SetForeColor, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, Gauge_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(Gauge_SetFont, self.0, aValue.Instance());
      }

	  pub fn MinValue(&self) -> i32  {
          return method_Call_1!(Gauge_GetMinValue, self.0);
      }

	  pub fn SetMinValue(&self, aValue: i32)  {
          method_Call_1!(Gauge_SetMinValue, self.0, aValue);
      }

	  pub fn MaxValue(&self) -> i32  {
          return method_Call_1!(Gauge_GetMaxValue, self.0);
      }

	  pub fn SetMaxValue(&self, aValue: i32)  {
          method_Call_1!(Gauge_SetMaxValue, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(Gauge_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(Gauge_SetParentColor, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(Gauge_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(Gauge_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(Gauge_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(Gauge_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, Gauge_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(Gauge_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn Progress(&self) -> i32  {
          return method_Call_1!(Gauge_GetProgress, self.0);
      }

	  pub fn SetProgress(&self, aValue: i32)  {
          method_Call_1!(Gauge_SetProgress, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(Gauge_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(Gauge_SetShowHint, self.0, aValue);
      }

	  pub fn ShowText(&self) -> bool  {
          return method_Call_1!(Gauge_GetShowText, self.0);
      }

	  pub fn SetShowText(&self, aValue: bool)  {
          method_Call_1!(Gauge_SetShowText, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(Gauge_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(Gauge_SetVisible, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, Gauge_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(Gauge_SetAction, self.0, aValue.Instance());
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(Gauge_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(Gauge_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Gauge_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(Gauge_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(Gauge_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(Gauge_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(Gauge_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Gauge_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(Gauge_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(Gauge_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(Gauge_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(Gauge_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(Gauge_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(Gauge_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(Gauge_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Gauge_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(Gauge_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(Gauge_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(Gauge_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(Gauge_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(Gauge_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Gauge_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Gauge_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Gauge_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Gauge_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(Gauge_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(Gauge_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Gauge_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(Gauge_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Gauge_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Gauge_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Gauge_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Gauge_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Gauge_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Gauge_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Gauge_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Gauge_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Gauge_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Gauge_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Gauge_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Gauge_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Gauge_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Gauge_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Gauge_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Gauge_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, Gauge_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(Gauge_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Gauge_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Gauge_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(Gauge_StaticClassType);
}

impl_IObject!(TGauge);
impl_IComponent!(TGauge);
impl_IControl!(TGauge);

impl TImageButton {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TImageButton, ImageButton_Create, aOwner.Instance());
      }

      impl_As_method!(TImageButton);

	  impl_Free_method!(ImageButton_Free);

	  pub fn Click(&self)  {
          method_Call_1!(ImageButton_Click, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(ImageButton_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ImageButton_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ImageButton_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(ImageButton_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ImageButton_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(ImageButton_Hide, self.0);
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(ImageButton_Invalidate, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(ImageButton_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(ImageButton_Refresh, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(ImageButton_Repaint, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ImageButton_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ImageButton_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(ImageButton_SendToBack, self.0);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(ImageButton_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn Show(&self) {
          method_Call_1!(ImageButton_Show, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(ImageButton_Update, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(ImageButton_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(ImageButton_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(ImageButton_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ImageButton_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ImageButton_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ImageButton_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ImageButton_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ImageButton_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ImageButton_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ImageButton_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ImageButton_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ImageButton_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ImageButton_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ImageButton_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ImageButton_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ImageButton_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ImageButton_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(ImageButton_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(ImageButton_AnchorClient, self.0, aSpace);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, ImageButton_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(ImageButton_SetAction, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(ImageButton_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(ImageButton_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(ImageButton_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(ImageButton_SetAnchors, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(ImageButton_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(ImageButton_SetAutoSize, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, ImageButton_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(ImageButton_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ImageButton_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(ImageButton_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(ImageButton_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(ImageButton_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(ImageButton_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(ImageButton_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(ImageButton_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(ImageButton_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(ImageButton_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(ImageButton_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, ImageButton_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(ImageButton_SetFont, self.0, aValue.Instance());
      }

	  pub fn ImageCount(&self) -> i32  {
          return method_Call_1!(ImageButton_GetImageCount, self.0);
      }

	  pub fn SetImageCount(&self, aValue: i32)  {
          method_Call_1!(ImageButton_SetImageCount, self.0, aValue);
      }

	  pub fn ModalResult(&self) -> TModalResult  {
          return method_Call_1!(ImageButton_GetModalResult, self.0);
      }

	  pub fn SetModalResult(&self, aValue: TModalResult)  {
          method_Call_1!(ImageButton_SetModalResult, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(ImageButton_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(ImageButton_SetParentShowHint, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(ImageButton_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(ImageButton_SetParentFont, self.0, aValue);
      }

	  pub fn Picture(&self) -> TPicture  {
          return method_Call_2!(TPicture, ImageButton_GetPicture, self.0);
      }

	  pub fn SetPicture(&self, aValue: &TPicture)  {
          method_Call_1!(ImageButton_SetPicture, self.0, aValue.Instance());
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, ImageButton_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(ImageButton_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(ImageButton_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(ImageButton_SetShowHint, self.0, aValue);
      }

	  pub fn ShowCaption(&self) -> bool  {
          return method_Call_1!(ImageButton_GetShowCaption, self.0);
      }

	  pub fn SetShowCaption(&self, aValue: bool)  {
          method_Call_1!(ImageButton_SetShowCaption, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(ImageButton_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(ImageButton_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ImageButton_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(ImageButton_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ImageButton_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(ImageButton_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(ImageButton_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ImageButton_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ImageButton_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ImageButton_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ImageButton_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ImageButton_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(ImageButton_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ImageButton_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(ImageButton_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(ImageButton_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ImageButton_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(ImageButton_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(ImageButton_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(ImageButton_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ImageButton_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ImageButton_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(ImageButton_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(ImageButton_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(ImageButton_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(ImageButton_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(ImageButton_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(ImageButton_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(ImageButton_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, ImageButton_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(ImageButton_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ImageButton_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ImageButton_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ImageButton_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ImageButton_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ImageButton_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ImageButton_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(ImageButton_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(ImageButton_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(ImageButton_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(ImageButton_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ImageButton_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(ImageButton_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ImageButton_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ImageButton_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ImageButton_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ImageButton_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ImageButton_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ImageButton_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ImageButton_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ImageButton_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ImageButton_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ImageButton_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ImageButton_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ImageButton_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ImageButton_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ImageButton_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ImageButton_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ImageButton_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, ImageButton_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(ImageButton_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ImageButton_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ImageButton_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(ImageButton_StaticClassType);
}

impl_IObject!(TImageButton);
impl_IComponent!(TImageButton);
impl_IControl!(TImageButton);

impl TFindDialog {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TFindDialog, FindDialog_Create, aOwner.Instance());
      }

      impl_As_method!(TFindDialog);

	  impl_Free_method!(FindDialog_Free);

	  pub fn CloseDialog(&self)  {
          method_Call_1!(FindDialog_CloseDialog, self.0);
      }

	  pub fn Execute(&self) -> bool  {
          return method_Call_1!(FindDialog_Execute, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, FindDialog_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(FindDialog_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(FindDialog_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(FindDialog_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(FindDialog_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(FindDialog_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(FindDialog_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(FindDialog_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(FindDialog_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(FindDialog_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(FindDialog_ToString, self.0));
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(FindDialog_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(FindDialog_SetLeft, self.0, aValue);
      }

	  pub fn Position(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(FindDialog_GetPosition, self.0, &mut result);
          return result;
      }

	  pub fn SetPosition(&self, aValue: *mut TPoint)  {
          method_Call_1!(FindDialog_SetPosition, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(FindDialog_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(FindDialog_SetTop, self.0, aValue);
      }

	  pub fn FindText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(FindDialog_GetFindText, self.0));
      }

	  pub fn SetFindText(&self, aValue: &str)  {
          method_Call_1!(FindDialog_SetFindText, self.0, to_CString!(aValue));
      }

	  pub fn Options(&self) -> TFindOptions  {
          return method_Call_1!(FindDialog_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TFindOptions)  {
          method_Call_1!(FindDialog_SetOptions, self.0, aValue);
      }

	  pub fn SetOnFind(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(FindDialog_SetOnFind, self.0, aEventId);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(FindDialog_GetHandle, self.0);
      }

	  pub fn SetOnClose(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(FindDialog_SetOnClose, self.0, aEventId);
      }

	  pub fn SetOnShow(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(FindDialog_SetOnShow, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(FindDialog_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(FindDialog_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(FindDialog_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, FindDialog_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(FindDialog_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(FindDialog_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(FindDialog_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(FindDialog_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, FindDialog_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(FindDialog_StaticClassType);
}

impl_IObject!(TFindDialog);
impl_IComponent!(TFindDialog);

impl TReplaceDialog {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TReplaceDialog, ReplaceDialog_Create, aOwner.Instance());
      }

      impl_As_method!(TReplaceDialog);

	  impl_Free_method!(ReplaceDialog_Free);

	  pub fn CloseDialog(&self)  {
          method_Call_1!(ReplaceDialog_CloseDialog, self.0);
      }

	  pub fn Execute(&self) -> bool  {
          return method_Call_1!(ReplaceDialog_Execute, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ReplaceDialog_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ReplaceDialog_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ReplaceDialog_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ReplaceDialog_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ReplaceDialog_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ReplaceDialog_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ReplaceDialog_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ReplaceDialog_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ReplaceDialog_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ReplaceDialog_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ReplaceDialog_ToString, self.0));
      }

	  pub fn ReplaceText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ReplaceDialog_GetReplaceText, self.0));
      }

	  pub fn SetReplaceText(&self, aValue: &str)  {
          method_Call_1!(ReplaceDialog_SetReplaceText, self.0, to_CString!(aValue));
      }

	  pub fn SetOnReplace(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ReplaceDialog_SetOnReplace, self.0, aEventId);
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ReplaceDialog_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ReplaceDialog_SetLeft, self.0, aValue);
      }

	  pub fn Position(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ReplaceDialog_GetPosition, self.0, &mut result);
          return result;
      }

	  pub fn SetPosition(&self, aValue: *mut TPoint)  {
          method_Call_1!(ReplaceDialog_SetPosition, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ReplaceDialog_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ReplaceDialog_SetTop, self.0, aValue);
      }

	  pub fn FindText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ReplaceDialog_GetFindText, self.0));
      }

	  pub fn SetFindText(&self, aValue: &str)  {
          method_Call_1!(ReplaceDialog_SetFindText, self.0, to_CString!(aValue));
      }

	  pub fn Options(&self) -> TFindOptions  {
          return method_Call_1!(ReplaceDialog_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TFindOptions)  {
          method_Call_1!(ReplaceDialog_SetOptions, self.0, aValue);
      }

	  pub fn SetOnFind(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ReplaceDialog_SetOnFind, self.0, aEventId);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(ReplaceDialog_GetHandle, self.0);
      }

	  pub fn SetOnClose(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ReplaceDialog_SetOnClose, self.0, aEventId);
      }

	  pub fn SetOnShow(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ReplaceDialog_SetOnShow, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ReplaceDialog_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ReplaceDialog_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ReplaceDialog_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ReplaceDialog_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ReplaceDialog_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ReplaceDialog_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ReplaceDialog_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ReplaceDialog_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ReplaceDialog_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(ReplaceDialog_StaticClassType);
}

impl_IObject!(TReplaceDialog);
impl_IComponent!(TReplaceDialog);

impl TPrinterSetupDialog {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TPrinterSetupDialog, PrinterSetupDialog_Create, aOwner.Instance());
      }

      impl_As_method!(TPrinterSetupDialog);

	  impl_Free_method!(PrinterSetupDialog_Free);

	  pub fn Execute(&self) -> bool  {
          return method_Call_1!(PrinterSetupDialog_Execute, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, PrinterSetupDialog_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PrinterSetupDialog_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(PrinterSetupDialog_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(PrinterSetupDialog_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(PrinterSetupDialog_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PrinterSetupDialog_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(PrinterSetupDialog_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(PrinterSetupDialog_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(PrinterSetupDialog_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(PrinterSetupDialog_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PrinterSetupDialog_ToString, self.0));
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(PrinterSetupDialog_GetHandle, self.0);
      }

	  pub fn SetOnClose(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PrinterSetupDialog_SetOnClose, self.0, aEventId);
      }

	  pub fn SetOnShow(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PrinterSetupDialog_SetOnShow, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(PrinterSetupDialog_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(PrinterSetupDialog_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(PrinterSetupDialog_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, PrinterSetupDialog_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(PrinterSetupDialog_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(PrinterSetupDialog_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(PrinterSetupDialog_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(PrinterSetupDialog_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, PrinterSetupDialog_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(PrinterSetupDialog_StaticClassType);
}

impl_IObject!(TPrinterSetupDialog);
impl_IComponent!(TPrinterSetupDialog);

impl TPageSetupDialog {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TPageSetupDialog, PageSetupDialog_Create, aOwner.Instance());
      }

      impl_As_method!(TPageSetupDialog);

	  impl_Free_method!(PageSetupDialog_Free);

	  pub fn Execute(&self) -> bool  {
          return method_Call_1!(PageSetupDialog_Execute, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, PageSetupDialog_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PageSetupDialog_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(PageSetupDialog_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(PageSetupDialog_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(PageSetupDialog_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PageSetupDialog_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(PageSetupDialog_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(PageSetupDialog_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(PageSetupDialog_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(PageSetupDialog_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(PageSetupDialog_ToString, self.0));
      }

	  pub fn MarginLeft(&self) -> i32  {
          return method_Call_1!(PageSetupDialog_GetMarginLeft, self.0);
      }

	  pub fn SetMarginLeft(&self, aValue: i32)  {
          method_Call_1!(PageSetupDialog_SetMarginLeft, self.0, aValue);
      }

	  pub fn MarginTop(&self) -> i32  {
          return method_Call_1!(PageSetupDialog_GetMarginTop, self.0);
      }

	  pub fn SetMarginTop(&self, aValue: i32)  {
          method_Call_1!(PageSetupDialog_SetMarginTop, self.0, aValue);
      }

	  pub fn MarginRight(&self) -> i32  {
          return method_Call_1!(PageSetupDialog_GetMarginRight, self.0);
      }

	  pub fn SetMarginRight(&self, aValue: i32)  {
          method_Call_1!(PageSetupDialog_SetMarginRight, self.0, aValue);
      }

	  pub fn MarginBottom(&self) -> i32  {
          return method_Call_1!(PageSetupDialog_GetMarginBottom, self.0);
      }

	  pub fn SetMarginBottom(&self, aValue: i32)  {
          method_Call_1!(PageSetupDialog_SetMarginBottom, self.0, aValue);
      }

	  pub fn Options(&self) -> TPageSetupDialogOptions  {
          return method_Call_1!(PageSetupDialog_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TPageSetupDialogOptions)  {
          method_Call_1!(PageSetupDialog_SetOptions, self.0, aValue);
      }

	  pub fn PageWidth(&self) -> i32  {
          return method_Call_1!(PageSetupDialog_GetPageWidth, self.0);
      }

	  pub fn SetPageWidth(&self, aValue: i32)  {
          method_Call_1!(PageSetupDialog_SetPageWidth, self.0, aValue);
      }

	  pub fn PageHeight(&self) -> i32  {
          return method_Call_1!(PageSetupDialog_GetPageHeight, self.0);
      }

	  pub fn SetPageHeight(&self, aValue: i32)  {
          method_Call_1!(PageSetupDialog_SetPageHeight, self.0, aValue);
      }

	  pub fn Units(&self) -> TPageMeasureUnits  {
          return method_Call_1!(PageSetupDialog_GetUnits, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(PageSetupDialog_GetHandle, self.0);
      }

	  pub fn SetOnClose(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PageSetupDialog_SetOnClose, self.0, aEventId);
      }

	  pub fn SetOnShow(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(PageSetupDialog_SetOnShow, self.0, aEventId);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(PageSetupDialog_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(PageSetupDialog_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(PageSetupDialog_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, PageSetupDialog_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(PageSetupDialog_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(PageSetupDialog_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(PageSetupDialog_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(PageSetupDialog_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, PageSetupDialog_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(PageSetupDialog_StaticClassType);
}

impl_IObject!(TPageSetupDialog);
impl_IComponent!(TPageSetupDialog);

impl TDragObject {
      pub fn new(aOwner: &dyn IControl) -> Self {
        method_Create!(TDragObject, DragObject_Create, aOwner.Instance());
      }

      impl_As_method!(TDragObject);

	  impl_Free_method!(DragObject_Free);

	  pub fn Assign(&self, source: &TDragObject)  {
          method_Call_1!(DragObject_Assign, self.0, source.Instance());
      }

	  pub fn HideDragImage(&self)  {
          method_Call_1!(DragObject_HideDragImage, self.0);
      }

	  pub fn ShowDragImage(&self)  {
          method_Call_1!(DragObject_ShowDragImage, self.0);
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(DragObject_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(DragObject_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(DragObject_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(DragObject_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(DragObject_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(DragObject_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(DragObject_ToString, self.0));
      }

	  pub fn AlwaysShowDragImages(&self) -> bool  {
          return method_Call_1!(DragObject_GetAlwaysShowDragImages, self.0);
      }

	  pub fn SetAlwaysShowDragImages(&self, aValue: bool)  {
          method_Call_1!(DragObject_SetAlwaysShowDragImages, self.0, aValue);
      }

	  pub fn DragPos(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(DragObject_GetDragPos, self.0, &mut result);
          return result;
      }

	  pub fn SetDragPos(&self, aValue: *mut TPoint)  {
          method_Call_1!(DragObject_SetDragPos, self.0, aValue);
      }

	  pub fn DragTarget(&self) -> usize  {
          return method_Call_1!(DragObject_GetDragTarget, self.0);
      }

	  pub fn SetDragTarget(&self, aValue: usize)  {
          method_Call_1!(DragObject_SetDragTarget, self.0, aValue);
      }

	  pub fn DragTargetPos(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(DragObject_GetDragTargetPos, self.0, &mut result);
          return result;
      }

	  pub fn SetDragTargetPos(&self, aValue: *mut TPoint)  {
          method_Call_1!(DragObject_SetDragTargetPos, self.0, aValue);
      }

	  pub fn Dropped(&self) -> bool  {
          return method_Call_1!(DragObject_GetDropped, self.0);
      }

      // static class
	  impl_Class_method!(DragObject_StaticClassType);
}

impl_IObject!(TDragObject);
impl_Drop_method!(TDragObject);

impl TDragDockObject {
      pub fn new(aOwner: &dyn IControl) -> Self {
        method_Create!(TDragDockObject, DragDockObject_Create, aOwner.Instance());
      }

      impl_As_method!(TDragDockObject);

	  impl_Free_method!(DragDockObject_Free);

	  pub fn Assign(&self, source: &TDragObject)  {
          method_Call_1!(DragDockObject_Assign, self.0, source.Instance());
      }

	  pub fn HideDragImage(&self)  {
          method_Call_1!(DragDockObject_HideDragImage, self.0);
      }

	  pub fn ShowDragImage(&self)  {
          method_Call_1!(DragDockObject_ShowDragImage, self.0);
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(DragDockObject_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(DragDockObject_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(DragDockObject_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(DragDockObject_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(DragDockObject_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(DragDockObject_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(DragDockObject_ToString, self.0));
      }

	  pub fn DockRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(DragDockObject_GetDockRect, self.0, &mut result);
          return result;
      }

	  pub fn SetDockRect(&self, aValue: *mut TRect)  {
          method_Call_1!(DragDockObject_SetDockRect, self.0, aValue);
      }

	  pub fn DropAlign(&self) -> TAlign  {
          return method_Call_1!(DragDockObject_GetDropAlign, self.0);
      }

	  pub fn DropOnControl(&self) -> TControl  {
          return method_Call_2!(TControl, DragDockObject_GetDropOnControl, self.0);
      }

	  pub fn EraseDockRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(DragDockObject_GetEraseDockRect, self.0, &mut result);
          return result;
      }

	  pub fn SetEraseDockRect(&self, aValue: *mut TRect)  {
          method_Call_1!(DragDockObject_SetEraseDockRect, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(DragDockObject_GetFloating, self.0);
      }

	  pub fn SetFloating(&self, aValue: bool)  {
          method_Call_1!(DragDockObject_SetFloating, self.0, aValue);
      }

	  pub fn Control(&self) -> TControl  {
          return method_Call_2!(TControl, DragDockObject_GetControl, self.0);
      }

	  pub fn SetControl(&self, aValue: &dyn IControl)  {
          method_Call_1!(DragDockObject_SetControl, self.0, aValue.Instance());
      }

	  pub fn AlwaysShowDragImages(&self) -> bool  {
          return method_Call_1!(DragDockObject_GetAlwaysShowDragImages, self.0);
      }

	  pub fn SetAlwaysShowDragImages(&self, aValue: bool)  {
          method_Call_1!(DragDockObject_SetAlwaysShowDragImages, self.0, aValue);
      }

	  pub fn DragPos(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(DragDockObject_GetDragPos, self.0, &mut result);
          return result;
      }

	  pub fn SetDragPos(&self, aValue: *mut TPoint)  {
          method_Call_1!(DragDockObject_SetDragPos, self.0, aValue);
      }

	  pub fn DragTarget(&self) -> usize  {
          return method_Call_1!(DragDockObject_GetDragTarget, self.0);
      }

	  pub fn SetDragTarget(&self, aValue: usize)  {
          method_Call_1!(DragDockObject_SetDragTarget, self.0, aValue);
      }

	  pub fn DragTargetPos(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(DragDockObject_GetDragTargetPos, self.0, &mut result);
          return result;
      }

	  pub fn SetDragTargetPos(&self, aValue: *mut TPoint)  {
          method_Call_1!(DragDockObject_SetDragTargetPos, self.0, aValue);
      }

	  pub fn Dropped(&self) -> bool  {
          return method_Call_1!(DragDockObject_GetDropped, self.0);
      }

      // static class
	  impl_Class_method!(DragDockObject_StaticClassType);
}

impl_IObject!(TDragDockObject);
impl_Drop_method!(TDragDockObject);

impl TStringGrid {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TStringGrid, StringGrid_Create, aOwner.Instance());
      }

      impl_As_method!(TStringGrid);

	  impl_Free_method!(StringGrid_Free);

	  pub fn DeleteColRow(&self, isColumn: bool, index: i32)  {
          method_Call_1!(StringGrid_DeleteColRow, self.0, isColumn, index);
      }

	  pub fn DeleteCol(&self, index: i32)  {
          method_Call_1!(StringGrid_DeleteCol, self.0, index);
      }

	  pub fn DeleteRow(&self, index: i32)  {
          method_Call_1!(StringGrid_DeleteRow, self.0, index);
      }

	  pub fn ExchangeColRow(&self, isColumn: bool, index: i32, withIndex: i32)  {
          method_Call_1!(StringGrid_ExchangeColRow, self.0, isColumn, index, withIndex);
      }

	  pub fn InsertColRow(&self, isColumn: bool, index: i32)  {
          method_Call_1!(StringGrid_InsertColRow, self.0, isColumn, index);
      }

	  pub fn MoveColRow(&self, isColumn: bool, fromIndex: i32, toIndex: i32)  {
          method_Call_1!(StringGrid_MoveColRow, self.0, isColumn, fromIndex, toIndex);
      }

	  pub fn SortColRow(&self, isColumn: bool, index: i32, fromIndex: i32, toIndex: i32)  {
          method_Call_1!(StringGrid_SortColRow, self.0, isColumn, index, fromIndex, toIndex);
      }

	  pub fn EditorByStyle(&self, style: TColumnButtonStyle) -> TWinControl  {
          return method_Call_2!(TWinControl, StringGrid_EditorByStyle, self.0, style);
      }

	  pub fn EditorKeyDown(&self, sender: &dyn IObject, key: *mut u16, shift: TShiftState)  {
          method_Call_1!(StringGrid_EditorKeyDown, self.0, sender.Instance(), key, shift);
      }

	  pub fn EditorKeyPress(&self, sender: &dyn IObject, key: *mut Char)  {
          method_Call_1!(StringGrid_EditorKeyPress, self.0, sender.Instance(), key);
      }

	  pub fn EditorKeyUp(&self, sender: &dyn IObject, key: *mut u16, shift: TShiftState)  {
          method_Call_1!(StringGrid_EditorKeyUp, self.0, sender.Instance(), key, shift);
      }

	  pub fn EditorTextChanged(&self, aCol: i32, aRow: i32, aText: &str)  {
          method_Call_1!(StringGrid_EditorTextChanged, self.0, aCol, aRow, to_CString!(aText));
      }

	  pub fn EditingDone(&self)  {
          method_Call_1!(StringGrid_EditingDone, self.0);
      }

	  pub fn AutoAdjustColumns(&self)  {
          method_Call_1!(StringGrid_AutoAdjustColumns, self.0);
      }

	  pub fn CellRect(&self, aCol: i32, aRow: i32) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(StringGrid_CellRect, self.0, aCol, aRow, &mut result);
          return result;
      }

	  pub fn CellToGridZone(&self, aCol: i32, aRow: i32) -> TGridZone  {
          return method_Call_1!(StringGrid_CellToGridZone, self.0, aCol, aRow);
      }

	  pub fn CheckPosition(&self)  {
          method_Call_1!(StringGrid_CheckPosition, self.0);
      }

	  pub fn ClearCols(&self) -> bool  {
          return method_Call_1!(StringGrid_ClearCols, self.0);
      }

	  pub fn ClearRows(&self) -> bool  {
          return method_Call_1!(StringGrid_ClearRows, self.0);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(StringGrid_Clear, self.0);
      }

	  pub fn ClearSelections(&self)  {
          method_Call_1!(StringGrid_ClearSelections, self.0);
      }

	  pub fn HasMultiSelection(&self) -> bool  {
          return method_Call_1!(StringGrid_HasMultiSelection, self.0);
      }

	  pub fn InvalidateCell(&self, aCol: i32, aRow: i32)  {
          method_Call_1!(StringGrid_InvalidateCell, self.0, aCol, aRow);
      }

	  pub fn InvalidateCol(&self, aCol: i32)  {
          method_Call_1!(StringGrid_InvalidateCol, self.0, aCol);
      }

	  pub fn InvalidateRange(&self, aRange: &TRect)  {
          let mut ps1 = TRect::From(aRange);
          method_Call_1!(StringGrid_InvalidateRange, self.0, &mut ps1);
      }

	  pub fn InvalidateRow(&self, aRow: i32)  {
          method_Call_1!(StringGrid_InvalidateRow, self.0, aRow);
      }

	  pub fn IsCellVisible(&self, aCol: i32, aRow: i32) -> bool  {
          return method_Call_1!(StringGrid_IsCellVisible, self.0, aCol, aRow);
      }

	  pub fn IsFixedCellVisible(&self, aCol: i32, aRow: i32) -> bool  {
          return method_Call_1!(StringGrid_IsFixedCellVisible, self.0, aCol, aRow);
      }

	  pub fn MouseCoord(&self, x: i32, y: i32) -> TGridCoord  {
          let mut result = TGridCoord::Empty();
          method_Call_1!(StringGrid_MouseCoord, self.0, x, y, &mut result);
          return result;
      }

	  pub fn MouseToCell(&self, mouse: &TPoint) -> TPoint  {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(mouse);
          method_Call_1!(StringGrid_MouseToCell, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn MouseToLogcell(&self, mouse: &TPoint) -> TPoint  {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(mouse);
          method_Call_1!(StringGrid_MouseToLogcell, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn MouseToGridZone(&self, x: i32, y: i32) -> TGridZone  {
          return method_Call_1!(StringGrid_MouseToGridZone, self.0, x, y);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(StringGrid_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(StringGrid_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, StringGrid_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(StringGrid_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(StringGrid_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, StringGrid_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(StringGrid_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(StringGrid_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(StringGrid_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(StringGrid_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(StringGrid_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(StringGrid_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(StringGrid_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(StringGrid_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(StringGrid_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(StringGrid_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(StringGrid_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(StringGrid_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(StringGrid_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(StringGrid_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(StringGrid_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(StringGrid_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(StringGrid_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(StringGrid_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(StringGrid_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(StringGrid_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(StringGrid_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(StringGrid_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(StringGrid_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(StringGrid_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(StringGrid_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(StringGrid_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(StringGrid_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(StringGrid_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, StringGrid_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StringGrid_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(StringGrid_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(StringGrid_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StringGrid_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(StringGrid_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(StringGrid_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(StringGrid_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(StringGrid_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(StringGrid_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(StringGrid_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(StringGrid_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(StringGrid_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(StringGrid_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(StringGrid_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(StringGrid_AnchorClient, self.0, aSpace);
      }

	  pub fn SelectedColor(&self) -> TColor  {
          return method_Call_1!(StringGrid_GetSelectedColor, self.0);
      }

	  pub fn SetSelectedColor(&self, aValue: TColor)  {
          method_Call_1!(StringGrid_SetSelectedColor, self.0, aValue);
      }

	  pub fn SelectedColumn(&self) -> TGridColumn  {
          return method_Call_2!(TGridColumn, StringGrid_GetSelectedColumn, self.0);
      }

	  pub fn StrictSort(&self) -> bool  {
          return method_Call_1!(StringGrid_GetStrictSort, self.0);
      }

	  pub fn SetStrictSort(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetStrictSort, self.0, aValue);
      }

	  pub fn FixedHotColor(&self) -> TColor  {
          return method_Call_1!(StringGrid_GetFixedHotColor, self.0);
      }

	  pub fn SetFixedHotColor(&self, aValue: TColor)  {
          method_Call_1!(StringGrid_SetFixedHotColor, self.0, aValue);
      }

	  pub fn FastEditing(&self) -> bool  {
          return method_Call_1!(StringGrid_GetFastEditing, self.0);
      }

	  pub fn SetFastEditing(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetFastEditing, self.0, aValue);
      }

	  pub fn FixedGridLineColor(&self) -> TColor  {
          return method_Call_1!(StringGrid_GetFixedGridLineColor, self.0);
      }

	  pub fn SetFixedGridLineColor(&self, aValue: TColor)  {
          method_Call_1!(StringGrid_SetFixedGridLineColor, self.0, aValue);
      }

	  pub fn FocusColor(&self) -> TColor  {
          return method_Call_1!(StringGrid_GetFocusColor, self.0);
      }

	  pub fn SetFocusColor(&self, aValue: TColor)  {
          method_Call_1!(StringGrid_SetFocusColor, self.0, aValue);
      }

	  pub fn FocusRectVisible(&self) -> bool  {
          return method_Call_1!(StringGrid_GetFocusRectVisible, self.0);
      }

	  pub fn SetFocusRectVisible(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetFocusRectVisible, self.0, aValue);
      }

	  pub fn GridLineColor(&self) -> TColor  {
          return method_Call_1!(StringGrid_GetGridLineColor, self.0);
      }

	  pub fn SetGridLineColor(&self, aValue: TColor)  {
          method_Call_1!(StringGrid_SetGridLineColor, self.0, aValue);
      }

	  pub fn GridLineStyle(&self) -> TPenStyle  {
          return method_Call_1!(StringGrid_GetGridLineStyle, self.0);
      }

	  pub fn SetGridLineStyle(&self, aValue: TPenStyle)  {
          method_Call_1!(StringGrid_SetGridLineStyle, self.0, aValue);
      }

	  pub fn Editor(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, StringGrid_GetEditor, self.0);
      }

	  pub fn SetEditor(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(StringGrid_SetEditor, self.0, aValue.Instance());
      }

	  pub fn EditorBorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(StringGrid_GetEditorBorderStyle, self.0);
      }

	  pub fn SetEditorBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(StringGrid_SetEditorBorderStyle, self.0, aValue);
      }

	  pub fn EditorMode(&self) -> bool  {
          return method_Call_1!(StringGrid_GetEditorMode, self.0);
      }

	  pub fn SetEditorMode(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetEditorMode, self.0, aValue);
      }

	  pub fn SortOrder(&self) -> TSortOrder  {
          return method_Call_1!(StringGrid_GetSortOrder, self.0);
      }

	  pub fn SetSortOrder(&self, aValue: TSortOrder)  {
          method_Call_1!(StringGrid_SetSortOrder, self.0, aValue);
      }

	  pub fn SortColumn(&self) -> i32  {
          return method_Call_1!(StringGrid_GetSortColumn, self.0);
      }

	  pub fn SetOnAfterSelection(&self, aEventId: TOnSelectEvent)  {
          method_Call_1!(StringGrid_SetOnAfterSelection, self.0, aEventId);
      }

	  pub fn SetOnBeforeSelection(&self, aEventId: TOnSelectEvent)  {
          method_Call_1!(StringGrid_SetOnBeforeSelection, self.0, aEventId);
      }

	  pub fn SetOnButtonClick(&self, aEventId: TOnSelectEvent)  {
          method_Call_1!(StringGrid_SetOnButtonClick, self.0, aEventId);
      }

	  pub fn SetOnCheckboxToggled(&self, aEventId: TToggledCheckboxEvent)  {
          method_Call_1!(StringGrid_SetOnCheckboxToggled, self.0, aEventId);
      }

	  pub fn SetOnColRowDeleted(&self, aEventId: TGridOperationEvent)  {
          method_Call_1!(StringGrid_SetOnColRowDeleted, self.0, aEventId);
      }

	  pub fn SetOnColRowExchanged(&self, aEventId: TGridOperationEvent)  {
          method_Call_1!(StringGrid_SetOnColRowExchanged, self.0, aEventId);
      }

	  pub fn SetOnColRowInserted(&self, aEventId: TGridOperationEvent)  {
          method_Call_1!(StringGrid_SetOnColRowInserted, self.0, aEventId);
      }

	  pub fn SetOnColRowMoved(&self, aEventId: TGridOperationEvent)  {
          method_Call_1!(StringGrid_SetOnColRowMoved, self.0, aEventId);
      }

	  pub fn SetOnCompareCells(&self, aEventId: TOnCompareCells)  {
          method_Call_1!(StringGrid_SetOnCompareCells, self.0, aEventId);
      }

	  pub fn SetOnEditingDone(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StringGrid_SetOnEditingDone, self.0, aEventId);
      }

	  pub fn SetOnGetCellHint(&self, aEventId: TGetCellHintEvent)  {
          method_Call_1!(StringGrid_SetOnGetCellHint, self.0, aEventId);
      }

	  pub fn SetOnGetCheckboxState(&self, aEventId: TGetCheckboxStateEvent)  {
          method_Call_1!(StringGrid_SetOnGetCheckboxState, self.0, aEventId);
      }

	  pub fn SetOnSetCheckboxState(&self, aEventId: TSetCheckboxStateEvent)  {
          method_Call_1!(StringGrid_SetOnSetCheckboxState, self.0, aEventId);
      }

	  pub fn SetOnHeaderClick(&self, aEventId: THdrEvent)  {
          method_Call_1!(StringGrid_SetOnHeaderClick, self.0, aEventId);
      }

	  pub fn SetOnHeaderSized(&self, aEventId: THdrEvent)  {
          method_Call_1!(StringGrid_SetOnHeaderSized, self.0, aEventId);
      }

	  pub fn SetOnHeaderSizing(&self, aEventId: THeaderSizingEvent)  {
          method_Call_1!(StringGrid_SetOnHeaderSizing, self.0, aEventId);
      }

	  pub fn SetOnPickListSelect(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StringGrid_SetOnPickListSelect, self.0, aEventId);
      }

	  pub fn SetOnSelection(&self, aEventId: TOnSelectEvent)  {
          method_Call_1!(StringGrid_SetOnSelection, self.0, aEventId);
      }

	  pub fn SetOnSelectEditor(&self, aEventId: TSelectEditorEvent)  {
          method_Call_1!(StringGrid_SetOnSelectEditor, self.0, aEventId);
      }

	  pub fn SetOnUserCheckboxBitmap(&self, aEventId: TUserCheckBoxBitmapEvent)  {
          method_Call_1!(StringGrid_SetOnUserCheckboxBitmap, self.0, aEventId);
      }

	  pub fn SetOnValidateEntry(&self, aEventId: TValidateEntryEvent)  {
          method_Call_1!(StringGrid_SetOnValidateEntry, self.0, aEventId);
      }

	  pub fn AlternateColor(&self) -> TColor  {
          return method_Call_1!(StringGrid_GetAlternateColor, self.0);
      }

	  pub fn SetAlternateColor(&self, aValue: TColor)  {
          method_Call_1!(StringGrid_SetAlternateColor, self.0, aValue);
      }

	  pub fn AutoAdvance(&self) -> TAutoAdvance  {
          return method_Call_1!(StringGrid_GetAutoAdvance, self.0);
      }

	  pub fn SetAutoAdvance(&self, aValue: TAutoAdvance)  {
          method_Call_1!(StringGrid_SetAutoAdvance, self.0, aValue);
      }

	  pub fn AutoEdit(&self) -> bool  {
          return method_Call_1!(StringGrid_GetAutoEdit, self.0);
      }

	  pub fn SetAutoEdit(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetAutoEdit, self.0, aValue);
      }

	  pub fn AutoFillColumns(&self) -> bool  {
          return method_Call_1!(StringGrid_GetAutoFillColumns, self.0);
      }

	  pub fn SetAutoFillColumns(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetAutoFillColumns, self.0, aValue);
      }

	  pub fn CellHintPriority(&self) -> TCellHintPriority  {
          return method_Call_1!(StringGrid_GetCellHintPriority, self.0);
      }

	  pub fn SetCellHintPriority(&self, aValue: TCellHintPriority)  {
          method_Call_1!(StringGrid_SetCellHintPriority, self.0, aValue);
      }

	  pub fn ColumnClickSorts(&self) -> bool  {
          return method_Call_1!(StringGrid_GetColumnClickSorts, self.0);
      }

	  pub fn SetColumnClickSorts(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetColumnClickSorts, self.0, aValue);
      }

	  pub fn Columns(&self) -> TGridColumns  {
          return method_Call_2!(TGridColumns, StringGrid_GetColumns, self.0);
      }

	  pub fn SetColumns(&self, aValue: &TGridColumns)  {
          method_Call_1!(StringGrid_SetColumns, self.0, aValue.Instance());
      }

	  pub fn ExtendedSelect(&self) -> bool  {
          return method_Call_1!(StringGrid_GetExtendedSelect, self.0);
      }

	  pub fn SetExtendedSelect(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetExtendedSelect, self.0, aValue);
      }

	  pub fn Flat(&self) -> bool  {
          return method_Call_1!(StringGrid_GetFlat, self.0);
      }

	  pub fn SetFlat(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetFlat, self.0, aValue);
      }

	  pub fn HeaderHotZones(&self) -> TGridZoneSet  {
          return method_Call_1!(StringGrid_GetHeaderHotZones, self.0);
      }

	  pub fn SetHeaderHotZones(&self, aValue: TGridZoneSet)  {
          method_Call_1!(StringGrid_SetHeaderHotZones, self.0, aValue);
      }

	  pub fn HeaderPushZones(&self) -> TGridZoneSet  {
          return method_Call_1!(StringGrid_GetHeaderPushZones, self.0);
      }

	  pub fn SetHeaderPushZones(&self, aValue: TGridZoneSet)  {
          method_Call_1!(StringGrid_SetHeaderPushZones, self.0, aValue);
      }

	  pub fn ImageIndexSortAsc(&self) -> i32  {
          return method_Call_1!(StringGrid_GetImageIndexSortAsc, self.0);
      }

	  pub fn SetImageIndexSortAsc(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetImageIndexSortAsc, self.0, aValue);
      }

	  pub fn ImageIndexSortDesc(&self) -> i32  {
          return method_Call_1!(StringGrid_GetImageIndexSortDesc, self.0);
      }

	  pub fn SetImageIndexSortDesc(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetImageIndexSortDesc, self.0, aValue);
      }

	  pub fn MouseWheelOption(&self) -> TMouseWheelOption  {
          return method_Call_1!(StringGrid_GetMouseWheelOption, self.0);
      }

	  pub fn SetMouseWheelOption(&self, aValue: TMouseWheelOption)  {
          method_Call_1!(StringGrid_SetMouseWheelOption, self.0, aValue);
      }

	  pub fn Options2(&self) -> TGridOptions2  {
          return method_Call_1!(StringGrid_GetOptions2, self.0);
      }

	  pub fn SetOptions2(&self, aValue: TGridOptions2)  {
          method_Call_1!(StringGrid_SetOptions2, self.0, aValue);
      }

	  pub fn RangeSelectMode(&self) -> TRangeSelectMode  {
          return method_Call_1!(StringGrid_GetRangeSelectMode, self.0);
      }

	  pub fn SetRangeSelectMode(&self, aValue: TRangeSelectMode)  {
          method_Call_1!(StringGrid_SetRangeSelectMode, self.0, aValue);
      }

	  pub fn TabAdvance(&self) -> TAutoAdvance  {
          return method_Call_1!(StringGrid_GetTabAdvance, self.0);
      }

	  pub fn SetTabAdvance(&self, aValue: TAutoAdvance)  {
          method_Call_1!(StringGrid_SetTabAdvance, self.0, aValue);
      }

	  pub fn TitleFont(&self) -> TFont  {
          return method_Call_2!(TFont, StringGrid_GetTitleFont, self.0);
      }

	  pub fn SetTitleFont(&self, aValue: &TFont)  {
          method_Call_1!(StringGrid_SetTitleFont, self.0, aValue.Instance());
      }

	  pub fn TitleImageList(&self) -> TImageList  {
          return method_Call_2!(TImageList, StringGrid_GetTitleImageList, self.0);
      }

	  pub fn SetTitleImageList(&self, aValue: &TImageList)  {
          method_Call_1!(StringGrid_SetTitleImageList, self.0, aValue.Instance());
      }

	  pub fn TitleStyle(&self) -> TTitleStyle  {
          return method_Call_1!(StringGrid_GetTitleStyle, self.0);
      }

	  pub fn SetTitleStyle(&self, aValue: TTitleStyle)  {
          method_Call_1!(StringGrid_SetTitleStyle, self.0, aValue);
      }

	  pub fn UseXORFeatures(&self) -> bool  {
          return method_Call_1!(StringGrid_GetUseXORFeatures, self.0);
      }

	  pub fn SetUseXORFeatures(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetUseXORFeatures, self.0, aValue);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(StringGrid_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(StringGrid_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(StringGrid_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(StringGrid_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(StringGrid_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(StringGrid_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(StringGrid_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(StringGrid_SetBorderStyle, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(StringGrid_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(StringGrid_SetColor, self.0, aValue);
      }

	  pub fn ColCount(&self) -> i32  {
          return method_Call_1!(StringGrid_GetColCount, self.0);
      }

	  pub fn SetColCount(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetColCount, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, StringGrid_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(StringGrid_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DefaultColWidth(&self) -> i32  {
          return method_Call_1!(StringGrid_GetDefaultColWidth, self.0);
      }

	  pub fn SetDefaultColWidth(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetDefaultColWidth, self.0, aValue);
      }

	  pub fn DefaultRowHeight(&self) -> i32  {
          return method_Call_1!(StringGrid_GetDefaultRowHeight, self.0);
      }

	  pub fn SetDefaultRowHeight(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetDefaultRowHeight, self.0, aValue);
      }

	  pub fn DefaultDrawing(&self) -> bool  {
          return method_Call_1!(StringGrid_GetDefaultDrawing, self.0);
      }

	  pub fn SetDefaultDrawing(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetDefaultDrawing, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(StringGrid_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(StringGrid_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(StringGrid_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(StringGrid_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(StringGrid_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(StringGrid_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(StringGrid_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(StringGrid_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetEnabled, self.0, aValue);
      }

	  pub fn FixedColor(&self) -> TColor  {
          return method_Call_1!(StringGrid_GetFixedColor, self.0);
      }

	  pub fn SetFixedColor(&self, aValue: TColor)  {
          method_Call_1!(StringGrid_SetFixedColor, self.0, aValue);
      }

	  pub fn FixedCols(&self) -> i32  {
          return method_Call_1!(StringGrid_GetFixedCols, self.0);
      }

	  pub fn SetFixedCols(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetFixedCols, self.0, aValue);
      }

	  pub fn RowCount(&self) -> i32  {
          return method_Call_1!(StringGrid_GetRowCount, self.0);
      }

	  pub fn SetRowCount(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetRowCount, self.0, aValue);
      }

	  pub fn FixedRows(&self) -> i32  {
          return method_Call_1!(StringGrid_GetFixedRows, self.0);
      }

	  pub fn SetFixedRows(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetFixedRows, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, StringGrid_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(StringGrid_SetFont, self.0, aValue.Instance());
      }

	  pub fn GridLineWidth(&self) -> i32  {
          return method_Call_1!(StringGrid_GetGridLineWidth, self.0);
      }

	  pub fn SetGridLineWidth(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetGridLineWidth, self.0, aValue);
      }

	  pub fn Options(&self) -> TGridOptions  {
          return method_Call_1!(StringGrid_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TGridOptions)  {
          method_Call_1!(StringGrid_SetOptions, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(StringGrid_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(StringGrid_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(StringGrid_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(StringGrid_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, StringGrid_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(StringGrid_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ScrollBars(&self) -> TScrollStyle  {
          return method_Call_1!(StringGrid_GetScrollBars, self.0);
      }

	  pub fn SetScrollBars(&self, aValue: TScrollStyle)  {
          method_Call_1!(StringGrid_SetScrollBars, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(StringGrid_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(StringGrid_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(StringGrid_SetTabOrder, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(StringGrid_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetVisible, self.0, aValue);
      }

	  pub fn VisibleColCount(&self) -> i32  {
          return method_Call_1!(StringGrid_GetVisibleColCount, self.0);
      }

	  pub fn VisibleRowCount(&self) -> i32  {
          return method_Call_1!(StringGrid_GetVisibleRowCount, self.0);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StringGrid_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(StringGrid_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StringGrid_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(StringGrid_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(StringGrid_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnDrawCell(&self, aEventId: TDrawCellEvent)  {
          method_Call_1!(StringGrid_SetOnDrawCell, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(StringGrid_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(StringGrid_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StringGrid_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StringGrid_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnGetEditMask(&self, aEventId: TGetEditEvent)  {
          method_Call_1!(StringGrid_SetOnGetEditMask, self.0, aEventId);
      }

	  pub fn SetOnGetEditText(&self, aEventId: TGetEditEvent)  {
          method_Call_1!(StringGrid_SetOnGetEditText, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(StringGrid_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(StringGrid_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(StringGrid_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(StringGrid_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StringGrid_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StringGrid_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(StringGrid_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(StringGrid_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelDown(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(StringGrid_SetOnMouseWheelDown, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelUp(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(StringGrid_SetOnMouseWheelUp, self.0, aEventId);
      }

	  pub fn SetOnSelectCell(&self, aEventId: TSelectCellEvent)  {
          method_Call_1!(StringGrid_SetOnSelectCell, self.0, aEventId);
      }

	  pub fn SetOnSetEditText(&self, aEventId: TSetEditEvent)  {
          method_Call_1!(StringGrid_SetOnSetEditText, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(StringGrid_SetOnStartDock, self.0, aEventId);
      }

	  pub fn SetOnTopLeftChanged(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(StringGrid_SetOnTopLeftChanged, self.0, aEventId);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, StringGrid_GetCanvas, self.0);
      }

	  pub fn Col(&self) -> i32  {
          return method_Call_1!(StringGrid_GetCol, self.0);
      }

	  pub fn SetCol(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetCol, self.0, aValue);
      }

	  pub fn GridHeight(&self) -> i32  {
          return method_Call_1!(StringGrid_GetGridHeight, self.0);
      }

	  pub fn GridWidth(&self) -> i32  {
          return method_Call_1!(StringGrid_GetGridWidth, self.0);
      }

	  pub fn LeftCol(&self) -> i32  {
          return method_Call_1!(StringGrid_GetLeftCol, self.0);
      }

	  pub fn SetLeftCol(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetLeftCol, self.0, aValue);
      }

	  pub fn Selection(&self) -> TGridRect  {
          let mut result = TGridRect::Empty();
          method_Call_1!(StringGrid_GetSelection, self.0, &mut result);
          return result;
      }

	  pub fn SetSelection(&self, aValue: *mut TGridRect)  {
          method_Call_1!(StringGrid_SetSelection, self.0, aValue);
      }

	  pub fn Row(&self) -> i32  {
          return method_Call_1!(StringGrid_GetRow, self.0);
      }

	  pub fn SetRow(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetRow, self.0, aValue);
      }

	  pub fn TopRow(&self) -> i32  {
          return method_Call_1!(StringGrid_GetTopRow, self.0);
      }

	  pub fn SetTopRow(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetTopRow, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(StringGrid_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetTabStop, self.0, aValue);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(StringGrid_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(StringGrid_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(StringGrid_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(StringGrid_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, StringGrid_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(StringGrid_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(StringGrid_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(StringGrid_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(StringGrid_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(StringGrid_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(StringGrid_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(StringGrid_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, StringGrid_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(StringGrid_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(StringGrid_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(StringGrid_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(StringGrid_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(StringGrid_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(StringGrid_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(StringGrid_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(StringGrid_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(StringGrid_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(StringGrid_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(StringGrid_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(StringGrid_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, StringGrid_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(StringGrid_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(StringGrid_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(StringGrid_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(StringGrid_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(StringGrid_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(StringGrid_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(StringGrid_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StringGrid_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(StringGrid_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(StringGrid_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(StringGrid_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(StringGrid_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, StringGrid_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StringGrid_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(StringGrid_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(StringGrid_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(StringGrid_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, StringGrid_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(StringGrid_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, StringGrid_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(StringGrid_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, StringGrid_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(StringGrid_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, StringGrid_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(StringGrid_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, StringGrid_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(StringGrid_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, StringGrid_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(StringGrid_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn IsCellSelected(&self, aCol: i32, aRow: i32) -> bool  {
          return method_Call_1!(StringGrid_GetIsCellSelected, self.0, aCol, aRow);
      }

	  pub fn Cells<'a>(&self, aCol: i32, aRow: i32) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(StringGrid_GetCells, self.0, aCol, aRow));
      }

	  pub fn SetCells(&self, aCol: i32, aRow: i32, aValue: &str)  {
          method_Call_1!(StringGrid_SetCells, self.0, aCol, aRow, to_CString!(aValue));
      }

	  pub fn Cols(&self, index: i32) -> TStrings  {
          return method_Call_2!(TStrings, StringGrid_GetCols, self.0, index);
      }

	  pub fn SetCols(&self, index: i32, aValue: &dyn IStrings)  {
          method_Call_1!(StringGrid_SetCols, self.0, index, aValue.Instance());
      }

	  pub fn Objects(&self, aCol: i32, aRow: i32) -> TObject  {
          return method_Call_2!(TObject, StringGrid_GetObjects, self.0, aCol, aRow);
      }

	  pub fn SetObjects(&self, aCol: i32, aRow: i32, aValue: &dyn IObject)  {
          method_Call_1!(StringGrid_SetObjects, self.0, aCol, aRow, aValue.Instance());
      }

	  pub fn Rows(&self, index: i32) -> TStrings  {
          return method_Call_2!(TStrings, StringGrid_GetRows, self.0, index);
      }

	  pub fn SetRows(&self, index: i32, aValue: &dyn IStrings)  {
          method_Call_1!(StringGrid_SetRows, self.0, index, aValue.Instance());
      }

	  pub fn ColWidths(&self, index: i32) -> i32  {
          return method_Call_1!(StringGrid_GetColWidths, self.0, index);
      }

	  pub fn SetColWidths(&self, index: i32, aValue: i32)  {
          method_Call_1!(StringGrid_SetColWidths, self.0, index, aValue);
      }

	  pub fn RowHeights(&self, index: i32) -> i32  {
          return method_Call_1!(StringGrid_GetRowHeights, self.0, index);
      }

	  pub fn SetRowHeights(&self, index: i32, aValue: i32)  {
          method_Call_1!(StringGrid_SetRowHeights, self.0, index, aValue);
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, StringGrid_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, StringGrid_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, StringGrid_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, StringGrid_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(StringGrid_StaticClassType);
}

impl_IObject!(TStringGrid);
impl_IComponent!(TStringGrid);
impl_IControl!(TStringGrid);
impl_IWinControl!(TStringGrid);

impl TDrawGrid {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TDrawGrid, DrawGrid_Create, aOwner.Instance());
      }

      impl_As_method!(TDrawGrid);

	  impl_Free_method!(DrawGrid_Free);

	  pub fn CellRect(&self, aCol: i32, aRow: i32) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(DrawGrid_CellRect, self.0, aCol, aRow, &mut result);
          return result;
      }

	  pub fn MouseToCell(&self, x: i32, y: i32, aCol: *mut i32, aRow: *mut i32)  {
          method_Call_1!(DrawGrid_MouseToCell, self.0, x, y, aCol, aRow);
      }

	  pub fn MouseCoord(&self, x: i32, y: i32) -> TGridCoord  {
          let mut result = TGridCoord::Empty();
          method_Call_1!(DrawGrid_MouseCoord, self.0, x, y, &mut result);
          return result;
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(DrawGrid_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(DrawGrid_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, DrawGrid_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(DrawGrid_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(DrawGrid_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, DrawGrid_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(DrawGrid_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(DrawGrid_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(DrawGrid_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(DrawGrid_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(DrawGrid_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(DrawGrid_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(DrawGrid_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(DrawGrid_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(DrawGrid_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(DrawGrid_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(DrawGrid_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(DrawGrid_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(DrawGrid_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(DrawGrid_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(DrawGrid_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(DrawGrid_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(DrawGrid_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(DrawGrid_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(DrawGrid_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(DrawGrid_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(DrawGrid_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(DrawGrid_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(DrawGrid_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(DrawGrid_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(DrawGrid_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(DrawGrid_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(DrawGrid_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(DrawGrid_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, DrawGrid_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(DrawGrid_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(DrawGrid_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(DrawGrid_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(DrawGrid_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(DrawGrid_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(DrawGrid_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(DrawGrid_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(DrawGrid_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(DrawGrid_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(DrawGrid_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(DrawGrid_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(DrawGrid_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(DrawGrid_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(DrawGrid_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(DrawGrid_AnchorClient, self.0, aSpace);
      }

	  pub fn SetOnColRowMoved(&self, aEventId: TGridOperationEvent)  {
          method_Call_1!(DrawGrid_SetOnColRowMoved, self.0, aEventId);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(DrawGrid_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(DrawGrid_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(DrawGrid_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(DrawGrid_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(DrawGrid_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(DrawGrid_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(DrawGrid_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(DrawGrid_SetBorderStyle, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(DrawGrid_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(DrawGrid_SetColor, self.0, aValue);
      }

	  pub fn ColCount(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetColCount, self.0);
      }

	  pub fn SetColCount(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetColCount, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, DrawGrid_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(DrawGrid_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DefaultColWidth(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetDefaultColWidth, self.0);
      }

	  pub fn SetDefaultColWidth(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetDefaultColWidth, self.0, aValue);
      }

	  pub fn DefaultRowHeight(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetDefaultRowHeight, self.0);
      }

	  pub fn SetDefaultRowHeight(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetDefaultRowHeight, self.0, aValue);
      }

	  pub fn DefaultDrawing(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetDefaultDrawing, self.0);
      }

	  pub fn SetDefaultDrawing(&self, aValue: bool)  {
          method_Call_1!(DrawGrid_SetDefaultDrawing, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(DrawGrid_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(DrawGrid_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(DrawGrid_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(DrawGrid_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(DrawGrid_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(DrawGrid_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(DrawGrid_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(DrawGrid_SetEnabled, self.0, aValue);
      }

	  pub fn FixedColor(&self) -> TColor  {
          return method_Call_1!(DrawGrid_GetFixedColor, self.0);
      }

	  pub fn SetFixedColor(&self, aValue: TColor)  {
          method_Call_1!(DrawGrid_SetFixedColor, self.0, aValue);
      }

	  pub fn FixedCols(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetFixedCols, self.0);
      }

	  pub fn SetFixedCols(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetFixedCols, self.0, aValue);
      }

	  pub fn RowCount(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetRowCount, self.0);
      }

	  pub fn SetRowCount(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetRowCount, self.0, aValue);
      }

	  pub fn FixedRows(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetFixedRows, self.0);
      }

	  pub fn SetFixedRows(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetFixedRows, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, DrawGrid_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(DrawGrid_SetFont, self.0, aValue.Instance());
      }

	  pub fn GridLineWidth(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetGridLineWidth, self.0);
      }

	  pub fn SetGridLineWidth(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetGridLineWidth, self.0, aValue);
      }

	  pub fn Options(&self) -> TGridOptions  {
          return method_Call_1!(DrawGrid_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TGridOptions)  {
          method_Call_1!(DrawGrid_SetOptions, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(DrawGrid_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(DrawGrid_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(DrawGrid_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(DrawGrid_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, DrawGrid_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(DrawGrid_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ScrollBars(&self) -> TScrollStyle  {
          return method_Call_1!(DrawGrid_GetScrollBars, self.0);
      }

	  pub fn SetScrollBars(&self, aValue: TScrollStyle)  {
          method_Call_1!(DrawGrid_SetScrollBars, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(DrawGrid_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(DrawGrid_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(DrawGrid_SetTabOrder, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(DrawGrid_SetVisible, self.0, aValue);
      }

	  pub fn VisibleColCount(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetVisibleColCount, self.0);
      }

	  pub fn VisibleRowCount(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetVisibleRowCount, self.0);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(DrawGrid_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(DrawGrid_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(DrawGrid_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(DrawGrid_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(DrawGrid_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnDrawCell(&self, aEventId: TDrawCellEvent)  {
          method_Call_1!(DrawGrid_SetOnDrawCell, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(DrawGrid_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(DrawGrid_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(DrawGrid_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(DrawGrid_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnGetEditMask(&self, aEventId: TGetEditEvent)  {
          method_Call_1!(DrawGrid_SetOnGetEditMask, self.0, aEventId);
      }

	  pub fn SetOnGetEditText(&self, aEventId: TGetEditEvent)  {
          method_Call_1!(DrawGrid_SetOnGetEditText, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(DrawGrid_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(DrawGrid_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(DrawGrid_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(DrawGrid_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(DrawGrid_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(DrawGrid_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(DrawGrid_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(DrawGrid_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelDown(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(DrawGrid_SetOnMouseWheelDown, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelUp(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(DrawGrid_SetOnMouseWheelUp, self.0, aEventId);
      }

	  pub fn SetOnSelectCell(&self, aEventId: TSelectCellEvent)  {
          method_Call_1!(DrawGrid_SetOnSelectCell, self.0, aEventId);
      }

	  pub fn SetOnSetEditText(&self, aEventId: TSetEditEvent)  {
          method_Call_1!(DrawGrid_SetOnSetEditText, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(DrawGrid_SetOnStartDock, self.0, aEventId);
      }

	  pub fn SetOnTopLeftChanged(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(DrawGrid_SetOnTopLeftChanged, self.0, aEventId);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, DrawGrid_GetCanvas, self.0);
      }

	  pub fn Col(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetCol, self.0);
      }

	  pub fn SetCol(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetCol, self.0, aValue);
      }

	  pub fn EditorMode(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetEditorMode, self.0);
      }

	  pub fn SetEditorMode(&self, aValue: bool)  {
          method_Call_1!(DrawGrid_SetEditorMode, self.0, aValue);
      }

	  pub fn GridHeight(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetGridHeight, self.0);
      }

	  pub fn GridWidth(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetGridWidth, self.0);
      }

	  pub fn LeftCol(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetLeftCol, self.0);
      }

	  pub fn SetLeftCol(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetLeftCol, self.0, aValue);
      }

	  pub fn Selection(&self) -> TGridRect  {
          let mut result = TGridRect::Empty();
          method_Call_1!(DrawGrid_GetSelection, self.0, &mut result);
          return result;
      }

	  pub fn SetSelection(&self, aValue: *mut TGridRect)  {
          method_Call_1!(DrawGrid_SetSelection, self.0, aValue);
      }

	  pub fn Row(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetRow, self.0);
      }

	  pub fn SetRow(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetRow, self.0, aValue);
      }

	  pub fn TopRow(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetTopRow, self.0);
      }

	  pub fn SetTopRow(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetTopRow, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(DrawGrid_SetTabStop, self.0, aValue);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(DrawGrid_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, DrawGrid_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(DrawGrid_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(DrawGrid_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(DrawGrid_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(DrawGrid_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, DrawGrid_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(DrawGrid_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(DrawGrid_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(DrawGrid_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(DrawGrid_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(DrawGrid_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(DrawGrid_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(DrawGrid_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(DrawGrid_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(DrawGrid_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(DrawGrid_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, DrawGrid_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(DrawGrid_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(DrawGrid_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(DrawGrid_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(DrawGrid_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(DrawGrid_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(DrawGrid_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(DrawGrid_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, DrawGrid_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(DrawGrid_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(DrawGrid_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(DrawGrid_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(DrawGrid_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, DrawGrid_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(DrawGrid_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, DrawGrid_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(DrawGrid_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, DrawGrid_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(DrawGrid_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, DrawGrid_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(DrawGrid_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, DrawGrid_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(DrawGrid_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, DrawGrid_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(DrawGrid_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn ColWidths(&self, index: i32) -> i32  {
          return method_Call_1!(DrawGrid_GetColWidths, self.0, index);
      }

	  pub fn SetColWidths(&self, index: i32, aValue: i32)  {
          method_Call_1!(DrawGrid_SetColWidths, self.0, index, aValue);
      }

	  pub fn RowHeights(&self, index: i32) -> i32  {
          return method_Call_1!(DrawGrid_GetRowHeights, self.0, index);
      }

	  pub fn SetRowHeights(&self, index: i32, aValue: i32)  {
          method_Call_1!(DrawGrid_SetRowHeights, self.0, index, aValue);
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, DrawGrid_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, DrawGrid_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, DrawGrid_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, DrawGrid_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(DrawGrid_StaticClassType);
}

impl_IObject!(TDrawGrid);
impl_IComponent!(TDrawGrid);
impl_IControl!(TDrawGrid);
impl_IWinControl!(TDrawGrid);

impl TValueListEditor {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TValueListEditor, ValueListEditor_Create, aOwner.Instance());
      }

      impl_As_method!(TValueListEditor);

	  impl_Free_method!(ValueListEditor_Free);

	  pub fn DeleteRow(&self, aRow: i32)  {
          method_Call_1!(ValueListEditor_DeleteRow, self.0, aRow);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(ValueListEditor_Refresh, self.0);
      }

	  pub fn CellRect(&self, aCol: i32, aRow: i32) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ValueListEditor_CellRect, self.0, aCol, aRow, &mut result);
          return result;
      }

	  pub fn MouseToCell(&self, x: i32, y: i32, aCol: *mut i32, aRow: *mut i32)  {
          method_Call_1!(ValueListEditor_MouseToCell, self.0, x, y, aCol, aRow);
      }

	  pub fn MouseCoord(&self, x: i32, y: i32) -> TGridCoord  {
          let mut result = TGridCoord::Empty();
          method_Call_1!(ValueListEditor_MouseCoord, self.0, x, y, &mut result);
          return result;
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(ValueListEditor_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(ValueListEditor_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, ValueListEditor_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(ValueListEditor_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(ValueListEditor_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, ValueListEditor_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(ValueListEditor_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(ValueListEditor_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(ValueListEditor_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ValueListEditor_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(ValueListEditor_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ValueListEditor_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(ValueListEditor_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(ValueListEditor_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(ValueListEditor_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(ValueListEditor_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(ValueListEditor_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(ValueListEditor_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(ValueListEditor_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(ValueListEditor_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ValueListEditor_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ValueListEditor_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(ValueListEditor_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ValueListEditor_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(ValueListEditor_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(ValueListEditor_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ValueListEditor_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ValueListEditor_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(ValueListEditor_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(ValueListEditor_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(ValueListEditor_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(ValueListEditor_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(ValueListEditor_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ValueListEditor_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ValueListEditor_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ValueListEditor_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ValueListEditor_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ValueListEditor_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ValueListEditor_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ValueListEditor_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ValueListEditor_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ValueListEditor_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ValueListEditor_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ValueListEditor_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ValueListEditor_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ValueListEditor_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ValueListEditor_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(ValueListEditor_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(ValueListEditor_AnchorClient, self.0, aSpace);
      }

	  pub fn ColCount(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetColCount, self.0);
      }

	  pub fn SetColCount(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetColCount, self.0, aValue);
      }

	  pub fn RowCount(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetRowCount, self.0);
      }

	  pub fn VisibleColCount(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetVisibleColCount, self.0);
      }

	  pub fn VisibleRowCount(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetVisibleRowCount, self.0);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(ValueListEditor_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(ValueListEditor_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(ValueListEditor_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(ValueListEditor_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(ValueListEditor_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(ValueListEditor_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(ValueListEditor_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(ValueListEditor_SetBorderStyle, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(ValueListEditor_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(ValueListEditor_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, ValueListEditor_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(ValueListEditor_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DefaultColWidth(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetDefaultColWidth, self.0);
      }

	  pub fn SetDefaultColWidth(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetDefaultColWidth, self.0, aValue);
      }

	  pub fn DefaultDrawing(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetDefaultDrawing, self.0);
      }

	  pub fn SetDefaultDrawing(&self, aValue: bool)  {
          method_Call_1!(ValueListEditor_SetDefaultDrawing, self.0, aValue);
      }

	  pub fn DefaultRowHeight(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetDefaultRowHeight, self.0);
      }

	  pub fn SetDefaultRowHeight(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetDefaultRowHeight, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ValueListEditor_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(ValueListEditor_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(ValueListEditor_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(ValueListEditor_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(ValueListEditor_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(ValueListEditor_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(ValueListEditor_SetDragMode, self.0, aValue);
      }

	  pub fn DropDownRows(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetDropDownRows, self.0);
      }

	  pub fn SetDropDownRows(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetDropDownRows, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(ValueListEditor_SetEnabled, self.0, aValue);
      }

	  pub fn FixedColor(&self) -> TColor  {
          return method_Call_1!(ValueListEditor_GetFixedColor, self.0);
      }

	  pub fn SetFixedColor(&self, aValue: TColor)  {
          method_Call_1!(ValueListEditor_SetFixedColor, self.0, aValue);
      }

	  pub fn FixedCols(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetFixedCols, self.0);
      }

	  pub fn SetFixedCols(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetFixedCols, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, ValueListEditor_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(ValueListEditor_SetFont, self.0, aValue.Instance());
      }

	  pub fn GridLineWidth(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetGridLineWidth, self.0);
      }

	  pub fn SetGridLineWidth(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetGridLineWidth, self.0, aValue);
      }

	  pub fn Options(&self) -> TGridOptions  {
          return method_Call_1!(ValueListEditor_GetOptions, self.0);
      }

	  pub fn SetOptions(&self, aValue: TGridOptions)  {
          method_Call_1!(ValueListEditor_SetOptions, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(ValueListEditor_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ValueListEditor_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(ValueListEditor_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(ValueListEditor_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, ValueListEditor_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(ValueListEditor_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ScrollBars(&self) -> TScrollStyle  {
          return method_Call_1!(ValueListEditor_GetScrollBars, self.0);
      }

	  pub fn SetScrollBars(&self, aValue: TScrollStyle)  {
          method_Call_1!(ValueListEditor_SetScrollBars, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(ValueListEditor_SetShowHint, self.0, aValue);
      }

	  pub fn Strings(&self) -> TStrings  {
          return method_Call_2!(TStrings, ValueListEditor_GetStrings, self.0);
      }

	  pub fn SetStrings(&self, aValue: &dyn IStrings)  {
          method_Call_1!(ValueListEditor_SetStrings, self.0, aValue.Instance());
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(ValueListEditor_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(ValueListEditor_SetTabOrder, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(ValueListEditor_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ValueListEditor_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(ValueListEditor_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ValueListEditor_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(ValueListEditor_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(ValueListEditor_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnDrawCell(&self, aEventId: TDrawCellEvent)  {
          method_Call_1!(ValueListEditor_SetOnDrawCell, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ValueListEditor_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ValueListEditor_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ValueListEditor_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ValueListEditor_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnGetEditMask(&self, aEventId: TGetEditEvent)  {
          method_Call_1!(ValueListEditor_SetOnGetEditMask, self.0, aEventId);
      }

	  pub fn SetOnGetEditText(&self, aEventId: TGetEditEvent)  {
          method_Call_1!(ValueListEditor_SetOnGetEditText, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ValueListEditor_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(ValueListEditor_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ValueListEditor_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ValueListEditor_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ValueListEditor_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ValueListEditor_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(ValueListEditor_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ValueListEditor_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelDown(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(ValueListEditor_SetOnMouseWheelDown, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelUp(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(ValueListEditor_SetOnMouseWheelUp, self.0, aEventId);
      }

	  pub fn SetOnSelectCell(&self, aEventId: TSelectCellEvent)  {
          method_Call_1!(ValueListEditor_SetOnSelectCell, self.0, aEventId);
      }

	  pub fn SetOnSetEditText(&self, aEventId: TSetEditEvent)  {
          method_Call_1!(ValueListEditor_SetOnSetEditText, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(ValueListEditor_SetOnStartDock, self.0, aEventId);
      }

	  pub fn SetOnTopLeftChanged(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ValueListEditor_SetOnTopLeftChanged, self.0, aEventId);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, ValueListEditor_GetCanvas, self.0);
      }

	  pub fn Col(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetCol, self.0);
      }

	  pub fn SetCol(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetCol, self.0, aValue);
      }

	  pub fn EditorMode(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetEditorMode, self.0);
      }

	  pub fn SetEditorMode(&self, aValue: bool)  {
          method_Call_1!(ValueListEditor_SetEditorMode, self.0, aValue);
      }

	  pub fn GridHeight(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetGridHeight, self.0);
      }

	  pub fn GridWidth(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetGridWidth, self.0);
      }

	  pub fn LeftCol(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetLeftCol, self.0);
      }

	  pub fn SetLeftCol(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetLeftCol, self.0, aValue);
      }

	  pub fn Selection(&self) -> TGridRect  {
          let mut result = TGridRect::Empty();
          method_Call_1!(ValueListEditor_GetSelection, self.0, &mut result);
          return result;
      }

	  pub fn SetSelection(&self, aValue: *mut TGridRect)  {
          method_Call_1!(ValueListEditor_SetSelection, self.0, aValue);
      }

	  pub fn Row(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetRow, self.0);
      }

	  pub fn SetRow(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetRow, self.0, aValue);
      }

	  pub fn TopRow(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetTopRow, self.0);
      }

	  pub fn SetTopRow(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetTopRow, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(ValueListEditor_SetTabStop, self.0, aValue);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(ValueListEditor_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, ValueListEditor_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(ValueListEditor_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(ValueListEditor_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(ValueListEditor_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(ValueListEditor_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, ValueListEditor_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(ValueListEditor_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ValueListEditor_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(ValueListEditor_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ValueListEditor_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ValueListEditor_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(ValueListEditor_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(ValueListEditor_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(ValueListEditor_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(ValueListEditor_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(ValueListEditor_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, ValueListEditor_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(ValueListEditor_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(ValueListEditor_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(ValueListEditor_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ValueListEditor_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(ValueListEditor_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ValueListEditor_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ValueListEditor_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ValueListEditor_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ValueListEditor_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ValueListEditor_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ValueListEditor_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ValueListEditor_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ValueListEditor_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ValueListEditor_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ValueListEditor_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ValueListEditor_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ValueListEditor_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ValueListEditor_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ValueListEditor_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, ValueListEditor_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(ValueListEditor_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, ValueListEditor_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(ValueListEditor_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Cells<'a>(&self, aCol: i32, aRow: i32) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ValueListEditor_GetCells, self.0, aCol, aRow));
      }

	  pub fn SetCells(&self, aCol: i32, aRow: i32, aValue: &str)  {
          method_Call_1!(ValueListEditor_SetCells, self.0, aCol, aRow, to_CString!(aValue));
      }

	  pub fn Values<'a>(&self, key: &str) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ValueListEditor_GetValues, self.0, to_CString!(key)));
      }

	  pub fn SetValues(&self, key: &str, aValue: &str)  {
          method_Call_1!(ValueListEditor_SetValues, self.0, to_CString!(key), to_CString!(aValue));
      }

	  pub fn ColWidths(&self, index: i32) -> i32  {
          return method_Call_1!(ValueListEditor_GetColWidths, self.0, index);
      }

	  pub fn SetColWidths(&self, index: i32, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetColWidths, self.0, index, aValue);
      }

	  pub fn RowHeights(&self, index: i32) -> i32  {
          return method_Call_1!(ValueListEditor_GetRowHeights, self.0, index);
      }

	  pub fn SetRowHeights(&self, index: i32, aValue: i32)  {
          method_Call_1!(ValueListEditor_SetRowHeights, self.0, index, aValue);
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ValueListEditor_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ValueListEditor_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ValueListEditor_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ValueListEditor_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(ValueListEditor_StaticClassType);
}

impl_IObject!(TValueListEditor);
impl_IComponent!(TValueListEditor);
impl_IControl!(TValueListEditor);
impl_IWinControl!(TValueListEditor);

impl THeaderControl {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(THeaderControl, HeaderControl_Create, aOwner.Instance());
      }

      impl_As_method!(THeaderControl);

	  impl_Free_method!(HeaderControl_Free);

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(HeaderControl_FlipChildren, self.0, allLevels);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(HeaderControl_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(HeaderControl_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, HeaderControl_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(HeaderControl_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(HeaderControl_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, HeaderControl_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(HeaderControl_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(HeaderControl_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(HeaderControl_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(HeaderControl_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(HeaderControl_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(HeaderControl_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(HeaderControl_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(HeaderControl_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(HeaderControl_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(HeaderControl_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(HeaderControl_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(HeaderControl_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(HeaderControl_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(HeaderControl_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(HeaderControl_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(HeaderControl_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(HeaderControl_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(HeaderControl_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(HeaderControl_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(HeaderControl_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(HeaderControl_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(HeaderControl_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(HeaderControl_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(HeaderControl_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(HeaderControl_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(HeaderControl_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(HeaderControl_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, HeaderControl_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(HeaderControl_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(HeaderControl_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(HeaderControl_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(HeaderControl_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(HeaderControl_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(HeaderControl_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(HeaderControl_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(HeaderControl_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(HeaderControl_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(HeaderControl_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(HeaderControl_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(HeaderControl_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(HeaderControl_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(HeaderControl_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(HeaderControl_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(HeaderControl_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(HeaderControl_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(HeaderControl_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(HeaderControl_SetAnchors, self.0, aValue);
      }

	  pub fn BorderWidth(&self) -> i32  {
          return method_Call_1!(HeaderControl_GetBorderWidth, self.0);
      }

	  pub fn SetBorderWidth(&self, aValue: i32)  {
          method_Call_1!(HeaderControl_SetBorderWidth, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(HeaderControl_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(HeaderControl_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(HeaderControl_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(HeaderControl_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(HeaderControl_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(HeaderControl_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(HeaderControl_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(HeaderControl_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(HeaderControl_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(HeaderControl_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, HeaderControl_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(HeaderControl_SetFont, self.0, aValue.Instance());
      }

	  pub fn Images(&self) -> TImageList  {
          return method_Call_2!(TImageList, HeaderControl_GetImages, self.0);
      }

	  pub fn SetImages(&self, aValue: &TImageList)  {
          method_Call_1!(HeaderControl_SetImages, self.0, aValue.Instance());
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, HeaderControl_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(HeaderControl_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn Sections(&self) -> THeaderSections  {
          return method_Call_2!(THeaderSections, HeaderControl_GetSections, self.0);
      }

	  pub fn SetSections(&self, aValue: &THeaderSections)  {
          method_Call_1!(HeaderControl_SetSections, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(HeaderControl_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(HeaderControl_SetShowHint, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(HeaderControl_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(HeaderControl_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(HeaderControl_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(HeaderControl_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(HeaderControl_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(HeaderControl_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, HeaderControl_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(HeaderControl_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(HeaderControl_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(HeaderControl_SetVisible, self.0, aValue);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(HeaderControl_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(HeaderControl_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(HeaderControl_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(HeaderControl_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(HeaderControl_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(HeaderControl_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(HeaderControl_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(HeaderControl_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(HeaderControl_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(HeaderControl_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnResize(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(HeaderControl_SetOnResize, self.0, aEventId);
      }

	  pub fn SetOnSectionClick(&self, aEventId: TSectionNotifyEvent)  {
          method_Call_1!(HeaderControl_SetOnSectionClick, self.0, aEventId);
      }

	  pub fn SetOnSectionResize(&self, aEventId: TSectionNotifyEvent)  {
          method_Call_1!(HeaderControl_SetOnSectionResize, self.0, aEventId);
      }

	  pub fn SetOnSectionTrack(&self, aEventId: TSectionTrackEvent)  {
          method_Call_1!(HeaderControl_SetOnSectionTrack, self.0, aEventId);
      }

	  pub fn SetOnSectionDrag(&self, aEventId: TSectionDragEvent)  {
          method_Call_1!(HeaderControl_SetOnSectionDrag, self.0, aEventId);
      }

	  pub fn SetOnSectionEndDrag(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(HeaderControl_SetOnSectionEndDrag, self.0, aEventId);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, HeaderControl_GetCanvas, self.0);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(HeaderControl_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(HeaderControl_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(HeaderControl_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(HeaderControl_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(HeaderControl_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, HeaderControl_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(HeaderControl_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(HeaderControl_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(HeaderControl_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(HeaderControl_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(HeaderControl_GetShowing, self.0);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(HeaderControl_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(HeaderControl_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(HeaderControl_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(HeaderControl_SetTabStop, self.0, aValue);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(HeaderControl_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(HeaderControl_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, HeaderControl_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(HeaderControl_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(HeaderControl_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(HeaderControl_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(HeaderControl_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(HeaderControl_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(HeaderControl_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(HeaderControl_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(HeaderControl_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(HeaderControl_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(HeaderControl_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(HeaderControl_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(HeaderControl_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(HeaderControl_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(HeaderControl_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, HeaderControl_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(HeaderControl_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(HeaderControl_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(HeaderControl_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(HeaderControl_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(HeaderControl_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(HeaderControl_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(HeaderControl_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(HeaderControl_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(HeaderControl_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(HeaderControl_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(HeaderControl_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(HeaderControl_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(HeaderControl_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(HeaderControl_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(HeaderControl_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(HeaderControl_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, HeaderControl_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(HeaderControl_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(HeaderControl_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(HeaderControl_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(HeaderControl_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, HeaderControl_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(HeaderControl_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, HeaderControl_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(HeaderControl_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, HeaderControl_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(HeaderControl_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, HeaderControl_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(HeaderControl_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, HeaderControl_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(HeaderControl_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, HeaderControl_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(HeaderControl_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, HeaderControl_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, HeaderControl_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, HeaderControl_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, HeaderControl_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(HeaderControl_StaticClassType);
}

impl_IObject!(THeaderControl);
impl_IComponent!(THeaderControl);
impl_IControl!(THeaderControl);
impl_IWinControl!(THeaderControl);

impl THeaderSection {
      pub fn new(aOwner: &TCollection) -> Self {
        method_Create!(THeaderSection, HeaderSection_Create, aOwner.Instance());
      }

      impl_As_method!(THeaderSection);

	  impl_Free_method!(HeaderSection_Free);

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(HeaderSection_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(HeaderSection_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(HeaderSection_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(HeaderSection_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(HeaderSection_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(HeaderSection_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(HeaderSection_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(HeaderSection_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(HeaderSection_ToString, self.0));
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(HeaderSection_GetLeft, self.0);
      }

	  pub fn Right(&self) -> i32  {
          return method_Call_1!(HeaderSection_GetRight, self.0);
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(HeaderSection_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(HeaderSection_SetAlignment, self.0, aValue);
      }

	  pub fn ImageIndex(&self) -> i32  {
          return method_Call_1!(HeaderSection_GetImageIndex, self.0);
      }

	  pub fn SetImageIndex(&self, aValue: i32)  {
          method_Call_1!(HeaderSection_SetImageIndex, self.0, aValue);
      }

	  pub fn MaxWidth(&self) -> i32  {
          return method_Call_1!(HeaderSection_GetMaxWidth, self.0);
      }

	  pub fn SetMaxWidth(&self, aValue: i32)  {
          method_Call_1!(HeaderSection_SetMaxWidth, self.0, aValue);
      }

	  pub fn MinWidth(&self) -> i32  {
          return method_Call_1!(HeaderSection_GetMinWidth, self.0);
      }

	  pub fn SetMinWidth(&self, aValue: i32)  {
          method_Call_1!(HeaderSection_SetMinWidth, self.0, aValue);
      }

	  pub fn Text<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(HeaderSection_GetText, self.0));
      }

	  pub fn SetText(&self, aValue: &str)  {
          method_Call_1!(HeaderSection_SetText, self.0, to_CString!(aValue));
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(HeaderSection_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(HeaderSection_SetWidth, self.0, aValue);
      }

	  pub fn Collection(&self) -> TCollection  {
          return method_Call_2!(TCollection, HeaderSection_GetCollection, self.0);
      }

	  pub fn SetCollection(&self, aValue: &TCollection)  {
          method_Call_1!(HeaderSection_SetCollection, self.0, aValue.Instance());
      }

	  pub fn Index(&self) -> i32  {
          return method_Call_1!(HeaderSection_GetIndex, self.0);
      }

	  pub fn SetIndex(&self, aValue: i32)  {
          method_Call_1!(HeaderSection_SetIndex, self.0, aValue);
      }

	  pub fn DisplayName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(HeaderSection_GetDisplayName, self.0));
      }

	  pub fn SetDisplayName(&self, aValue: &str)  {
          method_Call_1!(HeaderSection_SetDisplayName, self.0, to_CString!(aValue));
      }

      // static class
	  impl_Class_method!(HeaderSection_StaticClassType);
}

impl_IObject!(THeaderSection);
impl_Drop_method!(THeaderSection);

impl THeaderSections {
      pub fn new(aOwner: &THeaderControl) -> Self {
        method_Create!(THeaderSections, HeaderSections_Create, aOwner.Instance());
      }

      impl_As_method!(THeaderSections);

	  impl_Free_method!(HeaderSections_Free);

	  pub fn Add(&self) -> THeaderSection  {
          return method_Call_2!(THeaderSection, HeaderSections_Add, self.0);
      }

	  pub fn AddItem(&self, item: &THeaderSection, index: i32) -> THeaderSection  {
          return method_Call_2!(THeaderSection, HeaderSections_AddItem, self.0, item.Instance(), index);
      }

	  pub fn Insert(&self, index: i32) -> THeaderSection  {
          return method_Call_2!(THeaderSection, HeaderSections_Insert, self.0, index);
      }

	  pub fn Owner(&self) -> TObject  {
          return method_Call_2!(TObject, HeaderSections_Owner, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(HeaderSections_Assign, self.0, source.Instance());
      }

	  pub fn BeginUpdate(&self)  {
          method_Call_1!(HeaderSections_BeginUpdate, self.0);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(HeaderSections_Clear, self.0);
      }

	  pub fn Delete(&self, index: i32)  {
          method_Call_1!(HeaderSections_Delete, self.0, index);
      }

	  pub fn EndUpdate(&self)  {
          method_Call_1!(HeaderSections_EndUpdate, self.0);
      }

	  pub fn FindItemID(&self, iD: i32) -> TCollectionItem  {
          return method_Call_2!(TCollectionItem, HeaderSections_FindItemID, self.0, iD);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(HeaderSections_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(HeaderSections_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(HeaderSections_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(HeaderSections_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(HeaderSections_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(HeaderSections_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(HeaderSections_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(HeaderSections_ToString, self.0));
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(HeaderSections_GetCount, self.0);
      }

	  pub fn Items(&self, index: i32) -> THeaderSection  {
          return method_Call_2!(THeaderSection, HeaderSections_GetItems, self.0, index);
      }

	  pub fn SetItems(&self, index: i32, aValue: &THeaderSection)  {
          method_Call_1!(HeaderSections_SetItems, self.0, index, aValue.Instance());
      }

      // static class
	  impl_Class_method!(HeaderSections_StaticClassType);
}

impl_IObject!(THeaderSections);
impl_Drop_method!(THeaderSections);

impl TLabeledEdit {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TLabeledEdit, LabeledEdit_Create, aOwner.Instance());
      }

      impl_As_method!(TLabeledEdit);

	  impl_Free_method!(LabeledEdit_Free);

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(LabeledEdit_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(LabeledEdit_Clear, self.0);
      }

	  pub fn ClearSelection(&self)  {
          method_Call_1!(LabeledEdit_ClearSelection, self.0);
      }

	  pub fn CopyToClipboard(&self)  {
          method_Call_1!(LabeledEdit_CopyToClipboard, self.0);
      }

	  pub fn CutToClipboard(&self)  {
          method_Call_1!(LabeledEdit_CutToClipboard, self.0);
      }

	  pub fn PasteFromClipboard(&self)  {
          method_Call_1!(LabeledEdit_PasteFromClipboard, self.0);
      }

	  pub fn Undo(&self)  {
          method_Call_1!(LabeledEdit_Undo, self.0);
      }

	  pub fn SelectAll(&self)  {
          method_Call_1!(LabeledEdit_SelectAll, self.0);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(LabeledEdit_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(LabeledEdit_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, LabeledEdit_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(LabeledEdit_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(LabeledEdit_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, LabeledEdit_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(LabeledEdit_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(LabeledEdit_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(LabeledEdit_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(LabeledEdit_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(LabeledEdit_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(LabeledEdit_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(LabeledEdit_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(LabeledEdit_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(LabeledEdit_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(LabeledEdit_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(LabeledEdit_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(LabeledEdit_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(LabeledEdit_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(LabeledEdit_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(LabeledEdit_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(LabeledEdit_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(LabeledEdit_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(LabeledEdit_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(LabeledEdit_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(LabeledEdit_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(LabeledEdit_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(LabeledEdit_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(LabeledEdit_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(LabeledEdit_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(LabeledEdit_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(LabeledEdit_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(LabeledEdit_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, LabeledEdit_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(LabeledEdit_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(LabeledEdit_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(LabeledEdit_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(LabeledEdit_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(LabeledEdit_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(LabeledEdit_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(LabeledEdit_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(LabeledEdit_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(LabeledEdit_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(LabeledEdit_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(LabeledEdit_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(LabeledEdit_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(LabeledEdit_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(LabeledEdit_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(LabeledEdit_AnchorClient, self.0, aSpace);
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(LabeledEdit_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(LabeledEdit_SetAlignment, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(LabeledEdit_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(LabeledEdit_SetAnchors, self.0, aValue);
      }

	  pub fn AutoSelect(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetAutoSelect, self.0);
      }

	  pub fn SetAutoSelect(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetAutoSelect, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetAutoSize, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(LabeledEdit_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(LabeledEdit_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(LabeledEdit_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(LabeledEdit_SetBorderStyle, self.0, aValue);
      }

	  pub fn CharCase(&self) -> TEditCharCase  {
          return method_Call_1!(LabeledEdit_GetCharCase, self.0);
      }

	  pub fn SetCharCase(&self, aValue: TEditCharCase)  {
          method_Call_1!(LabeledEdit_SetCharCase, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(LabeledEdit_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(LabeledEdit_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, LabeledEdit_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(LabeledEdit_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(LabeledEdit_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(LabeledEdit_SetDragCursor, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(LabeledEdit_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(LabeledEdit_SetDragMode, self.0, aValue);
      }

	  pub fn EditLabel(&self) -> TBoundLabel  {
          return method_Call_2!(TBoundLabel, LabeledEdit_GetEditLabel, self.0);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, LabeledEdit_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(LabeledEdit_SetFont, self.0, aValue.Instance());
      }

	  pub fn HideSelection(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetHideSelection, self.0);
      }

	  pub fn SetHideSelection(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetHideSelection, self.0, aValue);
      }

	  pub fn LabelPosition(&self) -> TLabelPosition  {
          return method_Call_1!(LabeledEdit_GetLabelPosition, self.0);
      }

	  pub fn SetLabelPosition(&self, aValue: TLabelPosition)  {
          method_Call_1!(LabeledEdit_SetLabelPosition, self.0, aValue);
      }

	  pub fn LabelSpacing(&self) -> i32  {
          return method_Call_1!(LabeledEdit_GetLabelSpacing, self.0);
      }

	  pub fn SetLabelSpacing(&self, aValue: i32)  {
          method_Call_1!(LabeledEdit_SetLabelSpacing, self.0, aValue);
      }

	  pub fn MaxLength(&self) -> i32  {
          return method_Call_1!(LabeledEdit_GetMaxLength, self.0);
      }

	  pub fn SetMaxLength(&self, aValue: i32)  {
          method_Call_1!(LabeledEdit_SetMaxLength, self.0, aValue);
      }

	  pub fn NumbersOnly(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetNumbersOnly, self.0);
      }

	  pub fn SetNumbersOnly(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetNumbersOnly, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetParentShowHint, self.0, aValue);
      }

	  pub fn PasswordChar(&self) -> Char  {
          return method_Call_1!(LabeledEdit_GetPasswordChar, self.0);
      }

	  pub fn SetPasswordChar(&self, aValue: Char)  {
          method_Call_1!(LabeledEdit_SetPasswordChar, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, LabeledEdit_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(LabeledEdit_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ReadOnly(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetReadOnly, self.0);
      }

	  pub fn SetReadOnly(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetReadOnly, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(LabeledEdit_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(LabeledEdit_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetTabStop, self.0, aValue);
      }

	  pub fn Text<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(LabeledEdit_GetText, self.0));
      }

	  pub fn SetText(&self, aValue: &str)  {
          method_Call_1!(LabeledEdit_SetText, self.0, to_CString!(aValue));
      }

	  pub fn TextHint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(LabeledEdit_GetTextHint, self.0));
      }

	  pub fn SetTextHint(&self, aValue: &str)  {
          method_Call_1!(LabeledEdit_SetTextHint, self.0, to_CString!(aValue));
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetVisible, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(LabeledEdit_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(LabeledEdit_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(LabeledEdit_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(LabeledEdit_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(LabeledEdit_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(LabeledEdit_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(LabeledEdit_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(LabeledEdit_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(LabeledEdit_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(LabeledEdit_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(LabeledEdit_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(LabeledEdit_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(LabeledEdit_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(LabeledEdit_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(LabeledEdit_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(LabeledEdit_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn CanUndo(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetCanUndo, self.0);
      }

	  pub fn Modified(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetModified, self.0);
      }

	  pub fn SetModified(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetModified, self.0, aValue);
      }

	  pub fn SelLength(&self) -> i32  {
          return method_Call_1!(LabeledEdit_GetSelLength, self.0);
      }

	  pub fn SetSelLength(&self, aValue: i32)  {
          method_Call_1!(LabeledEdit_SetSelLength, self.0, aValue);
      }

	  pub fn SelStart(&self) -> i32  {
          return method_Call_1!(LabeledEdit_GetSelStart, self.0);
      }

	  pub fn SetSelStart(&self, aValue: i32)  {
          method_Call_1!(LabeledEdit_SetSelStart, self.0, aValue);
      }

	  pub fn SelText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(LabeledEdit_GetSelText, self.0));
      }

	  pub fn SetSelText(&self, aValue: &str)  {
          method_Call_1!(LabeledEdit_SetSelText, self.0, to_CString!(aValue));
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(LabeledEdit_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(LabeledEdit_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, LabeledEdit_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(LabeledEdit_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(LabeledEdit_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(LabeledEdit_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(LabeledEdit_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(LabeledEdit_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, LabeledEdit_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(LabeledEdit_SetAction, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(LabeledEdit_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(LabeledEdit_SetAlign, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(LabeledEdit_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(LabeledEdit_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(LabeledEdit_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(LabeledEdit_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(LabeledEdit_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(LabeledEdit_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(LabeledEdit_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(LabeledEdit_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(LabeledEdit_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(LabeledEdit_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(LabeledEdit_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(LabeledEdit_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(LabeledEdit_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, LabeledEdit_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(LabeledEdit_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(LabeledEdit_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(LabeledEdit_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(LabeledEdit_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(LabeledEdit_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(LabeledEdit_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(LabeledEdit_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(LabeledEdit_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(LabeledEdit_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(LabeledEdit_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(LabeledEdit_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(LabeledEdit_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(LabeledEdit_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(LabeledEdit_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(LabeledEdit_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(LabeledEdit_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, LabeledEdit_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(LabeledEdit_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(LabeledEdit_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(LabeledEdit_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(LabeledEdit_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, LabeledEdit_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(LabeledEdit_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, LabeledEdit_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(LabeledEdit_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, LabeledEdit_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(LabeledEdit_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, LabeledEdit_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(LabeledEdit_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, LabeledEdit_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(LabeledEdit_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, LabeledEdit_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(LabeledEdit_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, LabeledEdit_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, LabeledEdit_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, LabeledEdit_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, LabeledEdit_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(LabeledEdit_StaticClassType);
}

impl_IObject!(TLabeledEdit);
impl_IComponent!(TLabeledEdit);
impl_IControl!(TLabeledEdit);
impl_IWinControl!(TLabeledEdit);

impl TBoundLabel {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TBoundLabel, BoundLabel_Create, aOwner.Instance());
      }

      impl_As_method!(TBoundLabel);

	  impl_Free_method!(BoundLabel_Free);

	  pub fn BringToFront(&self) {
          method_Call_1!(BoundLabel_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(BoundLabel_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(BoundLabel_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(BoundLabel_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(BoundLabel_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(BoundLabel_Hide, self.0);
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(BoundLabel_Invalidate, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(BoundLabel_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(BoundLabel_Refresh, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(BoundLabel_Repaint, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(BoundLabel_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(BoundLabel_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(BoundLabel_SendToBack, self.0);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(BoundLabel_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn Show(&self) {
          method_Call_1!(BoundLabel_Show, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(BoundLabel_Update, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(BoundLabel_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(BoundLabel_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(BoundLabel_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, BoundLabel_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(BoundLabel_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(BoundLabel_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(BoundLabel_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(BoundLabel_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(BoundLabel_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(BoundLabel_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(BoundLabel_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(BoundLabel_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(BoundLabel_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(BoundLabel_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(BoundLabel_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(BoundLabel_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(BoundLabel_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(BoundLabel_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(BoundLabel_AnchorClient, self.0, aSpace);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(BoundLabel_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(BoundLabel_SetBiDiMode, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(BoundLabel_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(BoundLabel_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(BoundLabel_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(BoundLabel_SetColor, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(BoundLabel_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(BoundLabel_SetDragCursor, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(BoundLabel_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(BoundLabel_SetDragMode, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, BoundLabel_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(BoundLabel_SetFont, self.0, aValue.Instance());
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(BoundLabel_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(BoundLabel_SetHeight, self.0, aValue);
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(BoundLabel_GetLeft, self.0);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(BoundLabel_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(BoundLabel_SetParentColor, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(BoundLabel_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(BoundLabel_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(BoundLabel_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(BoundLabel_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, BoundLabel_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(BoundLabel_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowAccelChar(&self) -> bool  {
          return method_Call_1!(BoundLabel_GetShowAccelChar, self.0);
      }

	  pub fn SetShowAccelChar(&self, aValue: bool)  {
          method_Call_1!(BoundLabel_SetShowAccelChar, self.0, aValue);
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(BoundLabel_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(BoundLabel_SetShowHint, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(BoundLabel_GetTop, self.0);
      }

	  pub fn Layout(&self) -> TTextLayout  {
          return method_Call_1!(BoundLabel_GetLayout, self.0);
      }

	  pub fn SetLayout(&self, aValue: TTextLayout)  {
          method_Call_1!(BoundLabel_SetLayout, self.0, aValue);
      }

	  pub fn WordWrap(&self) -> bool  {
          return method_Call_1!(BoundLabel_GetWordWrap, self.0);
      }

	  pub fn SetWordWrap(&self, aValue: bool)  {
          method_Call_1!(BoundLabel_SetWordWrap, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(BoundLabel_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(BoundLabel_SetWidth, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(BoundLabel_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(BoundLabel_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(BoundLabel_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(BoundLabel_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(BoundLabel_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(BoundLabel_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(BoundLabel_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(BoundLabel_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, BoundLabel_GetCanvas, self.0);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(BoundLabel_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(BoundLabel_SetEnabled, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, BoundLabel_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(BoundLabel_SetAction, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(BoundLabel_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(BoundLabel_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(BoundLabel_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(BoundLabel_SetAnchors, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(BoundLabel_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(BoundLabel_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(BoundLabel_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(BoundLabel_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(BoundLabel_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(BoundLabel_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(BoundLabel_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(BoundLabel_SetClientWidth, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, BoundLabel_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(BoundLabel_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(BoundLabel_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(BoundLabel_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(BoundLabel_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(BoundLabel_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(BoundLabel_GetFloating, self.0);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(BoundLabel_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(BoundLabel_SetVisible, self.0, aValue);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, BoundLabel_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(BoundLabel_SetParent, self.0, aValue.Instance());
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(BoundLabel_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(BoundLabel_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(BoundLabel_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(BoundLabel_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(BoundLabel_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(BoundLabel_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(BoundLabel_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, BoundLabel_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(BoundLabel_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(BoundLabel_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(BoundLabel_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(BoundLabel_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, BoundLabel_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(BoundLabel_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, BoundLabel_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(BoundLabel_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, BoundLabel_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(BoundLabel_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, BoundLabel_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(BoundLabel_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, BoundLabel_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(BoundLabel_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, BoundLabel_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, BoundLabel_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(BoundLabel_StaticClassType);
}

impl_IObject!(TBoundLabel);
impl_IComponent!(TBoundLabel);
impl_IControl!(TBoundLabel);

impl TFlowPanel {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TFlowPanel, FlowPanel_Create, aOwner.Instance());
      }

      impl_As_method!(TFlowPanel);

	  impl_Free_method!(FlowPanel_Free);

	  pub fn GetControlIndex(&self, aControl: &dyn IControl) -> i32  {
          return method_Call_1!(FlowPanel_GetControlIndex, self.0, aControl.Instance());
      }

	  pub fn SetControlIndex(&self, aControl: &dyn IControl, index: i32)  {
          method_Call_1!(FlowPanel_SetControlIndex, self.0, aControl.Instance(), index);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(FlowPanel_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(FlowPanel_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, FlowPanel_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(FlowPanel_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(FlowPanel_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, FlowPanel_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(FlowPanel_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(FlowPanel_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(FlowPanel_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(FlowPanel_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(FlowPanel_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(FlowPanel_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(FlowPanel_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(FlowPanel_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(FlowPanel_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(FlowPanel_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(FlowPanel_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(FlowPanel_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(FlowPanel_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(FlowPanel_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(FlowPanel_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(FlowPanel_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(FlowPanel_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(FlowPanel_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(FlowPanel_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(FlowPanel_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(FlowPanel_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(FlowPanel_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(FlowPanel_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(FlowPanel_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(FlowPanel_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(FlowPanel_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(FlowPanel_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(FlowPanel_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, FlowPanel_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(FlowPanel_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(FlowPanel_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(FlowPanel_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(FlowPanel_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(FlowPanel_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(FlowPanel_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(FlowPanel_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(FlowPanel_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(FlowPanel_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(FlowPanel_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(FlowPanel_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(FlowPanel_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(FlowPanel_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(FlowPanel_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(FlowPanel_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(FlowPanel_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(FlowPanel_SetAlign, self.0, aValue);
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(FlowPanel_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(FlowPanel_SetAlignment, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(FlowPanel_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(FlowPanel_SetAnchors, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(FlowPanel_SetAutoSize, self.0, aValue);
      }

	  pub fn AutoWrap(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetAutoWrap, self.0);
      }

	  pub fn SetAutoWrap(&self, aValue: bool)  {
          method_Call_1!(FlowPanel_SetAutoWrap, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(FlowPanel_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(FlowPanel_SetBiDiMode, self.0, aValue);
      }

	  pub fn BorderWidth(&self) -> i32  {
          return method_Call_1!(FlowPanel_GetBorderWidth, self.0);
      }

	  pub fn SetBorderWidth(&self, aValue: i32)  {
          method_Call_1!(FlowPanel_SetBorderWidth, self.0, aValue);
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(FlowPanel_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(FlowPanel_SetBorderStyle, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(FlowPanel_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(FlowPanel_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(FlowPanel_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(FlowPanel_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, FlowPanel_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(FlowPanel_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(FlowPanel_SetUseDockManager, self.0, aValue);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(FlowPanel_SetDockSite, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(FlowPanel_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(FlowPanel_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(FlowPanel_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(FlowPanel_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(FlowPanel_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(FlowPanel_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(FlowPanel_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(FlowPanel_SetEnabled, self.0, aValue);
      }

	  pub fn FlowStyle(&self) -> TFlowStyle  {
          return method_Call_1!(FlowPanel_GetFlowStyle, self.0);
      }

	  pub fn SetFlowStyle(&self, aValue: TFlowStyle)  {
          method_Call_1!(FlowPanel_SetFlowStyle, self.0, aValue);
      }

	  pub fn FullRepaint(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetFullRepaint, self.0);
      }

	  pub fn SetFullRepaint(&self, aValue: bool)  {
          method_Call_1!(FlowPanel_SetFullRepaint, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, FlowPanel_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(FlowPanel_SetFont, self.0, aValue.Instance());
      }

	  pub fn ParentBackground(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetParentBackground, self.0);
      }

	  pub fn SetParentBackground(&self, aValue: bool)  {
          method_Call_1!(FlowPanel_SetParentBackground, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(FlowPanel_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(FlowPanel_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(FlowPanel_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(FlowPanel_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, FlowPanel_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(FlowPanel_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(FlowPanel_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(FlowPanel_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(FlowPanel_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(FlowPanel_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(FlowPanel_SetVisible, self.0, aValue);
      }

	  pub fn SetOnAlignPosition(&self, aEventId: TAlignPositionEvent)  {
          method_Call_1!(FlowPanel_SetOnAlignPosition, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(FlowPanel_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(FlowPanel_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDockDrop(&self, aEventId: TDockDropEvent)  {
          method_Call_1!(FlowPanel_SetOnDockDrop, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(FlowPanel_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(FlowPanel_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(FlowPanel_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(FlowPanel_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(FlowPanel_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(FlowPanel_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(FlowPanel_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnGetSiteInfo(&self, aEventId: TGetSiteInfoEvent)  {
          method_Call_1!(FlowPanel_SetOnGetSiteInfo, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(FlowPanel_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(FlowPanel_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(FlowPanel_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(FlowPanel_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(FlowPanel_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnResize(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(FlowPanel_SetOnResize, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(FlowPanel_SetOnStartDock, self.0, aEventId);
      }

	  pub fn SetOnUnDock(&self, aEventId: TUnDockEvent)  {
          method_Call_1!(FlowPanel_SetOnUnDock, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(FlowPanel_GetDockClientCount, self.0);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(FlowPanel_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, FlowPanel_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(FlowPanel_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(FlowPanel_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(FlowPanel_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(FlowPanel_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetShowing, self.0);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, FlowPanel_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(FlowPanel_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(FlowPanel_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(FlowPanel_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(FlowPanel_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(FlowPanel_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(FlowPanel_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(FlowPanel_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(FlowPanel_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(FlowPanel_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(FlowPanel_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(FlowPanel_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(FlowPanel_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(FlowPanel_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(FlowPanel_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, FlowPanel_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(FlowPanel_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(FlowPanel_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(FlowPanel_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(FlowPanel_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(FlowPanel_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(FlowPanel_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(FlowPanel_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(FlowPanel_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(FlowPanel_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(FlowPanel_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(FlowPanel_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(FlowPanel_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(FlowPanel_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(FlowPanel_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(FlowPanel_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(FlowPanel_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, FlowPanel_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(FlowPanel_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(FlowPanel_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(FlowPanel_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(FlowPanel_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, FlowPanel_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(FlowPanel_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, FlowPanel_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(FlowPanel_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, FlowPanel_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(FlowPanel_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, FlowPanel_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(FlowPanel_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, FlowPanel_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(FlowPanel_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, FlowPanel_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(FlowPanel_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, FlowPanel_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, FlowPanel_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, FlowPanel_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, FlowPanel_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(FlowPanel_StaticClassType);
}

impl_IObject!(TFlowPanel);
impl_IComponent!(TFlowPanel);
impl_IControl!(TFlowPanel);
impl_IWinControl!(TFlowPanel);

impl TCoolBar {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TCoolBar, CoolBar_Create, aOwner.Instance());
      }

      impl_As_method!(TCoolBar);

	  impl_Free_method!(CoolBar_Free);

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(CoolBar_FlipChildren, self.0, allLevels);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(CoolBar_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(CoolBar_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, CoolBar_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(CoolBar_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(CoolBar_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, CoolBar_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(CoolBar_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(CoolBar_HandleAllocated, self.0);
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(CoolBar_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(CoolBar_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(CoolBar_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(CoolBar_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(CoolBar_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(CoolBar_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(CoolBar_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(CoolBar_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(CoolBar_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(CoolBar_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CoolBar_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CoolBar_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(CoolBar_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(CoolBar_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(CoolBar_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(CoolBar_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(CoolBar_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CoolBar_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CoolBar_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(CoolBar_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(CoolBar_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(CoolBar_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(CoolBar_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(CoolBar_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, CoolBar_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CoolBar_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(CoolBar_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(CoolBar_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CoolBar_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(CoolBar_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(CoolBar_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(CoolBar_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(CoolBar_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CoolBar_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(CoolBar_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(CoolBar_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(CoolBar_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(CoolBar_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(CoolBar_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(CoolBar_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(CoolBar_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(CoolBar_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(CoolBar_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(CoolBar_SetAnchors, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(CoolBar_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetAutoSize, self.0, aValue);
      }

	  pub fn BandBorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(CoolBar_GetBandBorderStyle, self.0);
      }

	  pub fn SetBandBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(CoolBar_SetBandBorderStyle, self.0, aValue);
      }

	  pub fn BandMaximize(&self) -> TCoolBandMaximize  {
          return method_Call_1!(CoolBar_GetBandMaximize, self.0);
      }

	  pub fn SetBandMaximize(&self, aValue: TCoolBandMaximize)  {
          method_Call_1!(CoolBar_SetBandMaximize, self.0, aValue);
      }

	  pub fn Bands(&self) -> TCoolBands  {
          return method_Call_2!(TCoolBands, CoolBar_GetBands, self.0);
      }

	  pub fn SetBands(&self, aValue: &TCoolBands)  {
          method_Call_1!(CoolBar_SetBands, self.0, aValue.Instance());
      }

	  pub fn BorderWidth(&self) -> i32  {
          return method_Call_1!(CoolBar_GetBorderWidth, self.0);
      }

	  pub fn SetBorderWidth(&self, aValue: i32)  {
          method_Call_1!(CoolBar_SetBorderWidth, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(CoolBar_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(CoolBar_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, CoolBar_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(CoolBar_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(CoolBar_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetDockSite, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(CoolBar_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(CoolBar_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(CoolBar_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(CoolBar_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(CoolBar_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(CoolBar_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(CoolBar_SetDragMode, self.0, aValue);
      }

	  pub fn EdgeBorders(&self) -> TEdgeBorders  {
          return method_Call_1!(CoolBar_GetEdgeBorders, self.0);
      }

	  pub fn SetEdgeBorders(&self, aValue: TEdgeBorders)  {
          method_Call_1!(CoolBar_SetEdgeBorders, self.0, aValue);
      }

	  pub fn EdgeInner(&self) -> TEdgeStyle  {
          return method_Call_1!(CoolBar_GetEdgeInner, self.0);
      }

	  pub fn SetEdgeInner(&self, aValue: TEdgeStyle)  {
          method_Call_1!(CoolBar_SetEdgeInner, self.0, aValue);
      }

	  pub fn EdgeOuter(&self) -> TEdgeStyle  {
          return method_Call_1!(CoolBar_GetEdgeOuter, self.0);
      }

	  pub fn SetEdgeOuter(&self, aValue: TEdgeStyle)  {
          method_Call_1!(CoolBar_SetEdgeOuter, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(CoolBar_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetEnabled, self.0, aValue);
      }

	  pub fn FixedSize(&self) -> bool  {
          return method_Call_1!(CoolBar_GetFixedSize, self.0);
      }

	  pub fn SetFixedSize(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetFixedSize, self.0, aValue);
      }

	  pub fn FixedOrder(&self) -> bool  {
          return method_Call_1!(CoolBar_GetFixedOrder, self.0);
      }

	  pub fn SetFixedOrder(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetFixedOrder, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, CoolBar_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(CoolBar_SetFont, self.0, aValue.Instance());
      }

	  pub fn Images(&self) -> TImageList  {
          return method_Call_2!(TImageList, CoolBar_GetImages, self.0);
      }

	  pub fn SetImages(&self, aValue: &TImageList)  {
          method_Call_1!(CoolBar_SetImages, self.0, aValue.Instance());
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(CoolBar_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(CoolBar_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(CoolBar_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(CoolBar_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetParentShowHint, self.0, aValue);
      }

	  pub fn Bitmap(&self) -> TBitmap  {
          return method_Call_2!(TBitmap, CoolBar_GetBitmap, self.0);
      }

	  pub fn SetBitmap(&self, aValue: &TBitmap)  {
          method_Call_1!(CoolBar_SetBitmap, self.0, aValue.Instance());
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, CoolBar_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(CoolBar_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(CoolBar_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetShowHint, self.0, aValue);
      }

	  pub fn ShowText(&self) -> bool  {
          return method_Call_1!(CoolBar_GetShowText, self.0);
      }

	  pub fn SetShowText(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetShowText, self.0, aValue);
      }

	  pub fn Vertical(&self) -> bool  {
          return method_Call_1!(CoolBar_GetVertical, self.0);
      }

	  pub fn SetVertical(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetVertical, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(CoolBar_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetVisible, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CoolBar_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CoolBar_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(CoolBar_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CoolBar_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDockDrop(&self, aEventId: TDockDropEvent)  {
          method_Call_1!(CoolBar_SetOnDockDrop, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(CoolBar_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(CoolBar_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(CoolBar_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(CoolBar_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnGetSiteInfo(&self, aEventId: TGetSiteInfoEvent)  {
          method_Call_1!(CoolBar_SetOnGetSiteInfo, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(CoolBar_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CoolBar_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CoolBar_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(CoolBar_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(CoolBar_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnResize(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CoolBar_SetOnResize, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(CoolBar_SetOnStartDock, self.0, aEventId);
      }

	  pub fn SetOnUnDock(&self, aEventId: TUnDockEvent)  {
          method_Call_1!(CoolBar_SetOnUnDock, self.0, aEventId);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(CoolBar_GetDockClientCount, self.0);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(CoolBar_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(CoolBar_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, CoolBar_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(CoolBar_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(CoolBar_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(CoolBar_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(CoolBar_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(CoolBar_GetShowing, self.0);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(CoolBar_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(CoolBar_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(CoolBar_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetTabStop, self.0, aValue);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(CoolBar_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(CoolBar_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, CoolBar_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(CoolBar_SetAction, self.0, aValue.Instance());
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(CoolBar_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(CoolBar_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(CoolBar_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(CoolBar_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(CoolBar_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(CoolBar_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(CoolBar_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(CoolBar_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(CoolBar_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(CoolBar_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(CoolBar_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(CoolBar_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(CoolBar_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(CoolBar_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(CoolBar_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, CoolBar_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(CoolBar_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(CoolBar_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(CoolBar_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(CoolBar_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(CoolBar_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(CoolBar_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(CoolBar_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(CoolBar_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(CoolBar_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(CoolBar_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(CoolBar_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CoolBar_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(CoolBar_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(CoolBar_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(CoolBar_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(CoolBar_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, CoolBar_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CoolBar_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(CoolBar_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(CoolBar_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(CoolBar_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CoolBar_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CoolBar_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CoolBar_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CoolBar_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CoolBar_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CoolBar_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CoolBar_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CoolBar_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, CoolBar_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(CoolBar_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, CoolBar_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(CoolBar_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, CoolBar_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, CoolBar_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, CoolBar_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CoolBar_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(CoolBar_StaticClassType);
}

impl_IObject!(TCoolBar);
impl_IComponent!(TCoolBar);
impl_IControl!(TCoolBar);
impl_IWinControl!(TCoolBar);

impl TCoolBands {
      pub fn new(aOwner: &TCoolBar) -> Self {
        method_Create!(TCoolBands, CoolBands_Create, aOwner.Instance());
      }

      impl_As_method!(TCoolBands);

	  impl_Free_method!(CoolBands_Free);

	  pub fn Add(&self) -> TCoolBand  {
          return method_Call_2!(TCoolBand, CoolBands_Add, self.0);
      }

	  pub fn FindBand(&self, aControl: &dyn IControl) -> TCoolBand  {
          return method_Call_2!(TCoolBand, CoolBands_FindBand, self.0, aControl.Instance());
      }

	  pub fn Owner(&self) -> TObject  {
          return method_Call_2!(TObject, CoolBands_Owner, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(CoolBands_Assign, self.0, source.Instance());
      }

	  pub fn BeginUpdate(&self)  {
          method_Call_1!(CoolBands_BeginUpdate, self.0);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(CoolBands_Clear, self.0);
      }

	  pub fn Delete(&self, index: i32)  {
          method_Call_1!(CoolBands_Delete, self.0, index);
      }

	  pub fn EndUpdate(&self)  {
          method_Call_1!(CoolBands_EndUpdate, self.0);
      }

	  pub fn FindItemID(&self, iD: i32) -> TCollectionItem  {
          return method_Call_2!(TCollectionItem, CoolBands_FindItemID, self.0, iD);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CoolBands_GetNamePath, self.0));
      }

	  pub fn Insert(&self, index: i32) -> TCollectionItem  {
          return method_Call_2!(TCollectionItem, CoolBands_Insert, self.0, index);
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(CoolBands_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CoolBands_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(CoolBands_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(CoolBands_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(CoolBands_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(CoolBands_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CoolBands_ToString, self.0));
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(CoolBands_GetCount, self.0);
      }

	  pub fn Items(&self, index: i32) -> TCoolBand  {
          return method_Call_2!(TCoolBand, CoolBands_GetItems, self.0, index);
      }

	  pub fn SetItems(&self, index: i32, aValue: &TCoolBand)  {
          method_Call_1!(CoolBands_SetItems, self.0, index, aValue.Instance());
      }

      // static class
	  impl_Class_method!(CoolBands_StaticClassType);
}

impl_IObject!(TCoolBands);
impl_Drop_method!(TCoolBands);

impl TCoolBand {
      pub fn new(aOwner: &TCollection) -> Self {
        method_Create!(TCoolBand, CoolBand_Create, aOwner.Instance());
      }

      impl_As_method!(TCoolBand);

	  impl_Free_method!(CoolBand_Free);

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(CoolBand_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CoolBand_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(CoolBand_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CoolBand_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(CoolBand_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(CoolBand_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(CoolBand_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(CoolBand_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CoolBand_ToString, self.0));
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(CoolBand_GetHeight, self.0);
      }

	  pub fn Bitmap(&self) -> TBitmap  {
          return method_Call_2!(TBitmap, CoolBand_GetBitmap, self.0);
      }

	  pub fn SetBitmap(&self, aValue: &TBitmap)  {
          method_Call_1!(CoolBand_SetBitmap, self.0, aValue.Instance());
      }

	  pub fn BorderStyle(&self) -> TBorderStyle  {
          return method_Call_1!(CoolBand_GetBorderStyle, self.0);
      }

	  pub fn SetBorderStyle(&self, aValue: TBorderStyle)  {
          method_Call_1!(CoolBand_SetBorderStyle, self.0, aValue);
      }

	  pub fn Break(&self) -> bool  {
          return method_Call_1!(CoolBand_GetBreak, self.0);
      }

	  pub fn SetBreak(&self, aValue: bool)  {
          method_Call_1!(CoolBand_SetBreak, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(CoolBand_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(CoolBand_SetColor, self.0, aValue);
      }

	  pub fn Control(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, CoolBand_GetControl, self.0);
      }

	  pub fn SetControl(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(CoolBand_SetControl, self.0, aValue.Instance());
      }

	  pub fn FixedBackground(&self) -> bool  {
          return method_Call_1!(CoolBand_GetFixedBackground, self.0);
      }

	  pub fn SetFixedBackground(&self, aValue: bool)  {
          method_Call_1!(CoolBand_SetFixedBackground, self.0, aValue);
      }

	  pub fn FixedSize(&self) -> bool  {
          return method_Call_1!(CoolBand_GetFixedSize, self.0);
      }

	  pub fn SetFixedSize(&self, aValue: bool)  {
          method_Call_1!(CoolBand_SetFixedSize, self.0, aValue);
      }

	  pub fn HorizontalOnly(&self) -> bool  {
          return method_Call_1!(CoolBand_GetHorizontalOnly, self.0);
      }

	  pub fn SetHorizontalOnly(&self, aValue: bool)  {
          method_Call_1!(CoolBand_SetHorizontalOnly, self.0, aValue);
      }

	  pub fn ImageIndex(&self) -> i32  {
          return method_Call_1!(CoolBand_GetImageIndex, self.0);
      }

	  pub fn SetImageIndex(&self, aValue: i32)  {
          method_Call_1!(CoolBand_SetImageIndex, self.0, aValue);
      }

	  pub fn MinHeight(&self) -> i32  {
          return method_Call_1!(CoolBand_GetMinHeight, self.0);
      }

	  pub fn SetMinHeight(&self, aValue: i32)  {
          method_Call_1!(CoolBand_SetMinHeight, self.0, aValue);
      }

	  pub fn MinWidth(&self) -> i32  {
          return method_Call_1!(CoolBand_GetMinWidth, self.0);
      }

	  pub fn SetMinWidth(&self, aValue: i32)  {
          method_Call_1!(CoolBand_SetMinWidth, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(CoolBand_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(CoolBand_SetParentColor, self.0, aValue);
      }

	  pub fn ParentBitmap(&self) -> bool  {
          return method_Call_1!(CoolBand_GetParentBitmap, self.0);
      }

	  pub fn SetParentBitmap(&self, aValue: bool)  {
          method_Call_1!(CoolBand_SetParentBitmap, self.0, aValue);
      }

	  pub fn Text<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CoolBand_GetText, self.0));
      }

	  pub fn SetText(&self, aValue: &str)  {
          method_Call_1!(CoolBand_SetText, self.0, to_CString!(aValue));
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(CoolBand_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(CoolBand_SetVisible, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(CoolBand_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(CoolBand_SetWidth, self.0, aValue);
      }

	  pub fn Collection(&self) -> TCollection  {
          return method_Call_2!(TCollection, CoolBand_GetCollection, self.0);
      }

	  pub fn SetCollection(&self, aValue: &TCollection)  {
          method_Call_1!(CoolBand_SetCollection, self.0, aValue.Instance());
      }

	  pub fn Index(&self) -> i32  {
          return method_Call_1!(CoolBand_GetIndex, self.0);
      }

	  pub fn SetIndex(&self, aValue: i32)  {
          method_Call_1!(CoolBand_SetIndex, self.0, aValue);
      }

	  pub fn DisplayName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CoolBand_GetDisplayName, self.0));
      }

	  pub fn SetDisplayName(&self, aValue: &str)  {
          method_Call_1!(CoolBand_SetDisplayName, self.0, to_CString!(aValue));
      }

      // static class
	  impl_Class_method!(CoolBand_StaticClassType);
}

impl_IObject!(TCoolBand);
impl_Drop_method!(TCoolBand);

impl TCollection {
      pub fn new(aOwner: usize) -> Self {
        method_Create!(TCollection, Collection_Create, aOwner);
      }

      impl_As_method!(TCollection);

	  impl_Free_method!(Collection_Free);

	  pub fn Owner(&self) -> TObject  {
          return method_Call_2!(TObject, Collection_Owner, self.0);
      }

	  pub fn Add(&self) -> TCollectionItem  {
          return method_Call_2!(TCollectionItem, Collection_Add, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(Collection_Assign, self.0, source.Instance());
      }

	  pub fn BeginUpdate(&self)  {
          method_Call_1!(Collection_BeginUpdate, self.0);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(Collection_Clear, self.0);
      }

	  pub fn Delete(&self, index: i32)  {
          method_Call_1!(Collection_Delete, self.0, index);
      }

	  pub fn EndUpdate(&self)  {
          method_Call_1!(Collection_EndUpdate, self.0);
      }

	  pub fn FindItemID(&self, iD: i32) -> TCollectionItem  {
          return method_Call_2!(TCollectionItem, Collection_FindItemID, self.0, iD);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Collection_GetNamePath, self.0));
      }

	  pub fn Insert(&self, index: i32) -> TCollectionItem  {
          return method_Call_2!(TCollectionItem, Collection_Insert, self.0, index);
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Collection_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Collection_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Collection_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Collection_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Collection_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Collection_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Collection_ToString, self.0));
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(Collection_GetCount, self.0);
      }

	  pub fn Items(&self, index: i32) -> TCollectionItem  {
          return method_Call_2!(TCollectionItem, Collection_GetItems, self.0, index);
      }

	  pub fn SetItems(&self, index: i32, aValue: &TCollectionItem)  {
          method_Call_1!(Collection_SetItems, self.0, index, aValue.Instance());
      }

      // static class
	  impl_Class_method!(Collection_StaticClassType);
}

impl_IObject!(TCollection);
impl_Drop_method!(TCollection);

impl TPrinter {
      pub fn new() -> Self {
        method_Create!(TPrinter, Printer_Create, );
      }

      impl_As_method!(TPrinter);

	  impl_Free_method!(Printer_Free);

	  pub fn Abort(&self)  {
          method_Call_1!(Printer_Abort, self.0);
      }

	  pub fn BeginDoc(&self)  {
          method_Call_1!(Printer_BeginDoc, self.0);
      }

	  pub fn EndDoc(&self)  {
          method_Call_1!(Printer_EndDoc, self.0);
      }

	  pub fn NewPage(&self)  {
          method_Call_1!(Printer_NewPage, self.0);
      }

	  pub fn Refresh(&self)  {
          method_Call_1!(Printer_Refresh, self.0);
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Printer_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Printer_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Printer_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Printer_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Printer_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Printer_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Printer_ToString, self.0));
      }

	  pub fn Aborted(&self) -> bool  {
          return method_Call_1!(Printer_GetAborted, self.0);
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, Printer_GetCanvas, self.0);
      }

	  pub fn Copies(&self) -> i32  {
          return method_Call_1!(Printer_GetCopies, self.0);
      }

	  pub fn SetCopies(&self, aValue: i32)  {
          method_Call_1!(Printer_SetCopies, self.0, aValue);
      }

	  pub fn Fonts(&self) -> TStrings  {
          return method_Call_2!(TStrings, Printer_GetFonts, self.0);
      }

	  pub fn Orientation(&self) -> TPrinterOrientation  {
          return method_Call_1!(Printer_GetOrientation, self.0);
      }

	  pub fn SetOrientation(&self, aValue: TPrinterOrientation)  {
          method_Call_1!(Printer_SetOrientation, self.0, aValue);
      }

	  pub fn PageHeight(&self) -> i32  {
          return method_Call_1!(Printer_GetPageHeight, self.0);
      }

	  pub fn PageWidth(&self) -> i32  {
          return method_Call_1!(Printer_GetPageWidth, self.0);
      }

	  pub fn PageNumber(&self) -> i32  {
          return method_Call_1!(Printer_GetPageNumber, self.0);
      }

	  pub fn PrinterIndex(&self) -> i32  {
          return method_Call_1!(Printer_GetPrinterIndex, self.0);
      }

	  pub fn SetPrinterIndex(&self, aValue: i32)  {
          method_Call_1!(Printer_SetPrinterIndex, self.0, aValue);
      }

	  pub fn Printing(&self) -> bool  {
          return method_Call_1!(Printer_GetPrinting, self.0);
      }

	  pub fn Printers(&self) -> TStrings  {
          return method_Call_2!(TStrings, Printer_GetPrinters, self.0);
      }

	  pub fn Title<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Printer_GetTitle, self.0));
      }

	  pub fn SetTitle(&self, aValue: &str)  {
          method_Call_1!(Printer_SetTitle, self.0, to_CString!(aValue));
      }

      // static class
	  impl_Class_method!(Printer_StaticClassType);
	  pub fn SetPrinter(&self, aName: &str)  {
          method_Call_1!(Printer_SetPrinter, self.0, to_CString!(aName));
      }

}

impl_IObject!(TPrinter);
impl_Drop_method!(TPrinter);

impl TTaskDialog {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TTaskDialog, TaskDialog_Create, aOwner.Instance());
      }

      impl_As_method!(TTaskDialog);

	  impl_Free_method!(TaskDialog_Free);

	  pub fn Execute(&self) -> bool  {
          return method_Call_1!(TaskDialog_Execute, self.0);
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, TaskDialog_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TaskDialog_GetNamePath, self.0));
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(TaskDialog_HasParent, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(TaskDialog_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(TaskDialog_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TaskDialog_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(TaskDialog_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(TaskDialog_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(TaskDialog_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(TaskDialog_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TaskDialog_ToString, self.0));
      }

	  pub fn Buttons(&self) -> TTaskDialogButtons  {
          return method_Call_2!(TTaskDialogButtons, TaskDialog_GetButtons, self.0);
      }

	  pub fn SetButtons(&self, aValue: &TTaskDialogButtons)  {
          method_Call_1!(TaskDialog_SetButtons, self.0, aValue.Instance());
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialog_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(TaskDialog_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn CommonButtons(&self) -> TTaskDialogCommonButtons  {
          return method_Call_1!(TaskDialog_GetCommonButtons, self.0);
      }

	  pub fn SetCommonButtons(&self, aValue: TTaskDialogCommonButtons)  {
          method_Call_1!(TaskDialog_SetCommonButtons, self.0, aValue);
      }

	  pub fn DefaultButton(&self) -> TTaskDialogCommonButton  {
          return method_Call_1!(TaskDialog_GetDefaultButton, self.0);
      }

	  pub fn SetDefaultButton(&self, aValue: TTaskDialogCommonButton)  {
          method_Call_1!(TaskDialog_SetDefaultButton, self.0, aValue);
      }

	  pub fn ExpandButtonCaption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialog_GetExpandButtonCaption, self.0));
      }

	  pub fn SetExpandButtonCaption(&self, aValue: &str)  {
          method_Call_1!(TaskDialog_SetExpandButtonCaption, self.0, to_CString!(aValue));
      }

	  pub fn ExpandedText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialog_GetExpandedText, self.0));
      }

	  pub fn SetExpandedText(&self, aValue: &str)  {
          method_Call_1!(TaskDialog_SetExpandedText, self.0, to_CString!(aValue));
      }

	  pub fn Flags(&self) -> TTaskDialogFlags  {
          return method_Call_1!(TaskDialog_GetFlags, self.0);
      }

	  pub fn SetFlags(&self, aValue: TTaskDialogFlags)  {
          method_Call_1!(TaskDialog_SetFlags, self.0, aValue);
      }

	  pub fn FooterIcon(&self) -> TTaskDialogIcon  {
          return method_Call_1!(TaskDialog_GetFooterIcon, self.0);
      }

	  pub fn SetFooterIcon(&self, aValue: TTaskDialogIcon)  {
          method_Call_1!(TaskDialog_SetFooterIcon, self.0, aValue);
      }

	  pub fn FooterText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialog_GetFooterText, self.0));
      }

	  pub fn SetFooterText(&self, aValue: &str)  {
          method_Call_1!(TaskDialog_SetFooterText, self.0, to_CString!(aValue));
      }

	  pub fn MainIcon(&self) -> TTaskDialogIcon  {
          return method_Call_1!(TaskDialog_GetMainIcon, self.0);
      }

	  pub fn SetMainIcon(&self, aValue: TTaskDialogIcon)  {
          method_Call_1!(TaskDialog_SetMainIcon, self.0, aValue);
      }

	  pub fn RadioButtons(&self) -> TTaskDialogButtons  {
          return method_Call_2!(TTaskDialogButtons, TaskDialog_GetRadioButtons, self.0);
      }

	  pub fn SetRadioButtons(&self, aValue: &TTaskDialogButtons)  {
          method_Call_1!(TaskDialog_SetRadioButtons, self.0, aValue.Instance());
      }

	  pub fn Text<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialog_GetText, self.0));
      }

	  pub fn SetText(&self, aValue: &str)  {
          method_Call_1!(TaskDialog_SetText, self.0, to_CString!(aValue));
      }

	  pub fn Title<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialog_GetTitle, self.0));
      }

	  pub fn SetTitle(&self, aValue: &str)  {
          method_Call_1!(TaskDialog_SetTitle, self.0, to_CString!(aValue));
      }

	  pub fn VerificationText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialog_GetVerificationText, self.0));
      }

	  pub fn SetVerificationText(&self, aValue: &str)  {
          method_Call_1!(TaskDialog_SetVerificationText, self.0, to_CString!(aValue));
      }

	  pub fn SetOnButtonClicked(&self, aEventId: TTaskDlgClickEvent)  {
          method_Call_1!(TaskDialog_SetOnButtonClicked, self.0, aEventId);
      }

	  pub fn Button(&self) -> TTaskDialogButtonItem  {
          return method_Call_2!(TTaskDialogButtonItem, TaskDialog_GetButton, self.0);
      }

	  pub fn SetButton(&self, aValue: &TTaskDialogButtonItem)  {
          method_Call_1!(TaskDialog_SetButton, self.0, aValue.Instance());
      }

	  pub fn ModalResult(&self) -> TModalResult  {
          return method_Call_1!(TaskDialog_GetModalResult, self.0);
      }

	  pub fn SetModalResult(&self, aValue: TModalResult)  {
          method_Call_1!(TaskDialog_SetModalResult, self.0, aValue);
      }

	  pub fn RadioButton(&self) -> TTaskDialogRadioButtonItem  {
          return method_Call_2!(TTaskDialogRadioButtonItem, TaskDialog_GetRadioButton, self.0);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(TaskDialog_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(TaskDialog_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(TaskDialog_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, TaskDialog_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialog_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(TaskDialog_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(TaskDialog_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(TaskDialog_SetTag, self.0, aValue);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, TaskDialog_GetComponents, self.0, aIndex);
      }

      // static class
	  impl_Class_method!(TaskDialog_StaticClassType);
}

impl_IObject!(TTaskDialog);
impl_IComponent!(TTaskDialog);

impl TTaskDialogButtons {
	  pub fn Add(&self) -> TTaskDialogBaseButtonItem  {
          return method_Call_2!(TTaskDialogBaseButtonItem, TaskDialogButtons_Add, self.0);
      }

	  pub fn FindButton(&self, aModalResult: TModalResult) -> TTaskDialogBaseButtonItem  {
          return method_Call_2!(TTaskDialogBaseButtonItem, TaskDialogButtons_FindButton, self.0, aModalResult);
      }

	  pub fn Owner(&self) -> TObject  {
          return method_Call_2!(TObject, TaskDialogButtons_Owner, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(TaskDialogButtons_Assign, self.0, source.Instance());
      }

	  pub fn BeginUpdate(&self)  {
          method_Call_1!(TaskDialogButtons_BeginUpdate, self.0);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(TaskDialogButtons_Clear, self.0);
      }

	  pub fn Delete(&self, index: i32)  {
          method_Call_1!(TaskDialogButtons_Delete, self.0, index);
      }

	  pub fn EndUpdate(&self)  {
          method_Call_1!(TaskDialogButtons_EndUpdate, self.0);
      }

	  pub fn FindItemID(&self, iD: i32) -> TCollectionItem  {
          return method_Call_2!(TCollectionItem, TaskDialogButtons_FindItemID, self.0, iD);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialogButtons_GetNamePath, self.0));
      }

	  pub fn Insert(&self, index: i32) -> TCollectionItem  {
          return method_Call_2!(TCollectionItem, TaskDialogButtons_Insert, self.0, index);
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(TaskDialogButtons_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TaskDialogButtons_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(TaskDialogButtons_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(TaskDialogButtons_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(TaskDialogButtons_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(TaskDialogButtons_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TaskDialogButtons_ToString, self.0));
      }

	  pub fn DefaultButton(&self) -> TTaskDialogBaseButtonItem  {
          return method_Call_2!(TTaskDialogBaseButtonItem, TaskDialogButtons_GetDefaultButton, self.0);
      }

	  pub fn SetDefaultButton(&self, aValue: &TTaskDialogBaseButtonItem)  {
          method_Call_1!(TaskDialogButtons_SetDefaultButton, self.0, aValue.Instance());
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(TaskDialogButtons_GetCount, self.0);
      }

	  pub fn Items(&self, index: i32) -> TTaskDialogBaseButtonItem  {
          return method_Call_2!(TTaskDialogBaseButtonItem, TaskDialogButtons_GetItems, self.0, index);
      }

	  pub fn SetItems(&self, index: i32, aValue: &TTaskDialogBaseButtonItem)  {
          method_Call_1!(TaskDialogButtons_SetItems, self.0, index, aValue.Instance());
      }

      // static class
	  impl_Class_method!(TaskDialogButtons_StaticClassType);
}

impl_IObject!(TTaskDialogButtons);

impl TTaskDialogButtonItem {
      pub fn new(aOwner: &TCollection) -> Self {
        method_Create!(TTaskDialogButtonItem, TaskDialogButtonItem_Create, aOwner.Instance());
      }

      impl_As_method!(TTaskDialogButtonItem);

	  impl_Free_method!(TaskDialogButtonItem_Free);

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialogButtonItem_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(TaskDialogButtonItem_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(TaskDialogButtonItem_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TaskDialogButtonItem_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(TaskDialogButtonItem_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(TaskDialogButtonItem_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(TaskDialogButtonItem_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(TaskDialogButtonItem_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TaskDialogButtonItem_ToString, self.0));
      }

	  pub fn ModalResult(&self) -> TModalResult  {
          return method_Call_1!(TaskDialogButtonItem_GetModalResult, self.0);
      }

	  pub fn SetModalResult(&self, aValue: TModalResult)  {
          method_Call_1!(TaskDialogButtonItem_SetModalResult, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialogButtonItem_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(TaskDialogButtonItem_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Default(&self) -> bool  {
          return method_Call_1!(TaskDialogButtonItem_GetDefault, self.0);
      }

	  pub fn SetDefault(&self, aValue: bool)  {
          method_Call_1!(TaskDialogButtonItem_SetDefault, self.0, aValue);
      }

	  pub fn Collection(&self) -> TCollection  {
          return method_Call_2!(TCollection, TaskDialogButtonItem_GetCollection, self.0);
      }

	  pub fn SetCollection(&self, aValue: &TCollection)  {
          method_Call_1!(TaskDialogButtonItem_SetCollection, self.0, aValue.Instance());
      }

	  pub fn Index(&self) -> i32  {
          return method_Call_1!(TaskDialogButtonItem_GetIndex, self.0);
      }

	  pub fn SetIndex(&self, aValue: i32)  {
          method_Call_1!(TaskDialogButtonItem_SetIndex, self.0, aValue);
      }

	  pub fn DisplayName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialogButtonItem_GetDisplayName, self.0));
      }

	  pub fn SetDisplayName(&self, aValue: &str)  {
          method_Call_1!(TaskDialogButtonItem_SetDisplayName, self.0, to_CString!(aValue));
      }

      // static class
	  impl_Class_method!(TaskDialogButtonItem_StaticClassType);
}

impl_IObject!(TTaskDialogButtonItem);
impl_Drop_method!(TTaskDialogButtonItem);

impl TTaskDialogRadioButtonItem {
      pub fn new(aOwner: &TCollection) -> Self {
        method_Create!(TTaskDialogRadioButtonItem, TaskDialogRadioButtonItem_Create, aOwner.Instance());
      }

      impl_As_method!(TTaskDialogRadioButtonItem);

	  impl_Free_method!(TaskDialogRadioButtonItem_Free);

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialogRadioButtonItem_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(TaskDialogRadioButtonItem_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(TaskDialogRadioButtonItem_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TaskDialogRadioButtonItem_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(TaskDialogRadioButtonItem_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(TaskDialogRadioButtonItem_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(TaskDialogRadioButtonItem_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(TaskDialogRadioButtonItem_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TaskDialogRadioButtonItem_ToString, self.0));
      }

	  pub fn ModalResult(&self) -> TModalResult  {
          return method_Call_1!(TaskDialogRadioButtonItem_GetModalResult, self.0);
      }

	  pub fn SetModalResult(&self, aValue: TModalResult)  {
          method_Call_1!(TaskDialogRadioButtonItem_SetModalResult, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialogRadioButtonItem_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(TaskDialogRadioButtonItem_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Default(&self) -> bool  {
          return method_Call_1!(TaskDialogRadioButtonItem_GetDefault, self.0);
      }

	  pub fn SetDefault(&self, aValue: bool)  {
          method_Call_1!(TaskDialogRadioButtonItem_SetDefault, self.0, aValue);
      }

	  pub fn Collection(&self) -> TCollection  {
          return method_Call_2!(TCollection, TaskDialogRadioButtonItem_GetCollection, self.0);
      }

	  pub fn SetCollection(&self, aValue: &TCollection)  {
          method_Call_1!(TaskDialogRadioButtonItem_SetCollection, self.0, aValue.Instance());
      }

	  pub fn Index(&self) -> i32  {
          return method_Call_1!(TaskDialogRadioButtonItem_GetIndex, self.0);
      }

	  pub fn SetIndex(&self, aValue: i32)  {
          method_Call_1!(TaskDialogRadioButtonItem_SetIndex, self.0, aValue);
      }

	  pub fn DisplayName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialogRadioButtonItem_GetDisplayName, self.0));
      }

	  pub fn SetDisplayName(&self, aValue: &str)  {
          method_Call_1!(TaskDialogRadioButtonItem_SetDisplayName, self.0, to_CString!(aValue));
      }

      // static class
	  impl_Class_method!(TaskDialogRadioButtonItem_StaticClassType);
}

impl_IObject!(TTaskDialogRadioButtonItem);
impl_Drop_method!(TTaskDialogRadioButtonItem);

impl TTaskDialogBaseButtonItem {
      pub fn new(aOwner: &TCollection) -> Self {
        method_Create!(TTaskDialogBaseButtonItem, TaskDialogBaseButtonItem_Create, aOwner.Instance());
      }

      impl_As_method!(TTaskDialogBaseButtonItem);

	  impl_Free_method!(TaskDialogBaseButtonItem_Free);

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialogBaseButtonItem_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(TaskDialogBaseButtonItem_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(TaskDialogBaseButtonItem_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TaskDialogBaseButtonItem_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(TaskDialogBaseButtonItem_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(TaskDialogBaseButtonItem_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(TaskDialogBaseButtonItem_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(TaskDialogBaseButtonItem_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(TaskDialogBaseButtonItem_ToString, self.0));
      }

	  pub fn ModalResult(&self) -> TModalResult  {
          return method_Call_1!(TaskDialogBaseButtonItem_GetModalResult, self.0);
      }

	  pub fn SetModalResult(&self, aValue: TModalResult)  {
          method_Call_1!(TaskDialogBaseButtonItem_SetModalResult, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialogBaseButtonItem_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(TaskDialogBaseButtonItem_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Default(&self) -> bool  {
          return method_Call_1!(TaskDialogBaseButtonItem_GetDefault, self.0);
      }

	  pub fn SetDefault(&self, aValue: bool)  {
          method_Call_1!(TaskDialogBaseButtonItem_SetDefault, self.0, aValue);
      }

	  pub fn Collection(&self) -> TCollection  {
          return method_Call_2!(TCollection, TaskDialogBaseButtonItem_GetCollection, self.0);
      }

	  pub fn SetCollection(&self, aValue: &TCollection)  {
          method_Call_1!(TaskDialogBaseButtonItem_SetCollection, self.0, aValue.Instance());
      }

	  pub fn Index(&self) -> i32  {
          return method_Call_1!(TaskDialogBaseButtonItem_GetIndex, self.0);
      }

	  pub fn SetIndex(&self, aValue: i32)  {
          method_Call_1!(TaskDialogBaseButtonItem_SetIndex, self.0, aValue);
      }

	  pub fn DisplayName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(TaskDialogBaseButtonItem_GetDisplayName, self.0));
      }

	  pub fn SetDisplayName(&self, aValue: &str)  {
          method_Call_1!(TaskDialogBaseButtonItem_SetDisplayName, self.0, to_CString!(aValue));
      }

      // static class
	  impl_Class_method!(TaskDialogBaseButtonItem_StaticClassType);
}

impl_IObject!(TTaskDialogBaseButtonItem);
impl_Drop_method!(TTaskDialogBaseButtonItem);

impl TComboBoxEx {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TComboBoxEx, ComboBoxEx_Create, aOwner.Instance());
      }

      impl_As_method!(TComboBoxEx);

	  impl_Free_method!(ComboBoxEx_Free);

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(ComboBoxEx_Focused, self.0);
      }

	  pub fn AddItem(&self, item: &str, aObject: &dyn IObject)  {
          method_Call_1!(ComboBoxEx_AddItem, self.0, to_CString!(item), aObject.Instance());
      }

	  pub fn Clear(&self)  {
          method_Call_1!(ComboBoxEx_Clear, self.0);
      }

	  pub fn ClearSelection(&self)  {
          method_Call_1!(ComboBoxEx_ClearSelection, self.0);
      }

	  pub fn DeleteSelected(&self)  {
          method_Call_1!(ComboBoxEx_DeleteSelected, self.0);
      }

	  pub fn SelectAll(&self)  {
          method_Call_1!(ComboBoxEx_SelectAll, self.0);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(ComboBoxEx_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(ComboBoxEx_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, ComboBoxEx_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(ComboBoxEx_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(ComboBoxEx_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, ComboBoxEx_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(ComboBoxEx_FlipChildren, self.0, allLevels);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(ComboBoxEx_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ComboBoxEx_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(ComboBoxEx_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ComboBoxEx_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(ComboBoxEx_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(ComboBoxEx_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(ComboBoxEx_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(ComboBoxEx_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(ComboBoxEx_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(ComboBoxEx_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(ComboBoxEx_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(ComboBoxEx_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ComboBoxEx_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ComboBoxEx_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(ComboBoxEx_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ComboBoxEx_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(ComboBoxEx_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(ComboBoxEx_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(ComboBoxEx_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ComboBoxEx_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ComboBoxEx_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(ComboBoxEx_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(ComboBoxEx_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(ComboBoxEx_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(ComboBoxEx_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(ComboBoxEx_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ComboBoxEx_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ComboBoxEx_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ComboBoxEx_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ComboBoxEx_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ComboBoxEx_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ComboBoxEx_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ComboBoxEx_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ComboBoxEx_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ComboBoxEx_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ComboBoxEx_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ComboBoxEx_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ComboBoxEx_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ComboBoxEx_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ComboBoxEx_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(ComboBoxEx_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(ComboBoxEx_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(ComboBoxEx_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(ComboBoxEx_SetAlign, self.0, aValue);
      }

	  pub fn AutoCompleteOptions(&self) -> TAutoCompleteOptions  {
          return method_Call_1!(ComboBoxEx_GetAutoCompleteOptions, self.0);
      }

	  pub fn SetAutoCompleteOptions(&self, aValue: TAutoCompleteOptions)  {
          method_Call_1!(ComboBoxEx_SetAutoCompleteOptions, self.0, aValue);
      }

	  pub fn ItemsEx(&self) -> TComboExItems  {
          return method_Call_2!(TComboExItems, ComboBoxEx_GetItemsEx, self.0);
      }

	  pub fn SetItemsEx(&self, aValue: &TComboExItems)  {
          method_Call_1!(ComboBoxEx_SetItemsEx, self.0, aValue.Instance());
      }

	  pub fn Style(&self) -> TComboBoxExStyle  {
          return method_Call_1!(ComboBoxEx_GetStyle, self.0);
      }

	  pub fn SetStyle(&self, aValue: TComboBoxExStyle)  {
          method_Call_1!(ComboBoxEx_SetStyle, self.0, aValue);
      }

	  pub fn StyleEx(&self) -> TComboBoxExStyles  {
          return method_Call_1!(ComboBoxEx_GetStyleEx, self.0);
      }

	  pub fn SetStyleEx(&self, aValue: TComboBoxExStyles)  {
          method_Call_1!(ComboBoxEx_SetStyleEx, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, ComboBoxEx_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(ComboBoxEx_SetAction, self.0, aValue.Instance());
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(ComboBoxEx_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(ComboBoxEx_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(ComboBoxEx_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(ComboBoxEx_SetBiDiMode, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(ComboBoxEx_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(ComboBoxEx_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, ComboBoxEx_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(ComboBoxEx_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(ComboBoxEx_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ComboBoxEx_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(ComboBoxEx_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(ComboBoxEx_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(ComboBoxEx_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(ComboBoxEx_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(ComboBoxEx_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(ComboBoxEx_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(ComboBoxEx_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(ComboBoxEx_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, ComboBoxEx_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(ComboBoxEx_SetFont, self.0, aValue.Instance());
      }

	  pub fn ItemHeight(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetItemHeight, self.0);
      }

	  pub fn SetItemHeight(&self, aValue: i32)  {
          method_Call_1!(ComboBoxEx_SetItemHeight, self.0, aValue);
      }

	  pub fn MaxLength(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetMaxLength, self.0);
      }

	  pub fn SetMaxLength(&self, aValue: i32)  {
          method_Call_1!(ComboBoxEx_SetMaxLength, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(ComboBoxEx_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(ComboBoxEx_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(ComboBoxEx_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ComboBoxEx_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(ComboBoxEx_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(ComboBoxEx_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(ComboBoxEx_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(ComboBoxEx_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, ComboBoxEx_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(ComboBoxEx_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(ComboBoxEx_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(ComboBoxEx_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(ComboBoxEx_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(ComboBoxEx_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(ComboBoxEx_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(ComboBoxEx_SetTabStop, self.0, aValue);
      }

	  pub fn Text<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ComboBoxEx_GetText, self.0));
      }

	  pub fn SetText(&self, aValue: &str)  {
          method_Call_1!(ComboBoxEx_SetText, self.0, to_CString!(aValue));
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(ComboBoxEx_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(ComboBoxEx_SetVisible, self.0, aValue);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBoxEx_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBoxEx_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(ComboBoxEx_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBoxEx_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(ComboBoxEx_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(ComboBoxEx_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnDropDown(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBoxEx_SetOnDropDown, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ComboBoxEx_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ComboBoxEx_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBoxEx_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBoxEx_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ComboBoxEx_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(ComboBoxEx_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(ComboBoxEx_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(ComboBoxEx_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnSelect(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ComboBoxEx_SetOnSelect, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(ComboBoxEx_SetOnStartDock, self.0, aEventId);
      }

	  pub fn Images(&self) -> TImageList  {
          return method_Call_2!(TImageList, ComboBoxEx_GetImages, self.0);
      }

	  pub fn SetImages(&self, aValue: &TImageList)  {
          method_Call_1!(ComboBoxEx_SetImages, self.0, aValue.Instance());
      }

	  pub fn DropDownCount(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetDropDownCount, self.0);
      }

	  pub fn SetDropDownCount(&self, aValue: i32)  {
          method_Call_1!(ComboBoxEx_SetDropDownCount, self.0, aValue);
      }

	  pub fn SelText<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ComboBoxEx_GetSelText, self.0));
      }

	  pub fn SetSelText(&self, aValue: &str)  {
          method_Call_1!(ComboBoxEx_SetSelText, self.0, to_CString!(aValue));
      }

	  pub fn Canvas(&self) -> TCanvas  {
          return method_Call_2!(TCanvas, ComboBoxEx_GetCanvas, self.0);
      }

	  pub fn DroppedDown(&self) -> bool  {
          return method_Call_1!(ComboBoxEx_GetDroppedDown, self.0);
      }

	  pub fn SetDroppedDown(&self, aValue: bool)  {
          method_Call_1!(ComboBoxEx_SetDroppedDown, self.0, aValue);
      }

	  pub fn Items(&self) -> TStrings  {
          return method_Call_2!(TStrings, ComboBoxEx_GetItems, self.0);
      }

	  pub fn SetItems(&self, aValue: &dyn IStrings)  {
          method_Call_1!(ComboBoxEx_SetItems, self.0, aValue.Instance());
      }

	  pub fn SelLength(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetSelLength, self.0);
      }

	  pub fn SetSelLength(&self, aValue: i32)  {
          method_Call_1!(ComboBoxEx_SetSelLength, self.0, aValue);
      }

	  pub fn SelStart(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetSelStart, self.0);
      }

	  pub fn SetSelStart(&self, aValue: i32)  {
          method_Call_1!(ComboBoxEx_SetSelStart, self.0, aValue);
      }

	  pub fn ItemIndex(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetItemIndex, self.0);
      }

	  pub fn SetItemIndex(&self, aValue: i32)  {
          method_Call_1!(ComboBoxEx_SetItemIndex, self.0, aValue);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(ComboBoxEx_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(ComboBoxEx_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(ComboBoxEx_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, ComboBoxEx_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(ComboBoxEx_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(ComboBoxEx_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(ComboBoxEx_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(ComboBoxEx_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(ComboBoxEx_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(ComboBoxEx_SetUseDockManager, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ComboBoxEx_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(ComboBoxEx_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(ComboBoxEx_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ComboBoxEx_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ComboBoxEx_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(ComboBoxEx_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(ComboBoxEx_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(ComboBoxEx_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(ComboBoxEx_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(ComboBoxEx_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(ComboBoxEx_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, ComboBoxEx_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(ComboBoxEx_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ComboBoxEx_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ComboBoxEx_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ComboBoxEx_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(ComboBoxEx_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(ComboBoxEx_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(ComboBoxEx_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ComboBoxEx_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(ComboBoxEx_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ComboBoxEx_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ComboBoxEx_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ComboBoxEx_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ComboBoxEx_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ComboBoxEx_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ComboBoxEx_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ComboBoxEx_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ComboBoxEx_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ComboBoxEx_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ComboBoxEx_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ComboBoxEx_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ComboBoxEx_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ComboBoxEx_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ComboBoxEx_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ComboBoxEx_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, ComboBoxEx_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(ComboBoxEx_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, ComboBoxEx_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(ComboBoxEx_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ComboBoxEx_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ComboBoxEx_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ComboBoxEx_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ComboBoxEx_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(ComboBoxEx_StaticClassType);
}

impl_IObject!(TComboBoxEx);
impl_IComponent!(TComboBoxEx);
impl_IControl!(TComboBoxEx);
impl_IWinControl!(TComboBoxEx);

impl TComboExItems {
	  pub fn Add(&self) -> TComboExItem  {
          return method_Call_2!(TComboExItem, ComboExItems_Add, self.0);
      }

	  pub fn AddItem(&self, caption: &str, imageIndex: i32, selectedImageIndex: i32, overlayImageIndex: i32, indent: i32, data: usize) -> TComboExItem  {
          return method_Call_2!(TComboExItem, ComboExItems_AddItem, self.0, to_CString!(caption), imageIndex, selectedImageIndex, overlayImageIndex, indent, data);
      }

	  pub fn Insert(&self, index: i32) -> TComboExItem  {
          return method_Call_2!(TComboExItem, ComboExItems_Insert, self.0, index);
      }

	  pub fn Owner(&self) -> TObject  {
          return method_Call_2!(TObject, ComboExItems_Owner, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(ComboExItems_Assign, self.0, source.Instance());
      }

	  pub fn BeginUpdate(&self)  {
          method_Call_1!(ComboExItems_BeginUpdate, self.0);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(ComboExItems_Clear, self.0);
      }

	  pub fn Delete(&self, index: i32)  {
          method_Call_1!(ComboExItems_Delete, self.0, index);
      }

	  pub fn EndUpdate(&self)  {
          method_Call_1!(ComboExItems_EndUpdate, self.0);
      }

	  pub fn FindItemID(&self, iD: i32) -> TCollectionItem  {
          return method_Call_2!(TCollectionItem, ComboExItems_FindItemID, self.0, iD);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ComboExItems_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ComboExItems_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ComboExItems_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ComboExItems_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ComboExItems_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ComboExItems_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ComboExItems_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ComboExItems_ToString, self.0));
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(ComboExItems_GetCount, self.0);
      }

	  pub fn ComboItems(&self, index: i32) -> TComboExItem  {
          return method_Call_2!(TComboExItem, ComboExItems_GetComboItems, self.0, index);
      }

      // static class
	  impl_Class_method!(ComboExItems_StaticClassType);
}

impl_IObject!(TComboExItems);

impl TComboExItem {
	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(ComboExItem_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ComboExItem_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ComboExItem_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ComboExItem_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ComboExItem_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ComboExItem_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ComboExItem_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ComboExItem_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ComboExItem_ToString, self.0));
      }

	  pub fn Indent(&self) -> i32  {
          return method_Call_1!(ComboExItem_GetIndent, self.0);
      }

	  pub fn SetIndent(&self, aValue: i32)  {
          method_Call_1!(ComboExItem_SetIndent, self.0, aValue);
      }

	  pub fn OverlayImageIndex(&self) -> i32  {
          return method_Call_1!(ComboExItem_GetOverlayImageIndex, self.0);
      }

	  pub fn SetOverlayImageIndex(&self, aValue: i32)  {
          method_Call_1!(ComboExItem_SetOverlayImageIndex, self.0, aValue);
      }

	  pub fn Data(&self) -> usize  {
          return method_Call_1!(ComboExItem_GetData, self.0);
      }

	  pub fn SetData(&self, aValue: usize)  {
          method_Call_1!(ComboExItem_SetData, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ComboExItem_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(ComboExItem_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn ImageIndex(&self) -> i32  {
          return method_Call_1!(ComboExItem_GetImageIndex, self.0);
      }

	  pub fn SetImageIndex(&self, aValue: i32)  {
          method_Call_1!(ComboExItem_SetImageIndex, self.0, aValue);
      }

	  pub fn Collection(&self) -> TCollection  {
          return method_Call_2!(TCollection, ComboExItem_GetCollection, self.0);
      }

	  pub fn SetCollection(&self, aValue: &TCollection)  {
          method_Call_1!(ComboExItem_SetCollection, self.0, aValue.Instance());
      }

	  pub fn Index(&self) -> i32  {
          return method_Call_1!(ComboExItem_GetIndex, self.0);
      }

	  pub fn SetIndex(&self, aValue: i32)  {
          method_Call_1!(ComboExItem_SetIndex, self.0, aValue);
      }

	  pub fn DisplayName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ComboExItem_GetDisplayName, self.0));
      }

	  pub fn SetDisplayName(&self, aValue: &str)  {
          method_Call_1!(ComboExItem_SetDisplayName, self.0, to_CString!(aValue));
      }

      // static class
	  impl_Class_method!(ComboExItem_StaticClassType);
}

impl_IObject!(TComboExItem);

impl TFrame {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TFrame, Frame_Create, aOwner.Instance());
      }

      impl_As_method!(TFrame);

	  impl_Free_method!(Frame_Free);

	  pub fn ScrollInView(&self, aControl: &dyn IControl)  {
          method_Call_1!(Frame_ScrollInView, self.0, aControl.Instance());
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(Frame_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(Frame_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, Frame_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(Frame_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(Frame_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, Frame_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(Frame_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(Frame_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(Frame_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(Frame_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(Frame_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(Frame_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(Frame_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(Frame_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(Frame_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(Frame_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(Frame_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(Frame_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(Frame_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(Frame_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Frame_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Frame_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(Frame_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(Frame_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(Frame_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(Frame_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(Frame_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Frame_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(Frame_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(Frame_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(Frame_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(Frame_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(Frame_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(Frame_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, Frame_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Frame_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(Frame_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(Frame_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Frame_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(Frame_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(Frame_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(Frame_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(Frame_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(Frame_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Frame_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(Frame_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Frame_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(Frame_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(Frame_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(Frame_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(Frame_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(Frame_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(Frame_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(Frame_SetAnchors, self.0, aValue);
      }

	  pub fn AutoScroll(&self) -> bool  {
          return method_Call_1!(Frame_GetAutoScroll, self.0);
      }

	  pub fn SetAutoScroll(&self, aValue: bool)  {
          method_Call_1!(Frame_SetAutoScroll, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(Frame_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(Frame_SetAutoSize, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(Frame_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(Frame_SetBiDiMode, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, Frame_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(Frame_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(Frame_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(Frame_SetDockSite, self.0, aValue);
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(Frame_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(Frame_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(Frame_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(Frame_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(Frame_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(Frame_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(Frame_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(Frame_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(Frame_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(Frame_SetEnabled, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(Frame_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(Frame_SetColor, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, Frame_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(Frame_SetFont, self.0, aValue.Instance());
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(Frame_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(Frame_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(Frame_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(Frame_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(Frame_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(Frame_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(Frame_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(Frame_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, Frame_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(Frame_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(Frame_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(Frame_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(Frame_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(Frame_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(Frame_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(Frame_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(Frame_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(Frame_SetVisible, self.0, aValue);
      }

	  pub fn SetOnAlignPosition(&self, aEventId: TAlignPositionEvent)  {
          method_Call_1!(Frame_SetOnAlignPosition, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Frame_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnContextPopup(&self, aEventId: TContextPopupEvent)  {
          method_Call_1!(Frame_SetOnContextPopup, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Frame_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDockDrop(&self, aEventId: TDockDropEvent)  {
          method_Call_1!(Frame_SetOnDockDrop, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(Frame_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(Frame_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDock(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(Frame_SetOnEndDock, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(Frame_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Frame_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Frame_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnGetSiteInfo(&self, aEventId: TGetSiteInfoEvent)  {
          method_Call_1!(Frame_SetOnGetSiteInfo, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Frame_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Frame_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Frame_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(Frame_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(Frame_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnMouseWheel(&self, aEventId: TMouseWheelEvent)  {
          method_Call_1!(Frame_SetOnMouseWheel, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelDown(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(Frame_SetOnMouseWheelDown, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelUp(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(Frame_SetOnMouseWheelUp, self.0, aEventId);
      }

	  pub fn SetOnResize(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(Frame_SetOnResize, self.0, aEventId);
      }

	  pub fn SetOnStartDock(&self, aEventId: TStartDockEvent)  {
          method_Call_1!(Frame_SetOnStartDock, self.0, aEventId);
      }

	  pub fn SetOnUnDock(&self, aEventId: TUnDockEvent)  {
          method_Call_1!(Frame_SetOnUnDock, self.0, aEventId);
      }

	  pub fn HorzScrollBar(&self) -> TControlScrollBar  {
          return method_Call_2!(TControlScrollBar, Frame_GetHorzScrollBar, self.0);
      }

	  pub fn SetHorzScrollBar(&self, aValue: &TControlScrollBar)  {
          method_Call_1!(Frame_SetHorzScrollBar, self.0, aValue.Instance());
      }

	  pub fn VertScrollBar(&self) -> TControlScrollBar  {
          return method_Call_2!(TControlScrollBar, Frame_GetVertScrollBar, self.0);
      }

	  pub fn SetVertScrollBar(&self, aValue: &TControlScrollBar)  {
          method_Call_1!(Frame_SetVertScrollBar, self.0, aValue.Instance());
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(Frame_GetDockClientCount, self.0);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(Frame_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(Frame_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, Frame_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(Frame_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(Frame_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(Frame_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(Frame_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(Frame_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(Frame_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(Frame_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, Frame_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(Frame_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Frame_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(Frame_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(Frame_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(Frame_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(Frame_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(Frame_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(Frame_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(Frame_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(Frame_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(Frame_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(Frame_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(Frame_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(Frame_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, Frame_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(Frame_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(Frame_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(Frame_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(Frame_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(Frame_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(Frame_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(Frame_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(Frame_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(Frame_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(Frame_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(Frame_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Frame_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(Frame_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(Frame_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(Frame_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(Frame_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, Frame_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(Frame_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(Frame_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(Frame_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(Frame_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Frame_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Frame_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Frame_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Frame_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Frame_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Frame_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Frame_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(Frame_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, Frame_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(Frame_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, Frame_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(Frame_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, Frame_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, Frame_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, Frame_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, Frame_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(Frame_StaticClassType);
}

impl_IObject!(TFrame);
impl_IComponent!(TFrame);
impl_IControl!(TFrame);
impl_IWinControl!(TFrame);

impl TControlScrollBar {
	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(ControlScrollBar_Assign, self.0, source.Instance());
      }

	  pub fn IsScrollBarVisible(&self) -> bool  {
          return method_Call_1!(ControlScrollBar_IsScrollBarVisible, self.0);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ControlScrollBar_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ControlScrollBar_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ControlScrollBar_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ControlScrollBar_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ControlScrollBar_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ControlScrollBar_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ControlScrollBar_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ControlScrollBar_ToString, self.0));
      }

	  pub fn ScrollPos(&self) -> i32  {
          return method_Call_1!(ControlScrollBar_GetScrollPos, self.0);
      }

	  pub fn Increment(&self) -> TScrollBarInc  {
          return method_Call_1!(ControlScrollBar_GetIncrement, self.0);
      }

	  pub fn SetIncrement(&self, aValue: TScrollBarInc)  {
          method_Call_1!(ControlScrollBar_SetIncrement, self.0, aValue);
      }

	  pub fn Position(&self) -> i32  {
          return method_Call_1!(ControlScrollBar_GetPosition, self.0);
      }

	  pub fn SetPosition(&self, aValue: i32)  {
          method_Call_1!(ControlScrollBar_SetPosition, self.0, aValue);
      }

	  pub fn Range(&self) -> i32  {
          return method_Call_1!(ControlScrollBar_GetRange, self.0);
      }

	  pub fn SetRange(&self, aValue: i32)  {
          method_Call_1!(ControlScrollBar_SetRange, self.0, aValue);
      }

	  pub fn Smooth(&self) -> bool  {
          return method_Call_1!(ControlScrollBar_GetSmooth, self.0);
      }

	  pub fn SetSmooth(&self, aValue: bool)  {
          method_Call_1!(ControlScrollBar_SetSmooth, self.0, aValue);
      }

	  pub fn Tracking(&self) -> bool  {
          return method_Call_1!(ControlScrollBar_GetTracking, self.0);
      }

	  pub fn SetTracking(&self, aValue: bool)  {
          method_Call_1!(ControlScrollBar_SetTracking, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(ControlScrollBar_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(ControlScrollBar_SetVisible, self.0, aValue);
      }

      // static class
	  impl_Class_method!(ControlScrollBar_StaticClassType);
}

impl_IObject!(TControlScrollBar);

impl TSizeConstraints {
	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(SizeConstraints_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(SizeConstraints_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(SizeConstraints_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SizeConstraints_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(SizeConstraints_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(SizeConstraints_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(SizeConstraints_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(SizeConstraints_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(SizeConstraints_ToString, self.0));
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(SizeConstraints_SetOnChange, self.0, aEventId);
      }

	  pub fn MaxHeight(&self) -> TConstraintSize  {
          return method_Call_1!(SizeConstraints_GetMaxHeight, self.0);
      }

	  pub fn SetMaxHeight(&self, aValue: TConstraintSize)  {
          method_Call_1!(SizeConstraints_SetMaxHeight, self.0, aValue);
      }

	  pub fn MaxWidth(&self) -> TConstraintSize  {
          return method_Call_1!(SizeConstraints_GetMaxWidth, self.0);
      }

	  pub fn SetMaxWidth(&self, aValue: TConstraintSize)  {
          method_Call_1!(SizeConstraints_SetMaxWidth, self.0, aValue);
      }

	  pub fn MinHeight(&self) -> TConstraintSize  {
          return method_Call_1!(SizeConstraints_GetMinHeight, self.0);
      }

	  pub fn SetMinHeight(&self, aValue: TConstraintSize)  {
          method_Call_1!(SizeConstraints_SetMinHeight, self.0, aValue);
      }

	  pub fn MinWidth(&self) -> TConstraintSize  {
          return method_Call_1!(SizeConstraints_GetMinWidth, self.0);
      }

	  pub fn SetMinWidth(&self, aValue: TConstraintSize)  {
          method_Call_1!(SizeConstraints_SetMinWidth, self.0, aValue);
      }

      // static class
	  impl_Class_method!(SizeConstraints_StaticClassType);
}

impl_IObject!(TSizeConstraints);

impl TXButton {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TXButton, XButton_Create, aOwner.Instance());
      }

      impl_As_method!(TXButton);

	  impl_Free_method!(XButton_Free);

	  pub fn BringToFront(&self) {
          method_Call_1!(XButton_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(XButton_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(XButton_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(XButton_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(XButton_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(XButton_Hide, self.0);
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(XButton_Invalidate, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(XButton_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(XButton_Refresh, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(XButton_Repaint, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(XButton_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(XButton_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(XButton_SendToBack, self.0);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(XButton_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn Show(&self) {
          method_Call_1!(XButton_Show, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(XButton_Update, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(XButton_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(XButton_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(XButton_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, XButton_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(XButton_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(XButton_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(XButton_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(XButton_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(XButton_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(XButton_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(XButton_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(XButton_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(XButton_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(XButton_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(XButton_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(XButton_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(XButton_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(XButton_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(XButton_AnchorClient, self.0, aSpace);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(XButton_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(XButton_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn ShowCaption(&self) -> bool  {
          return method_Call_1!(XButton_GetShowCaption, self.0);
      }

	  pub fn SetShowCaption(&self, aValue: bool)  {
          method_Call_1!(XButton_SetShowCaption, self.0, aValue);
      }

	  pub fn BackColor(&self) -> TColor  {
          return method_Call_1!(XButton_GetBackColor, self.0);
      }

	  pub fn SetBackColor(&self, aValue: TColor)  {
          method_Call_1!(XButton_SetBackColor, self.0, aValue);
      }

	  pub fn HoverColor(&self) -> TColor  {
          return method_Call_1!(XButton_GetHoverColor, self.0);
      }

	  pub fn SetHoverColor(&self, aValue: TColor)  {
          method_Call_1!(XButton_SetHoverColor, self.0, aValue);
      }

	  pub fn DownColor(&self) -> TColor  {
          return method_Call_1!(XButton_GetDownColor, self.0);
      }

	  pub fn SetDownColor(&self, aValue: TColor)  {
          method_Call_1!(XButton_SetDownColor, self.0, aValue);
      }

	  pub fn BorderWidth(&self) -> i32  {
          return method_Call_1!(XButton_GetBorderWidth, self.0);
      }

	  pub fn SetBorderWidth(&self, aValue: i32)  {
          method_Call_1!(XButton_SetBorderWidth, self.0, aValue);
      }

	  pub fn BorderColor(&self) -> TColor  {
          return method_Call_1!(XButton_GetBorderColor, self.0);
      }

	  pub fn SetBorderColor(&self, aValue: TColor)  {
          method_Call_1!(XButton_SetBorderColor, self.0, aValue);
      }

	  pub fn Picture(&self) -> TPicture  {
          return method_Call_2!(TPicture, XButton_GetPicture, self.0);
      }

	  pub fn SetPicture(&self, aValue: &TPicture)  {
          method_Call_1!(XButton_SetPicture, self.0, aValue.Instance());
      }

	  pub fn DrawMode(&self) -> TDrawImageMode  {
          return method_Call_1!(XButton_GetDrawMode, self.0);
      }

	  pub fn SetDrawMode(&self, aValue: TDrawImageMode)  {
          method_Call_1!(XButton_SetDrawMode, self.0, aValue);
      }

	  pub fn NormalFontColor(&self) -> TColor  {
          return method_Call_1!(XButton_GetNormalFontColor, self.0);
      }

	  pub fn SetNormalFontColor(&self, aValue: TColor)  {
          method_Call_1!(XButton_SetNormalFontColor, self.0, aValue);
      }

	  pub fn DownFontColor(&self) -> TColor  {
          return method_Call_1!(XButton_GetDownFontColor, self.0);
      }

	  pub fn SetDownFontColor(&self, aValue: TColor)  {
          method_Call_1!(XButton_SetDownFontColor, self.0, aValue);
      }

	  pub fn HoverFontColor(&self) -> TColor  {
          return method_Call_1!(XButton_GetHoverFontColor, self.0);
      }

	  pub fn SetHoverFontColor(&self, aValue: TColor)  {
          method_Call_1!(XButton_SetHoverFontColor, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, XButton_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(XButton_SetAction, self.0, aValue.Instance());
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(XButton_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(XButton_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(XButton_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(XButton_SetAnchors, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(XButton_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(XButton_SetBiDiMode, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, XButton_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(XButton_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(XButton_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(XButton_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, XButton_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(XButton_SetFont, self.0, aValue.Instance());
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(XButton_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(XButton_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(XButton_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(XButton_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, XButton_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(XButton_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(XButton_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(XButton_SetShowHint, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(XButton_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(XButton_SetVisible, self.0, aValue);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(XButton_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(XButton_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(XButton_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(XButton_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(XButton_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(XButton_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(XButton_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(XButton_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(XButton_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(XButton_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(XButton_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(XButton_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(XButton_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(XButton_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(XButton_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(XButton_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(XButton_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(XButton_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(XButton_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(XButton_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, XButton_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(XButton_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(XButton_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(XButton_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(XButton_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(XButton_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(XButton_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(XButton_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(XButton_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(XButton_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(XButton_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(XButton_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(XButton_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(XButton_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(XButton_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(XButton_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(XButton_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, XButton_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(XButton_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(XButton_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(XButton_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(XButton_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, XButton_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(XButton_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, XButton_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(XButton_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, XButton_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(XButton_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, XButton_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(XButton_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, XButton_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(XButton_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, XButton_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, XButton_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(XButton_StaticClassType);
}

impl_IObject!(TXButton);
impl_IComponent!(TXButton);
impl_IControl!(TXButton);

impl TAnchorSide {
	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(AnchorSide_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(AnchorSide_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(AnchorSide_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(AnchorSide_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(AnchorSide_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(AnchorSide_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(AnchorSide_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(AnchorSide_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(AnchorSide_ToString, self.0));
      }

	  pub fn Owner(&self) -> TControl  {
          return method_Call_2!(TControl, AnchorSide_GetOwner, self.0);
      }

	  pub fn Control(&self) -> TControl  {
          return method_Call_2!(TControl, AnchorSide_GetControl, self.0);
      }

	  pub fn SetControl(&self, aValue: &dyn IControl)  {
          method_Call_1!(AnchorSide_SetControl, self.0, aValue.Instance());
      }

	  pub fn Side(&self) -> TAnchorSideReference  {
          return method_Call_1!(AnchorSide_GetSide, self.0);
      }

	  pub fn SetSide(&self, aValue: TAnchorSideReference)  {
          method_Call_1!(AnchorSide_SetSide, self.0, aValue);
      }

      // static class
	  impl_Class_method!(AnchorSide_StaticClassType);
}

impl_IObject!(TAnchorSide);

impl TControlBorderSpacing {
	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(ControlBorderSpacing_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ControlBorderSpacing_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ControlBorderSpacing_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ControlBorderSpacing_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ControlBorderSpacing_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ControlBorderSpacing_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ControlBorderSpacing_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ControlBorderSpacing_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ControlBorderSpacing_ToString, self.0));
      }

	  pub fn Control(&self) -> TControl  {
          return method_Call_2!(TControl, ControlBorderSpacing_GetControl, self.0);
      }

	  pub fn AroundLeft(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetAroundLeft, self.0);
      }

	  pub fn AroundTop(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetAroundTop, self.0);
      }

	  pub fn AroundRight(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetAroundRight, self.0);
      }

	  pub fn AroundBottom(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetAroundBottom, self.0);
      }

	  pub fn ControlLeft(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetControlLeft, self.0);
      }

	  pub fn ControlTop(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetControlTop, self.0);
      }

	  pub fn ControlWidth(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetControlWidth, self.0);
      }

	  pub fn ControlHeight(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetControlHeight, self.0);
      }

	  pub fn ControlRight(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetControlRight, self.0);
      }

	  pub fn ControlBottom(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetControlBottom, self.0);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ControlBorderSpacing_SetOnChange, self.0, aEventId);
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ControlBorderSpacing_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ControlBorderSpacing_SetTop, self.0, aValue);
      }

	  pub fn Right(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetRight, self.0);
      }

	  pub fn SetRight(&self, aValue: i32)  {
          method_Call_1!(ControlBorderSpacing_SetRight, self.0, aValue);
      }

	  pub fn Bottom(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetBottom, self.0);
      }

	  pub fn SetBottom(&self, aValue: i32)  {
          method_Call_1!(ControlBorderSpacing_SetBottom, self.0, aValue);
      }

	  pub fn Around(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetAround, self.0);
      }

	  pub fn SetAround(&self, aValue: i32)  {
          method_Call_1!(ControlBorderSpacing_SetAround, self.0, aValue);
      }

	  pub fn InnerBorder(&self) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetInnerBorder, self.0);
      }

	  pub fn SetInnerBorder(&self, aValue: i32)  {
          method_Call_1!(ControlBorderSpacing_SetInnerBorder, self.0, aValue);
      }

	  pub fn CellAlignHorizontal(&self) -> TControlCellAlign  {
          return method_Call_1!(ControlBorderSpacing_GetCellAlignHorizontal, self.0);
      }

	  pub fn SetCellAlignHorizontal(&self, aValue: TControlCellAlign)  {
          method_Call_1!(ControlBorderSpacing_SetCellAlignHorizontal, self.0, aValue);
      }

	  pub fn CellAlignVertical(&self) -> TControlCellAlign  {
          return method_Call_1!(ControlBorderSpacing_GetCellAlignVertical, self.0);
      }

	  pub fn SetCellAlignVertical(&self, aValue: TControlCellAlign)  {
          method_Call_1!(ControlBorderSpacing_SetCellAlignVertical, self.0, aValue);
      }

	  pub fn Space(&self, kind: TAnchorKind) -> i32  {
          return method_Call_1!(ControlBorderSpacing_GetSpace, self.0, kind);
      }

	  pub fn SetSpace(&self, kind: TAnchorKind, aValue: i32)  {
          method_Call_1!(ControlBorderSpacing_SetSpace, self.0, kind, aValue);
      }

      // static class
	  impl_Class_method!(ControlBorderSpacing_StaticClassType);
}

impl_IObject!(TControlBorderSpacing);

impl TControlChildSizing {
	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(ControlChildSizing_Assign, self.0, source.Instance());
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ControlChildSizing_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ControlChildSizing_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ControlChildSizing_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ControlChildSizing_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ControlChildSizing_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ControlChildSizing_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ControlChildSizing_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ControlChildSizing_ToString, self.0));
      }

	  pub fn Control(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, ControlChildSizing_GetControl, self.0);
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ControlChildSizing_SetOnChange, self.0, aEventId);
      }

	  pub fn LeftRightSpacing(&self) -> i32  {
          return method_Call_1!(ControlChildSizing_GetLeftRightSpacing, self.0);
      }

	  pub fn SetLeftRightSpacing(&self, aValue: i32)  {
          method_Call_1!(ControlChildSizing_SetLeftRightSpacing, self.0, aValue);
      }

	  pub fn TopBottomSpacing(&self) -> i32  {
          return method_Call_1!(ControlChildSizing_GetTopBottomSpacing, self.0);
      }

	  pub fn SetTopBottomSpacing(&self, aValue: i32)  {
          method_Call_1!(ControlChildSizing_SetTopBottomSpacing, self.0, aValue);
      }

	  pub fn HorizontalSpacing(&self) -> i32  {
          return method_Call_1!(ControlChildSizing_GetHorizontalSpacing, self.0);
      }

	  pub fn SetHorizontalSpacing(&self, aValue: i32)  {
          method_Call_1!(ControlChildSizing_SetHorizontalSpacing, self.0, aValue);
      }

	  pub fn VerticalSpacing(&self) -> i32  {
          return method_Call_1!(ControlChildSizing_GetVerticalSpacing, self.0);
      }

	  pub fn SetVerticalSpacing(&self, aValue: i32)  {
          method_Call_1!(ControlChildSizing_SetVerticalSpacing, self.0, aValue);
      }

	  pub fn EnlargeHorizontal(&self) -> TChildControlResizeStyle  {
          return method_Call_1!(ControlChildSizing_GetEnlargeHorizontal, self.0);
      }

	  pub fn SetEnlargeHorizontal(&self, aValue: TChildControlResizeStyle)  {
          method_Call_1!(ControlChildSizing_SetEnlargeHorizontal, self.0, aValue);
      }

	  pub fn EnlargeVertical(&self) -> TChildControlResizeStyle  {
          return method_Call_1!(ControlChildSizing_GetEnlargeVertical, self.0);
      }

	  pub fn SetEnlargeVertical(&self, aValue: TChildControlResizeStyle)  {
          method_Call_1!(ControlChildSizing_SetEnlargeVertical, self.0, aValue);
      }

	  pub fn ShrinkHorizontal(&self) -> TChildControlResizeStyle  {
          return method_Call_1!(ControlChildSizing_GetShrinkHorizontal, self.0);
      }

	  pub fn SetShrinkHorizontal(&self, aValue: TChildControlResizeStyle)  {
          method_Call_1!(ControlChildSizing_SetShrinkHorizontal, self.0, aValue);
      }

	  pub fn ShrinkVertical(&self) -> TChildControlResizeStyle  {
          return method_Call_1!(ControlChildSizing_GetShrinkVertical, self.0);
      }

	  pub fn SetShrinkVertical(&self, aValue: TChildControlResizeStyle)  {
          method_Call_1!(ControlChildSizing_SetShrinkVertical, self.0, aValue);
      }

	  pub fn Layout(&self) -> TControlChildrenLayout  {
          return method_Call_1!(ControlChildSizing_GetLayout, self.0);
      }

	  pub fn SetLayout(&self, aValue: TControlChildrenLayout)  {
          method_Call_1!(ControlChildSizing_SetLayout, self.0, aValue);
      }

	  pub fn ControlsPerLine(&self) -> i32  {
          return method_Call_1!(ControlChildSizing_GetControlsPerLine, self.0);
      }

	  pub fn SetControlsPerLine(&self, aValue: i32)  {
          method_Call_1!(ControlChildSizing_SetControlsPerLine, self.0, aValue);
      }

      // static class
	  impl_Class_method!(ControlChildSizing_StaticClassType);
}

impl_IObject!(TControlChildSizing);

impl TCheckGroup {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TCheckGroup, CheckGroup_Create, aOwner.Instance());
      }

      impl_As_method!(TCheckGroup);

	  impl_Free_method!(CheckGroup_Free);

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(CheckGroup_FlipChildren, self.0, allLevels);
      }

	  pub fn Rows(&self) -> i32  {
          return method_Call_1!(CheckGroup_Rows, self.0);
      }

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(CheckGroup_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(CheckGroup_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, CheckGroup_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(CheckGroup_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(CheckGroup_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, CheckGroup_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(CheckGroup_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(CheckGroup_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(CheckGroup_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(CheckGroup_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(CheckGroup_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(CheckGroup_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(CheckGroup_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(CheckGroup_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(CheckGroup_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(CheckGroup_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(CheckGroup_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(CheckGroup_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(CheckGroup_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CheckGroup_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CheckGroup_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(CheckGroup_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(CheckGroup_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(CheckGroup_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(CheckGroup_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(CheckGroup_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CheckGroup_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(CheckGroup_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(CheckGroup_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(CheckGroup_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(CheckGroup_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(CheckGroup_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(CheckGroup_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, CheckGroup_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CheckGroup_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(CheckGroup_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(CheckGroup_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CheckGroup_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(CheckGroup_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(CheckGroup_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(CheckGroup_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(CheckGroup_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(CheckGroup_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(CheckGroup_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(CheckGroup_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(CheckGroup_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(CheckGroup_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(CheckGroup_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(CheckGroup_AnchorClient, self.0, aSpace);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(CheckGroup_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(CheckGroup_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(CheckGroup_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(CheckGroup_SetAnchors, self.0, aValue);
      }

	  pub fn AutoFill(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetAutoFill, self.0);
      }

	  pub fn SetAutoFill(&self, aValue: bool)  {
          method_Call_1!(CheckGroup_SetAutoFill, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(CheckGroup_SetAutoSize, self.0, aValue);
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(CheckGroup_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(CheckGroup_SetBiDiMode, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CheckGroup_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(CheckGroup_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(CheckGroup_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(CheckGroup_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(CheckGroup_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(CheckGroup_SetClientWidth, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(CheckGroup_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(CheckGroup_SetColor, self.0, aValue);
      }

	  pub fn ColumnLayout(&self) -> TColumnLayout  {
          return method_Call_1!(CheckGroup_GetColumnLayout, self.0);
      }

	  pub fn SetColumnLayout(&self, aValue: TColumnLayout)  {
          method_Call_1!(CheckGroup_SetColumnLayout, self.0, aValue);
      }

	  pub fn Columns(&self) -> i32  {
          return method_Call_1!(CheckGroup_GetColumns, self.0);
      }

	  pub fn SetColumns(&self, aValue: i32)  {
          method_Call_1!(CheckGroup_SetColumns, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, CheckGroup_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(CheckGroup_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(CheckGroup_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(CheckGroup_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(CheckGroup_SetDragCursor, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(CheckGroup_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(CheckGroup_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(CheckGroup_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, CheckGroup_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(CheckGroup_SetFont, self.0, aValue.Instance());
      }

	  pub fn Items(&self) -> TStrings  {
          return method_Call_2!(TStrings, CheckGroup_GetItems, self.0);
      }

	  pub fn SetItems(&self, aValue: &dyn IStrings)  {
          method_Call_1!(CheckGroup_SetItems, self.0, aValue.Instance());
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckGroup_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnDblClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckGroup_SetOnDblClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(CheckGroup_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(CheckGroup_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(CheckGroup_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckGroup_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckGroup_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnItemClick(&self, aEventId: TCheckGroupClicked)  {
          method_Call_1!(CheckGroup_SetOnItemClick, self.0, aEventId);
      }

	  pub fn SetOnKeyDown(&self, aEventId: TKeyEvent)  {
          method_Call_1!(CheckGroup_SetOnKeyDown, self.0, aEventId);
      }

	  pub fn SetOnKeyPress(&self, aEventId: TKeyPressEvent)  {
          method_Call_1!(CheckGroup_SetOnKeyPress, self.0, aEventId);
      }

	  pub fn SetOnKeyUp(&self, aEventId: TKeyEvent)  {
          method_Call_1!(CheckGroup_SetOnKeyUp, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(CheckGroup_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckGroup_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckGroup_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(CheckGroup_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(CheckGroup_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnMouseWheel(&self, aEventId: TMouseWheelEvent)  {
          method_Call_1!(CheckGroup_SetOnMouseWheel, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelDown(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(CheckGroup_SetOnMouseWheelDown, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelUp(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(CheckGroup_SetOnMouseWheelUp, self.0, aEventId);
      }

	  pub fn SetOnResize(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(CheckGroup_SetOnResize, self.0, aEventId);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(CheckGroup_SetParentFont, self.0, aValue);
      }

	  pub fn ParentColor(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetParentColor, self.0);
      }

	  pub fn SetParentColor(&self, aValue: bool)  {
          method_Call_1!(CheckGroup_SetParentColor, self.0, aValue);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(CheckGroup_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(CheckGroup_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, CheckGroup_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(CheckGroup_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(CheckGroup_SetShowHint, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(CheckGroup_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(CheckGroup_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(CheckGroup_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(CheckGroup_SetVisible, self.0, aValue);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(CheckGroup_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(CheckGroup_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(CheckGroup_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, CheckGroup_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(CheckGroup_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(CheckGroup_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(CheckGroup_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(CheckGroup_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(CheckGroup_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, CheckGroup_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(CheckGroup_SetAction, self.0, aValue.Instance());
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(CheckGroup_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(CheckGroup_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(CheckGroup_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(CheckGroup_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(CheckGroup_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(CheckGroup_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(CheckGroup_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(CheckGroup_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(CheckGroup_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, CheckGroup_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(CheckGroup_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(CheckGroup_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(CheckGroup_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(CheckGroup_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(CheckGroup_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(CheckGroup_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(CheckGroup_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(CheckGroup_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(CheckGroup_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(CheckGroup_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(CheckGroup_SetCursor, self.0, aValue);
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CheckGroup_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(CheckGroup_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(CheckGroup_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(CheckGroup_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(CheckGroup_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, CheckGroup_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(CheckGroup_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(CheckGroup_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(CheckGroup_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(CheckGroup_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CheckGroup_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CheckGroup_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CheckGroup_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CheckGroup_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CheckGroup_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CheckGroup_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CheckGroup_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(CheckGroup_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, CheckGroup_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(CheckGroup_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, CheckGroup_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(CheckGroup_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn Checked(&self, index: i32) -> bool  {
          return method_Call_1!(CheckGroup_GetChecked, self.0, index);
      }

	  pub fn SetChecked(&self, index: i32, aValue: bool)  {
          method_Call_1!(CheckGroup_SetChecked, self.0, index, aValue);
      }

	  pub fn CheckEnabled(&self, index: i32) -> bool  {
          return method_Call_1!(CheckGroup_GetCheckEnabled, self.0, index);
      }

	  pub fn SetCheckEnabled(&self, index: i32, aValue: bool)  {
          method_Call_1!(CheckGroup_SetCheckEnabled, self.0, index, aValue);
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, CheckGroup_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, CheckGroup_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, CheckGroup_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, CheckGroup_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(CheckGroup_StaticClassType);
}

impl_IObject!(TCheckGroup);
impl_IComponent!(TCheckGroup);
impl_IControl!(TCheckGroup);
impl_IWinControl!(TCheckGroup);

impl TToggleBox {
      pub fn new(aOwner: &dyn IComponent) -> Self {
        method_Create!(TToggleBox, ToggleBox_Create, aOwner.Instance());
      }

      impl_As_method!(TToggleBox);

	  impl_Free_method!(ToggleBox_Free);

	  pub fn CanFocus(&self) -> bool {
          return method_Call_1!(ToggleBox_CanFocus, self.0);
      }

	  pub fn ContainsControl(&self, control: &dyn IControl) -> bool {
          return method_Call_1!(ToggleBox_ContainsControl, self.0, control.Instance());
      }

	  pub fn ControlAtPos(&self, pos: &TPoint, allowDisabled: bool, allowWinControls: bool) -> TControl {
          let mut ps1 = TPoint::From(pos);
          return method_Call_2!(TControl, ToggleBox_ControlAtPos, self.0, &mut ps1, allowDisabled, allowWinControls);
      }

	  pub fn DisableAlign(&self) {
          method_Call_1!(ToggleBox_DisableAlign, self.0);
      }

	  pub fn EnableAlign(&self) {
          method_Call_1!(ToggleBox_EnableAlign, self.0);
      }

	  pub fn FindChildControl(&self, controlName: &str) -> TControl {
          return method_Call_2!(TControl, ToggleBox_FindChildControl, self.0, to_CString!(controlName));
      }

	  pub fn FlipChildren(&self, allLevels: bool) {
          method_Call_1!(ToggleBox_FlipChildren, self.0, allLevels);
      }

	  pub fn Focused(&self) -> bool {
          return method_Call_1!(ToggleBox_Focused, self.0);
      }

	  pub fn HandleAllocated(&self) -> bool {
          return method_Call_1!(ToggleBox_HandleAllocated, self.0);
      }

	  pub fn InsertControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ToggleBox_InsertControl, self.0, aControl.Instance());
      }

	  pub fn Invalidate(&self) {
          method_Call_1!(ToggleBox_Invalidate, self.0);
      }

	  pub fn RemoveControl(&self, aControl: &dyn IControl) {
          method_Call_1!(ToggleBox_RemoveControl, self.0, aControl.Instance());
      }

	  pub fn Realign(&self) {
          method_Call_1!(ToggleBox_Realign, self.0);
      }

	  pub fn Repaint(&self) {
          method_Call_1!(ToggleBox_Repaint, self.0);
      }

	  pub fn ScaleBy(&self, m: i32, d: i32) {
          method_Call_1!(ToggleBox_ScaleBy, self.0, m, d);
      }

	  pub fn ScrollBy(&self, deltaX: i32, deltaY: i32) {
          method_Call_1!(ToggleBox_ScrollBy, self.0, deltaX, deltaY);
      }

	  pub fn SetBounds(&self, aLeft: i32, aTop: i32, aWidth: i32, aHeight: i32) {
          method_Call_1!(ToggleBox_SetBounds, self.0, aLeft, aTop, aWidth, aHeight);
      }

	  pub fn SetFocus(&self) {
          method_Call_1!(ToggleBox_SetFocus, self.0);
      }

	  pub fn Update(&self) {
          method_Call_1!(ToggleBox_Update, self.0);
      }

	  pub fn BringToFront(&self) {
          method_Call_1!(ToggleBox_BringToFront, self.0);
      }

	  pub fn ClientToScreen(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ToggleBox_ClientToScreen, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ClientToParent(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ToggleBox_ClientToParent, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn Dragging(&self) -> bool {
          return method_Call_1!(ToggleBox_Dragging, self.0);
      }

	  pub fn HasParent(&self) -> bool {
          return method_Call_1!(ToggleBox_HasParent, self.0);
      }

	  pub fn Hide(&self) {
          method_Call_1!(ToggleBox_Hide, self.0);
      }

	  pub fn Perform(&self, msg: u32, wParam: usize, lParam: isize) -> isize {
          return method_Call_1!(ToggleBox_Perform, self.0, msg, wParam, lParam);
      }

	  pub fn Refresh(&self) {
          method_Call_1!(ToggleBox_Refresh, self.0);
      }

	  pub fn ScreenToClient(&self, point: &TPoint) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ToggleBox_ScreenToClient, self.0, &mut ps1, &mut result);
          return result;
      }

	  pub fn ParentToClient(&self, point: &TPoint, aParent: &dyn IWinControl) -> TPoint {
          let mut result = TPoint::Empty();
          let mut ps1 = TPoint::From(point);
          method_Call_1!(ToggleBox_ParentToClient, self.0, &mut ps1, aParent.Instance(), &mut result);
          return result;
      }

	  pub fn SendToBack(&self) {
          method_Call_1!(ToggleBox_SendToBack, self.0);
      }

	  pub fn Show(&self) {
          method_Call_1!(ToggleBox_Show, self.0);
      }

	  pub fn GetTextBuf(&self, buffer: &str, bufSize: i32) -> i32 {
          return method_Call_1!(ToggleBox_GetTextBuf, self.0, to_CString!(buffer), bufSize);
      }

	  pub fn GetTextLen(&self) -> i32 {
          return method_Call_1!(ToggleBox_GetTextLen, self.0);
      }

	  pub fn SetTextBuf(&self, buffer: &str) {
          method_Call_1!(ToggleBox_SetTextBuf, self.0, to_CString!(buffer));
      }

	  pub fn FindComponent(&self, aName: &str) -> TComponent {
          return method_Call_2!(TComponent, ToggleBox_FindComponent, self.0, to_CString!(aName));
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ToggleBox_GetNamePath, self.0));
      }

	  pub fn Assign(&self, source: &dyn IObject) {
          method_Call_1!(ToggleBox_Assign, self.0, source.Instance());
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(ToggleBox_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ToggleBox_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(ToggleBox_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(ToggleBox_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(ToggleBox_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(ToggleBox_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(ToggleBox_ToString, self.0));
      }

	  pub fn AnchorToNeighbour(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ToggleBox_AnchorToNeighbour, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorParallel(&self, aSide: TAnchorKind, aSpace: i32, aSibling: &dyn IControl) {
          method_Call_1!(ToggleBox_AnchorParallel, self.0, aSide, aSpace, aSibling.Instance());
      }

	  pub fn AnchorHorizontalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ToggleBox_AnchorHorizontalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorVerticalCenterTo(&self, aSibling: &dyn IControl) {
          method_Call_1!(ToggleBox_AnchorVerticalCenterTo, self.0, aSibling.Instance());
      }

	  pub fn AnchorAsAlign(&self, aTheAlign: TAlign, aSpace: i32) {
          method_Call_1!(ToggleBox_AnchorAsAlign, self.0, aTheAlign, aSpace);
      }

	  pub fn AnchorClient(&self, aSpace: i32) {
          method_Call_1!(ToggleBox_AnchorClient, self.0, aSpace);
      }

	  pub fn AllowGrayed(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetAllowGrayed, self.0);
      }

	  pub fn SetAllowGrayed(&self, aValue: bool)  {
          method_Call_1!(ToggleBox_SetAllowGrayed, self.0, aValue);
      }

	  pub fn Align(&self) -> TAlign  {
          return method_Call_1!(ToggleBox_GetAlign, self.0);
      }

	  pub fn SetAlign(&self, aValue: TAlign)  {
          method_Call_1!(ToggleBox_SetAlign, self.0, aValue);
      }

	  pub fn Anchors(&self) -> TAnchors  {
          return method_Call_1!(ToggleBox_GetAnchors, self.0);
      }

	  pub fn SetAnchors(&self, aValue: TAnchors)  {
          method_Call_1!(ToggleBox_SetAnchors, self.0, aValue);
      }

	  pub fn AutoSize(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetAutoSize, self.0);
      }

	  pub fn SetAutoSize(&self, aValue: bool)  {
          method_Call_1!(ToggleBox_SetAutoSize, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ToggleBox_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(ToggleBox_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Checked(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetChecked, self.0);
      }

	  pub fn SetChecked(&self, aValue: bool)  {
          method_Call_1!(ToggleBox_SetChecked, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(ToggleBox_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(ToggleBox_SetColor, self.0, aValue);
      }

	  pub fn Constraints(&self) -> TSizeConstraints  {
          return method_Call_2!(TSizeConstraints, ToggleBox_GetConstraints, self.0);
      }

	  pub fn SetConstraints(&self, aValue: &TSizeConstraints)  {
          method_Call_1!(ToggleBox_SetConstraints, self.0, aValue.Instance());
      }

	  pub fn DoubleBuffered(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetDoubleBuffered, self.0);
      }

	  pub fn SetDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ToggleBox_SetDoubleBuffered, self.0, aValue);
      }

	  pub fn DragCursor(&self) -> TCursor  {
          return method_Call_1!(ToggleBox_GetDragCursor, self.0);
      }

	  pub fn SetDragCursor(&self, aValue: TCursor)  {
          method_Call_1!(ToggleBox_SetDragCursor, self.0, aValue);
      }

	  pub fn DragKind(&self) -> TDragKind  {
          return method_Call_1!(ToggleBox_GetDragKind, self.0);
      }

	  pub fn SetDragKind(&self, aValue: TDragKind)  {
          method_Call_1!(ToggleBox_SetDragKind, self.0, aValue);
      }

	  pub fn DragMode(&self) -> TDragMode  {
          return method_Call_1!(ToggleBox_GetDragMode, self.0);
      }

	  pub fn SetDragMode(&self, aValue: TDragMode)  {
          method_Call_1!(ToggleBox_SetDragMode, self.0, aValue);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetEnabled, self.0);
      }

	  pub fn SetEnabled(&self, aValue: bool)  {
          method_Call_1!(ToggleBox_SetEnabled, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, ToggleBox_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(ToggleBox_SetFont, self.0, aValue.Instance());
      }

	  pub fn Hint<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ToggleBox_GetHint, self.0));
      }

	  pub fn SetHint(&self, aValue: &str)  {
          method_Call_1!(ToggleBox_SetHint, self.0, to_CString!(aValue));
      }

	  pub fn SetOnChange(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToggleBox_SetOnChange, self.0, aEventId);
      }

	  pub fn SetOnClick(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToggleBox_SetOnClick, self.0, aEventId);
      }

	  pub fn SetOnDragDrop(&self, aEventId: TDragDropEvent)  {
          method_Call_1!(ToggleBox_SetOnDragDrop, self.0, aEventId);
      }

	  pub fn SetOnDragOver(&self, aEventId: TDragOverEvent)  {
          method_Call_1!(ToggleBox_SetOnDragOver, self.0, aEventId);
      }

	  pub fn SetOnEndDrag(&self, aEventId: TEndDragEvent)  {
          method_Call_1!(ToggleBox_SetOnEndDrag, self.0, aEventId);
      }

	  pub fn SetOnEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToggleBox_SetOnEnter, self.0, aEventId);
      }

	  pub fn SetOnExit(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToggleBox_SetOnExit, self.0, aEventId);
      }

	  pub fn SetOnMouseDown(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ToggleBox_SetOnMouseDown, self.0, aEventId);
      }

	  pub fn SetOnMouseEnter(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToggleBox_SetOnMouseEnter, self.0, aEventId);
      }

	  pub fn SetOnMouseLeave(&self, aEventId: TNotifyEvent)  {
          method_Call_1!(ToggleBox_SetOnMouseLeave, self.0, aEventId);
      }

	  pub fn SetOnMouseMove(&self, aEventId: TMouseMoveEvent)  {
          method_Call_1!(ToggleBox_SetOnMouseMove, self.0, aEventId);
      }

	  pub fn SetOnMouseUp(&self, aEventId: TMouseEvent)  {
          method_Call_1!(ToggleBox_SetOnMouseUp, self.0, aEventId);
      }

	  pub fn SetOnMouseWheel(&self, aEventId: TMouseWheelEvent)  {
          method_Call_1!(ToggleBox_SetOnMouseWheel, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelDown(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(ToggleBox_SetOnMouseWheelDown, self.0, aEventId);
      }

	  pub fn SetOnMouseWheelUp(&self, aEventId: TMouseWheelUpDownEvent)  {
          method_Call_1!(ToggleBox_SetOnMouseWheelUp, self.0, aEventId);
      }

	  pub fn ParentDoubleBuffered(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetParentDoubleBuffered, self.0);
      }

	  pub fn SetParentDoubleBuffered(&self, aValue: bool)  {
          method_Call_1!(ToggleBox_SetParentDoubleBuffered, self.0, aValue);
      }

	  pub fn ParentFont(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetParentFont, self.0);
      }

	  pub fn SetParentFont(&self, aValue: bool)  {
          method_Call_1!(ToggleBox_SetParentFont, self.0, aValue);
      }

	  pub fn ParentShowHint(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetParentShowHint, self.0);
      }

	  pub fn SetParentShowHint(&self, aValue: bool)  {
          method_Call_1!(ToggleBox_SetParentShowHint, self.0, aValue);
      }

	  pub fn PopupMenu(&self) -> TPopupMenu  {
          return method_Call_2!(TPopupMenu, ToggleBox_GetPopupMenu, self.0);
      }

	  pub fn SetPopupMenu(&self, aValue: &TPopupMenu)  {
          method_Call_1!(ToggleBox_SetPopupMenu, self.0, aValue.Instance());
      }

	  pub fn ShowHint(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetShowHint, self.0);
      }

	  pub fn SetShowHint(&self, aValue: bool)  {
          method_Call_1!(ToggleBox_SetShowHint, self.0, aValue);
      }

	  pub fn State(&self) -> TCheckBoxState  {
          return method_Call_1!(ToggleBox_GetState, self.0);
      }

	  pub fn SetState(&self, aValue: TCheckBoxState)  {
          method_Call_1!(ToggleBox_SetState, self.0, aValue);
      }

	  pub fn TabOrder(&self) -> TTabOrder  {
          return method_Call_1!(ToggleBox_GetTabOrder, self.0);
      }

	  pub fn SetTabOrder(&self, aValue: TTabOrder)  {
          method_Call_1!(ToggleBox_SetTabOrder, self.0, aValue);
      }

	  pub fn TabStop(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetTabStop, self.0);
      }

	  pub fn SetTabStop(&self, aValue: bool)  {
          method_Call_1!(ToggleBox_SetTabStop, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(ToggleBox_SetVisible, self.0, aValue);
      }

	  pub fn DockClientCount(&self) -> i32  {
          return method_Call_1!(ToggleBox_GetDockClientCount, self.0);
      }

	  pub fn DockSite(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetDockSite, self.0);
      }

	  pub fn SetDockSite(&self, aValue: bool)  {
          method_Call_1!(ToggleBox_SetDockSite, self.0, aValue);
      }

	  pub fn MouseInClient(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetMouseInClient, self.0);
      }

	  pub fn VisibleDockClientCount(&self) -> i32  {
          return method_Call_1!(ToggleBox_GetVisibleDockClientCount, self.0);
      }

	  pub fn Brush(&self) -> TBrush  {
          return method_Call_2!(TBrush, ToggleBox_GetBrush, self.0);
      }

	  pub fn ControlCount(&self) -> i32  {
          return method_Call_1!(ToggleBox_GetControlCount, self.0);
      }

	  pub fn Handle(&self) -> HWND  {
          return method_Call_1!(ToggleBox_GetHandle, self.0);
      }

	  pub fn ParentWindow(&self) -> HWND  {
          return method_Call_1!(ToggleBox_GetParentWindow, self.0);
      }

	  pub fn SetParentWindow(&self, aValue: HWND)  {
          method_Call_1!(ToggleBox_SetParentWindow, self.0, aValue);
      }

	  pub fn Showing(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetShowing, self.0);
      }

	  pub fn UseDockManager(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetUseDockManager, self.0);
      }

	  pub fn SetUseDockManager(&self, aValue: bool)  {
          method_Call_1!(ToggleBox_SetUseDockManager, self.0, aValue);
      }

	  pub fn Action(&self) -> TAction  {
          return method_Call_2!(TAction, ToggleBox_GetAction, self.0);
      }

	  pub fn SetAction(&self, aValue: &TAction)  {
          method_Call_1!(ToggleBox_SetAction, self.0, aValue.Instance());
      }

	  pub fn BiDiMode(&self) -> TBiDiMode  {
          return method_Call_1!(ToggleBox_GetBiDiMode, self.0);
      }

	  pub fn SetBiDiMode(&self, aValue: TBiDiMode)  {
          method_Call_1!(ToggleBox_SetBiDiMode, self.0, aValue);
      }

	  pub fn BoundsRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ToggleBox_GetBoundsRect, self.0, &mut result);
          return result;
      }

	  pub fn SetBoundsRect(&self, aValue: *mut TRect)  {
          method_Call_1!(ToggleBox_SetBoundsRect, self.0, aValue);
      }

	  pub fn ClientHeight(&self) -> i32  {
          return method_Call_1!(ToggleBox_GetClientHeight, self.0);
      }

	  pub fn SetClientHeight(&self, aValue: i32)  {
          method_Call_1!(ToggleBox_SetClientHeight, self.0, aValue);
      }

	  pub fn ClientOrigin(&self) -> TPoint  {
          let mut result = TPoint::Empty();
          method_Call_1!(ToggleBox_GetClientOrigin, self.0, &mut result);
          return result;
      }

	  pub fn ClientRect(&self) -> TRect  {
          let mut result = TRect::Empty();
          method_Call_1!(ToggleBox_GetClientRect, self.0, &mut result);
          return result;
      }

	  pub fn ClientWidth(&self) -> i32  {
          return method_Call_1!(ToggleBox_GetClientWidth, self.0);
      }

	  pub fn SetClientWidth(&self, aValue: i32)  {
          method_Call_1!(ToggleBox_SetClientWidth, self.0, aValue);
      }

	  pub fn ControlState(&self) -> TControlState  {
          return method_Call_1!(ToggleBox_GetControlState, self.0);
      }

	  pub fn SetControlState(&self, aValue: TControlState)  {
          method_Call_1!(ToggleBox_SetControlState, self.0, aValue);
      }

	  pub fn ControlStyle(&self) -> TControlStyle  {
          return method_Call_1!(ToggleBox_GetControlStyle, self.0);
      }

	  pub fn SetControlStyle(&self, aValue: TControlStyle)  {
          method_Call_1!(ToggleBox_SetControlStyle, self.0, aValue);
      }

	  pub fn Floating(&self) -> bool  {
          return method_Call_1!(ToggleBox_GetFloating, self.0);
      }

	  pub fn Parent(&self) -> TWinControl  {
          return method_Call_2!(TWinControl, ToggleBox_GetParent, self.0);
      }

	  pub fn SetParent(&self, aValue: &dyn IWinControl)  {
          method_Call_1!(ToggleBox_SetParent, self.0, aValue.Instance());
      }

	  pub fn Left(&self) -> i32  {
          return method_Call_1!(ToggleBox_GetLeft, self.0);
      }

	  pub fn SetLeft(&self, aValue: i32)  {
          method_Call_1!(ToggleBox_SetLeft, self.0, aValue);
      }

	  pub fn Top(&self) -> i32  {
          return method_Call_1!(ToggleBox_GetTop, self.0);
      }

	  pub fn SetTop(&self, aValue: i32)  {
          method_Call_1!(ToggleBox_SetTop, self.0, aValue);
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(ToggleBox_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(ToggleBox_SetWidth, self.0, aValue);
      }

	  pub fn Height(&self) -> i32  {
          return method_Call_1!(ToggleBox_GetHeight, self.0);
      }

	  pub fn SetHeight(&self, aValue: i32)  {
          method_Call_1!(ToggleBox_SetHeight, self.0, aValue);
      }

	  pub fn Cursor(&self) -> TCursor  {
          return method_Call_1!(ToggleBox_GetCursor, self.0);
      }

	  pub fn SetCursor(&self, aValue: TCursor)  {
          method_Call_1!(ToggleBox_SetCursor, self.0, aValue);
      }

	  pub fn ComponentCount(&self) -> i32  {
          return method_Call_1!(ToggleBox_GetComponentCount, self.0);
      }

	  pub fn ComponentIndex(&self) -> i32  {
          return method_Call_1!(ToggleBox_GetComponentIndex, self.0);
      }

	  pub fn SetComponentIndex(&self, aValue: i32)  {
          method_Call_1!(ToggleBox_SetComponentIndex, self.0, aValue);
      }

	  pub fn Owner(&self) -> TComponent  {
          return method_Call_2!(TComponent, ToggleBox_GetOwner, self.0);
      }

	  pub fn Name<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(ToggleBox_GetName, self.0));
      }

	  pub fn SetName(&self, aValue: &str)  {
          method_Call_1!(ToggleBox_SetName, self.0, to_CString!(aValue));
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(ToggleBox_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(ToggleBox_SetTag, self.0, aValue);
      }

	  pub fn AnchorSideLeft(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ToggleBox_GetAnchorSideLeft, self.0);
      }

	  pub fn SetAnchorSideLeft(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ToggleBox_SetAnchorSideLeft, self.0, aValue.Instance());
      }

	  pub fn AnchorSideTop(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ToggleBox_GetAnchorSideTop, self.0);
      }

	  pub fn SetAnchorSideTop(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ToggleBox_SetAnchorSideTop, self.0, aValue.Instance());
      }

	  pub fn AnchorSideRight(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ToggleBox_GetAnchorSideRight, self.0);
      }

	  pub fn SetAnchorSideRight(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ToggleBox_SetAnchorSideRight, self.0, aValue.Instance());
      }

	  pub fn AnchorSideBottom(&self) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ToggleBox_GetAnchorSideBottom, self.0);
      }

	  pub fn SetAnchorSideBottom(&self, aValue: &TAnchorSide)  {
          method_Call_1!(ToggleBox_SetAnchorSideBottom, self.0, aValue.Instance());
      }

	  pub fn ChildSizing(&self) -> TControlChildSizing  {
          return method_Call_2!(TControlChildSizing, ToggleBox_GetChildSizing, self.0);
      }

	  pub fn SetChildSizing(&self, aValue: &TControlChildSizing)  {
          method_Call_1!(ToggleBox_SetChildSizing, self.0, aValue.Instance());
      }

	  pub fn BorderSpacing(&self) -> TControlBorderSpacing  {
          return method_Call_2!(TControlBorderSpacing, ToggleBox_GetBorderSpacing, self.0);
      }

	  pub fn SetBorderSpacing(&self, aValue: &TControlBorderSpacing)  {
          method_Call_1!(ToggleBox_SetBorderSpacing, self.0, aValue.Instance());
      }

	  pub fn DockClients(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ToggleBox_GetDockClients, self.0, index);
      }

	  pub fn Controls(&self, index: i32) -> TControl  {
          return method_Call_2!(TControl, ToggleBox_GetControls, self.0, index);
      }

	  pub fn Components(&self, aIndex: i32) -> TComponent  {
          return method_Call_2!(TComponent, ToggleBox_GetComponents, self.0, aIndex);
      }

	  pub fn AnchorSide(&self, aKind: TAnchorKind) -> TAnchorSide  {
          return method_Call_2!(TAnchorSide, ToggleBox_GetAnchorSide, self.0, aKind);
      }

      // static class
	  impl_Class_method!(ToggleBox_StaticClassType);
}

impl_IObject!(TToggleBox);
impl_IComponent!(TToggleBox);
impl_IControl!(TToggleBox);
impl_IWinControl!(TToggleBox);

impl TGridColumnTitle {
	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(GridColumnTitle_Assign, self.0, source.Instance());
      }

	  pub fn FillTitleDefaultFont(&self)  {
          method_Call_1!(GridColumnTitle_FillTitleDefaultFont, self.0);
      }

	  pub fn IsDefault(&self) -> bool  {
          return method_Call_1!(GridColumnTitle_IsDefault, self.0);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(GridColumnTitle_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(GridColumnTitle_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(GridColumnTitle_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(GridColumnTitle_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(GridColumnTitle_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(GridColumnTitle_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(GridColumnTitle_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(GridColumnTitle_ToString, self.0));
      }

	  pub fn Column(&self) -> TGridColumn  {
          return method_Call_2!(TGridColumn, GridColumnTitle_GetColumn, self.0);
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(GridColumnTitle_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(GridColumnTitle_SetAlignment, self.0, aValue);
      }

	  pub fn Caption<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(GridColumnTitle_GetCaption, self.0));
      }

	  pub fn SetCaption(&self, aValue: &str)  {
          method_Call_1!(GridColumnTitle_SetCaption, self.0, to_CString!(aValue));
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(GridColumnTitle_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(GridColumnTitle_SetColor, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, GridColumnTitle_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(GridColumnTitle_SetFont, self.0, aValue.Instance());
      }

	  pub fn ImageIndex(&self) -> i32  {
          return method_Call_1!(GridColumnTitle_GetImageIndex, self.0);
      }

	  pub fn SetImageIndex(&self, aValue: i32)  {
          method_Call_1!(GridColumnTitle_SetImageIndex, self.0, aValue);
      }

	  pub fn ImageLayout(&self) -> TButtonLayout  {
          return method_Call_1!(GridColumnTitle_GetImageLayout, self.0);
      }

	  pub fn SetImageLayout(&self, aValue: TButtonLayout)  {
          method_Call_1!(GridColumnTitle_SetImageLayout, self.0, aValue);
      }

	  pub fn Layout(&self) -> TTextLayout  {
          return method_Call_1!(GridColumnTitle_GetLayout, self.0);
      }

	  pub fn SetLayout(&self, aValue: TTextLayout)  {
          method_Call_1!(GridColumnTitle_SetLayout, self.0, aValue);
      }

	  pub fn MultiLine(&self) -> bool  {
          return method_Call_1!(GridColumnTitle_GetMultiLine, self.0);
      }

	  pub fn SetMultiLine(&self, aValue: bool)  {
          method_Call_1!(GridColumnTitle_SetMultiLine, self.0, aValue);
      }

	  pub fn PrefixOption(&self) -> TPrefixOption  {
          return method_Call_1!(GridColumnTitle_GetPrefixOption, self.0);
      }

	  pub fn SetPrefixOption(&self, aValue: TPrefixOption)  {
          method_Call_1!(GridColumnTitle_SetPrefixOption, self.0, aValue);
      }

      // static class
	  impl_Class_method!(GridColumnTitle_StaticClassType);
}

impl_IObject!(TGridColumnTitle);

impl TGridColumn {
	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(GridColumn_Assign, self.0, source.Instance());
      }

	  pub fn IsDefault(&self) -> bool  {
          return method_Call_1!(GridColumn_IsDefault, self.0);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(GridColumn_GetNamePath, self.0));
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(GridColumn_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(GridColumn_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(GridColumn_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(GridColumn_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(GridColumn_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(GridColumn_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(GridColumn_ToString, self.0));
      }

	  pub fn Grid(&self) -> TStringGrid  {
          return method_Call_2!(TStringGrid, GridColumn_GetGrid, self.0);
      }

	  pub fn DefaultWidth(&self) -> i32  {
          return method_Call_1!(GridColumn_GetDefaultWidth, self.0);
      }

	  pub fn StoredWidth(&self) -> i32  {
          return method_Call_1!(GridColumn_GetStoredWidth, self.0);
      }

	  pub fn WidthChanged(&self) -> bool  {
          return method_Call_1!(GridColumn_GetWidthChanged, self.0);
      }

	  pub fn Alignment(&self) -> TAlignment  {
          return method_Call_1!(GridColumn_GetAlignment, self.0);
      }

	  pub fn SetAlignment(&self, aValue: TAlignment)  {
          method_Call_1!(GridColumn_SetAlignment, self.0, aValue);
      }

	  pub fn ButtonStyle(&self) -> TColumnButtonStyle  {
          return method_Call_1!(GridColumn_GetButtonStyle, self.0);
      }

	  pub fn SetButtonStyle(&self, aValue: TColumnButtonStyle)  {
          method_Call_1!(GridColumn_SetButtonStyle, self.0, aValue);
      }

	  pub fn Color(&self) -> TColor  {
          return method_Call_1!(GridColumn_GetColor, self.0);
      }

	  pub fn SetColor(&self, aValue: TColor)  {
          method_Call_1!(GridColumn_SetColor, self.0, aValue);
      }

	  pub fn DropDownRows(&self) -> i32  {
          return method_Call_1!(GridColumn_GetDropDownRows, self.0);
      }

	  pub fn SetDropDownRows(&self, aValue: i32)  {
          method_Call_1!(GridColumn_SetDropDownRows, self.0, aValue);
      }

	  pub fn Expanded(&self) -> bool  {
          return method_Call_1!(GridColumn_GetExpanded, self.0);
      }

	  pub fn SetExpanded(&self, aValue: bool)  {
          method_Call_1!(GridColumn_SetExpanded, self.0, aValue);
      }

	  pub fn Font(&self) -> TFont  {
          return method_Call_2!(TFont, GridColumn_GetFont, self.0);
      }

	  pub fn SetFont(&self, aValue: &TFont)  {
          method_Call_1!(GridColumn_SetFont, self.0, aValue.Instance());
      }

	  pub fn Layout(&self) -> TTextLayout  {
          return method_Call_1!(GridColumn_GetLayout, self.0);
      }

	  pub fn SetLayout(&self, aValue: TTextLayout)  {
          method_Call_1!(GridColumn_SetLayout, self.0, aValue);
      }

	  pub fn MinSize(&self) -> i32  {
          return method_Call_1!(GridColumn_GetMinSize, self.0);
      }

	  pub fn SetMinSize(&self, aValue: i32)  {
          method_Call_1!(GridColumn_SetMinSize, self.0, aValue);
      }

	  pub fn MaxSize(&self) -> i32  {
          return method_Call_1!(GridColumn_GetMaxSize, self.0);
      }

	  pub fn SetMaxSize(&self, aValue: i32)  {
          method_Call_1!(GridColumn_SetMaxSize, self.0, aValue);
      }

	  pub fn PickList(&self) -> TStrings  {
          return method_Call_2!(TStrings, GridColumn_GetPickList, self.0);
      }

	  pub fn SetPickList(&self, aValue: &dyn IStrings)  {
          method_Call_1!(GridColumn_SetPickList, self.0, aValue.Instance());
      }

	  pub fn ReadOnly(&self) -> bool  {
          return method_Call_1!(GridColumn_GetReadOnly, self.0);
      }

	  pub fn SetReadOnly(&self, aValue: bool)  {
          method_Call_1!(GridColumn_SetReadOnly, self.0, aValue);
      }

	  pub fn SizePriority(&self) -> i32  {
          return method_Call_1!(GridColumn_GetSizePriority, self.0);
      }

	  pub fn SetSizePriority(&self, aValue: i32)  {
          method_Call_1!(GridColumn_SetSizePriority, self.0, aValue);
      }

	  pub fn Tag(&self) -> isize  {
          return method_Call_1!(GridColumn_GetTag, self.0);
      }

	  pub fn SetTag(&self, aValue: isize)  {
          method_Call_1!(GridColumn_SetTag, self.0, aValue);
      }

	  pub fn Title(&self) -> TGridColumnTitle  {
          return method_Call_2!(TGridColumnTitle, GridColumn_GetTitle, self.0);
      }

	  pub fn SetTitle(&self, aValue: &TGridColumnTitle)  {
          method_Call_1!(GridColumn_SetTitle, self.0, aValue.Instance());
      }

	  pub fn Width(&self) -> i32  {
          return method_Call_1!(GridColumn_GetWidth, self.0);
      }

	  pub fn SetWidth(&self, aValue: i32)  {
          method_Call_1!(GridColumn_SetWidth, self.0, aValue);
      }

	  pub fn Visible(&self) -> bool  {
          return method_Call_1!(GridColumn_GetVisible, self.0);
      }

	  pub fn SetVisible(&self, aValue: bool)  {
          method_Call_1!(GridColumn_SetVisible, self.0, aValue);
      }

	  pub fn ValueChecked<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(GridColumn_GetValueChecked, self.0));
      }

	  pub fn SetValueChecked(&self, aValue: &str)  {
          method_Call_1!(GridColumn_SetValueChecked, self.0, to_CString!(aValue));
      }

	  pub fn ValueUnchecked<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(GridColumn_GetValueUnchecked, self.0));
      }

	  pub fn SetValueUnchecked(&self, aValue: &str)  {
          method_Call_1!(GridColumn_SetValueUnchecked, self.0, to_CString!(aValue));
      }

	  pub fn Collection(&self) -> TCollection  {
          return method_Call_2!(TCollection, GridColumn_GetCollection, self.0);
      }

	  pub fn SetCollection(&self, aValue: &TCollection)  {
          method_Call_1!(GridColumn_SetCollection, self.0, aValue.Instance());
      }

	  pub fn Index(&self) -> i32  {
          return method_Call_1!(GridColumn_GetIndex, self.0);
      }

	  pub fn SetIndex(&self, aValue: i32)  {
          method_Call_1!(GridColumn_SetIndex, self.0, aValue);
      }

	  pub fn DisplayName<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(GridColumn_GetDisplayName, self.0));
      }

	  pub fn SetDisplayName(&self, aValue: &str)  {
          method_Call_1!(GridColumn_SetDisplayName, self.0, to_CString!(aValue));
      }

      // static class
	  impl_Class_method!(GridColumn_StaticClassType);
}

impl_IObject!(TGridColumn);

impl TGridColumns {
	  pub fn Add(&self) -> TGridColumn  {
          return method_Call_2!(TGridColumn, GridColumns_Add, self.0);
      }

	  pub fn Clear(&self)  {
          method_Call_1!(GridColumns_Clear, self.0);
      }

	  pub fn RealIndex(&self, index: i32) -> i32  {
          return method_Call_1!(GridColumns_RealIndex, self.0, index);
      }

	  pub fn IndexOf(&self, column: &TGridColumn) -> i32  {
          return method_Call_1!(GridColumns_IndexOf, self.0, column.Instance());
      }

	  pub fn IsDefault(&self) -> bool  {
          return method_Call_1!(GridColumns_IsDefault, self.0);
      }

	  pub fn HasIndex(&self, index: i32) -> bool  {
          return method_Call_1!(GridColumns_HasIndex, self.0, index);
      }

	  pub fn Owner(&self) -> TObject  {
          return method_Call_2!(TObject, GridColumns_Owner, self.0);
      }

	  pub fn Assign(&self, source: &dyn IObject)  {
          method_Call_1!(GridColumns_Assign, self.0, source.Instance());
      }

	  pub fn BeginUpdate(&self)  {
          method_Call_1!(GridColumns_BeginUpdate, self.0);
      }

	  pub fn Delete(&self, index: i32)  {
          method_Call_1!(GridColumns_Delete, self.0, index);
      }

	  pub fn EndUpdate(&self)  {
          method_Call_1!(GridColumns_EndUpdate, self.0);
      }

	  pub fn FindItemID(&self, iD: i32) -> TCollectionItem  {
          return method_Call_2!(TCollectionItem, GridColumns_FindItemID, self.0, iD);
      }

	  pub fn GetNamePath<'a>(&self) -> Cow<'a, str>  {
          return to_RustString!(method_Call_1!(GridColumns_GetNamePath, self.0));
      }

	  pub fn Insert(&self, index: i32) -> TCollectionItem  {
          return method_Call_2!(TCollectionItem, GridColumns_Insert, self.0, index);
      }

	  pub fn ClassType(&self) -> TClass {
          return method_Call_1!(GridColumns_ClassType, self.0);
      }

	  pub fn ClassName<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(GridColumns_ClassName, self.0));
      }

	  pub fn InstanceSize(&self) -> i32 {
          return method_Call_1!(GridColumns_InstanceSize, self.0);
      }

	  pub fn InheritsFrom(&self, aClass: TClass) -> bool {
          return method_Call_1!(GridColumns_InheritsFrom, self.0, aClass);
      }

	  pub fn Equals(&self, obj: &dyn IObject) -> bool {
          return method_Call_1!(GridColumns_Equals, self.0, obj.Instance());
      }

	  pub fn GetHashCode(&self) -> i32 {
          return method_Call_1!(GridColumns_GetHashCode, self.0);
      }

	  pub fn ToString<'a>(&self) -> Cow<'a, str> {
          return to_RustString!(method_Call_1!(GridColumns_ToString, self.0));
      }

	  pub fn Grid(&self) -> TStringGrid  {
          return method_Call_2!(TStringGrid, GridColumns_GetGrid, self.0);
      }

	  pub fn VisibleCount(&self) -> i32  {
          return method_Call_1!(GridColumns_GetVisibleCount, self.0);
      }

	  pub fn Enabled(&self) -> bool  {
          return method_Call_1!(GridColumns_GetEnabled, self.0);
      }

	  pub fn Count(&self) -> i32  {
          return method_Call_1!(GridColumns_GetCount, self.0);
      }

	  pub fn Items(&self, index: i32) -> TGridColumn  {
          return method_Call_2!(TGridColumn, GridColumns_GetItems, self.0, index);
      }

	  pub fn SetItems(&self, index: i32, aValue: &TGridColumn)  {
          method_Call_1!(GridColumns_SetItems, self.0, index, aValue.Instance());
      }

      // static class
	  impl_Class_method!(GridColumns_StaticClassType);
}

impl_IObject!(TGridColumns);


pub fn NullObject() -> TObject {
   TObject { 0: 0, 1: false, }
}

fn getApplication() -> TApplication {
   initLibLCLCallback();
   TApplication {
       0: unsafe { Application_Instance() }, 1: false,
   }
}

// ------------------------------------ global vars ------------------------------------

lazy_static! {
    pub static ref Application: TApplication = getApplication();
    pub static ref Screen: TScreen = TScreen::As(unsafe { Screen_Instance() });
    pub static ref Mouse: TMouse = TMouse::As(unsafe { Mouse_Instance() });
    pub static ref Clipboard: TClipboard = TClipboard::As(unsafe { Clipboard_Instance() });
    pub static ref Printer: TPrinter = TPrinter::As(unsafe { Printer_Instance() });
}
